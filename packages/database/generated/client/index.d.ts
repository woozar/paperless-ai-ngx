/**
 * Client
 **/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Setting
 *
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model UserPaperlessInstanceAccess
 *
 */
export type UserPaperlessInstanceAccess =
  $Result.DefaultSelection<Prisma.$UserPaperlessInstanceAccessPayload>;
/**
 * Model UserAiAccountAccess
 *
 */
export type UserAiAccountAccess = $Result.DefaultSelection<Prisma.$UserAiAccountAccessPayload>;
/**
 * Model UserAiModelAccess
 *
 */
export type UserAiModelAccess = $Result.DefaultSelection<Prisma.$UserAiModelAccessPayload>;
/**
 * Model UserAiBotAccess
 *
 */
export type UserAiBotAccess = $Result.DefaultSelection<Prisma.$UserAiBotAccessPayload>;
/**
 * Model PaperlessInstance
 *
 */
export type PaperlessInstance = $Result.DefaultSelection<Prisma.$PaperlessInstancePayload>;
/**
 * Model AiAccount
 *
 */
export type AiAccount = $Result.DefaultSelection<Prisma.$AiAccountPayload>;
/**
 * Model AiModel
 *
 */
export type AiModel = $Result.DefaultSelection<Prisma.$AiModelPayload>;
/**
 * Model AiBot
 *
 */
export type AiBot = $Result.DefaultSelection<Prisma.$AiBotPayload>;
/**
 * Model PaperlessDocument
 *
 */
export type PaperlessDocument = $Result.DefaultSelection<Prisma.$PaperlessDocumentPayload>;
/**
 * Model DocumentProcessingResult
 *
 */
export type DocumentProcessingResult =
  $Result.DefaultSelection<Prisma.$DocumentProcessingResultPayload>;
/**
 * Model ProcessingQueue
 *
 */
export type ProcessingQueue = $Result.DefaultSelection<Prisma.$ProcessingQueuePayload>;
/**
 * Model ImportHistory
 *
 */
export type ImportHistory = $Result.DefaultSelection<Prisma.$ImportHistoryPayload>;
/**
 * Model AiUsageMetric
 *
 */
export type AiUsageMetric = $Result.DefaultSelection<Prisma.$AiUsageMetricPayload>;
/**
 * Model WebAuthnCredential
 *
 */
export type WebAuthnCredential = $Result.DefaultSelection<Prisma.$WebAuthnCredentialPayload>;
/**
 * Model WebAuthnChallenge
 *
 */
export type WebAuthnChallenge = $Result.DefaultSelection<Prisma.$WebAuthnChallengePayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
    DEFAULT: 'DEFAULT';
    ADMIN: 'ADMIN';
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const Permission: {
    READ: 'READ';
    WRITE: 'WRITE';
    FULL: 'FULL';
  };

  export type Permission = (typeof Permission)[keyof typeof Permission];
}

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type Permission = $Enums.Permission;

export const Permission: typeof $Enums.Permission;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Settings
 * const settings = await prisma.setting.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Settings
   * const settings = await prisma.setting.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(
    eventType: V,
    callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Settings
   * const settings = await prisma.setting.findMany()
   * ```
   */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPaperlessInstanceAccess`: Exposes CRUD operations for the **UserPaperlessInstanceAccess** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserPaperlessInstanceAccesses
   * const userPaperlessInstanceAccesses = await prisma.userPaperlessInstanceAccess.findMany()
   * ```
   */
  get userPaperlessInstanceAccess(): Prisma.UserPaperlessInstanceAccessDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.userAiAccountAccess`: Exposes CRUD operations for the **UserAiAccountAccess** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserAiAccountAccesses
   * const userAiAccountAccesses = await prisma.userAiAccountAccess.findMany()
   * ```
   */
  get userAiAccountAccess(): Prisma.UserAiAccountAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAiModelAccess`: Exposes CRUD operations for the **UserAiModelAccess** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserAiModelAccesses
   * const userAiModelAccesses = await prisma.userAiModelAccess.findMany()
   * ```
   */
  get userAiModelAccess(): Prisma.UserAiModelAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAiBotAccess`: Exposes CRUD operations for the **UserAiBotAccess** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserAiBotAccesses
   * const userAiBotAccesses = await prisma.userAiBotAccess.findMany()
   * ```
   */
  get userAiBotAccess(): Prisma.UserAiBotAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paperlessInstance`: Exposes CRUD operations for the **PaperlessInstance** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PaperlessInstances
   * const paperlessInstances = await prisma.paperlessInstance.findMany()
   * ```
   */
  get paperlessInstance(): Prisma.PaperlessInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiAccount`: Exposes CRUD operations for the **AiAccount** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AiAccounts
   * const aiAccounts = await prisma.aiAccount.findMany()
   * ```
   */
  get aiAccount(): Prisma.AiAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiModel`: Exposes CRUD operations for the **AiModel** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AiModels
   * const aiModels = await prisma.aiModel.findMany()
   * ```
   */
  get aiModel(): Prisma.AiModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiBot`: Exposes CRUD operations for the **AiBot** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AiBots
   * const aiBots = await prisma.aiBot.findMany()
   * ```
   */
  get aiBot(): Prisma.AiBotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paperlessDocument`: Exposes CRUD operations for the **PaperlessDocument** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PaperlessDocuments
   * const paperlessDocuments = await prisma.paperlessDocument.findMany()
   * ```
   */
  get paperlessDocument(): Prisma.PaperlessDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentProcessingResult`: Exposes CRUD operations for the **DocumentProcessingResult** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DocumentProcessingResults
   * const documentProcessingResults = await prisma.documentProcessingResult.findMany()
   * ```
   */
  get documentProcessingResult(): Prisma.DocumentProcessingResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.processingQueue`: Exposes CRUD operations for the **ProcessingQueue** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ProcessingQueues
   * const processingQueues = await prisma.processingQueue.findMany()
   * ```
   */
  get processingQueue(): Prisma.ProcessingQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importHistory`: Exposes CRUD operations for the **ImportHistory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ImportHistories
   * const importHistories = await prisma.importHistory.findMany()
   * ```
   */
  get importHistory(): Prisma.ImportHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aiUsageMetric`: Exposes CRUD operations for the **AiUsageMetric** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AiUsageMetrics
   * const aiUsageMetrics = await prisma.aiUsageMetric.findMany()
   * ```
   */
  get aiUsageMetric(): Prisma.AiUsageMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webAuthnCredential`: Exposes CRUD operations for the **WebAuthnCredential** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more WebAuthnCredentials
   * const webAuthnCredentials = await prisma.webAuthnCredential.findMany()
   * ```
   */
  get webAuthnCredential(): Prisma.WebAuthnCredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webAuthnChallenge`: Exposes CRUD operations for the **WebAuthnChallenge** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more WebAuthnChallenges
   * const webAuthnChallenges = await prisma.webAuthnChallenge.findMany()
   * ```
   */
  get webAuthnChallenge(): Prisma.WebAuthnChallengeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string;
    engine: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
    ReturnType<T>
  >;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
    ? _Either<O, K, strict>
    : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
    k: infer I
  ) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
    IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
    T,
    MaybeTupleToUnion<K>
  >;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Setting: 'Setting';
    User: 'User';
    UserPaperlessInstanceAccess: 'UserPaperlessInstanceAccess';
    UserAiAccountAccess: 'UserAiAccountAccess';
    UserAiModelAccess: 'UserAiModelAccess';
    UserAiBotAccess: 'UserAiBotAccess';
    PaperlessInstance: 'PaperlessInstance';
    AiAccount: 'AiAccount';
    AiModel: 'AiModel';
    AiBot: 'AiBot';
    PaperlessDocument: 'PaperlessDocument';
    DocumentProcessingResult: 'DocumentProcessingResult';
    ProcessingQueue: 'ProcessingQueue';
    ImportHistory: 'ImportHistory';
    AiUsageMetric: 'AiUsageMetric';
    WebAuthnCredential: 'WebAuthnCredential';
    WebAuthnChallenge: 'WebAuthnChallenge';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  interface TypeMapCb<ClientOptions = {}>
    extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'setting'
        | 'user'
        | 'userPaperlessInstanceAccess'
        | 'userAiAccountAccess'
        | 'userAiModelAccess'
        | 'userAiBotAccess'
        | 'paperlessInstance'
        | 'aiAccount'
        | 'aiModel'
        | 'aiBot'
        | 'paperlessDocument'
        | 'documentProcessingResult'
        | 'processingQueue'
        | 'importHistory'
        | 'aiUsageMetric'
        | 'webAuthnCredential'
        | 'webAuthnChallenge';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>;
        fields: Prisma.SettingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[];
          };
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[];
          };
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[];
          };
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>;
          };
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSetting>;
          };
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SettingGroupByOutputType>[];
          };
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>;
            result: $Utils.Optional<SettingCountAggregateOutputType> | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      UserPaperlessInstanceAccess: {
        payload: Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>;
        fields: Prisma.UserPaperlessInstanceAccessFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserPaperlessInstanceAccessFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserPaperlessInstanceAccessFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>;
          };
          findFirst: {
            args: Prisma.UserPaperlessInstanceAccessFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserPaperlessInstanceAccessFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>;
          };
          findMany: {
            args: Prisma.UserPaperlessInstanceAccessFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>[];
          };
          create: {
            args: Prisma.UserPaperlessInstanceAccessCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>;
          };
          createMany: {
            args: Prisma.UserPaperlessInstanceAccessCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserPaperlessInstanceAccessCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>[];
          };
          delete: {
            args: Prisma.UserPaperlessInstanceAccessDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>;
          };
          update: {
            args: Prisma.UserPaperlessInstanceAccessUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>;
          };
          deleteMany: {
            args: Prisma.UserPaperlessInstanceAccessDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserPaperlessInstanceAccessUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserPaperlessInstanceAccessUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>[];
          };
          upsert: {
            args: Prisma.UserPaperlessInstanceAccessUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPaperlessInstanceAccessPayload>;
          };
          aggregate: {
            args: Prisma.UserPaperlessInstanceAccessAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserPaperlessInstanceAccess>;
          };
          groupBy: {
            args: Prisma.UserPaperlessInstanceAccessGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserPaperlessInstanceAccessGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserPaperlessInstanceAccessCountArgs<ExtArgs>;
            result: $Utils.Optional<UserPaperlessInstanceAccessCountAggregateOutputType> | number;
          };
        };
      };
      UserAiAccountAccess: {
        payload: Prisma.$UserAiAccountAccessPayload<ExtArgs>;
        fields: Prisma.UserAiAccountAccessFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserAiAccountAccessFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserAiAccountAccessFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>;
          };
          findFirst: {
            args: Prisma.UserAiAccountAccessFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserAiAccountAccessFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>;
          };
          findMany: {
            args: Prisma.UserAiAccountAccessFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>[];
          };
          create: {
            args: Prisma.UserAiAccountAccessCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>;
          };
          createMany: {
            args: Prisma.UserAiAccountAccessCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserAiAccountAccessCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>[];
          };
          delete: {
            args: Prisma.UserAiAccountAccessDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>;
          };
          update: {
            args: Prisma.UserAiAccountAccessUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>;
          };
          deleteMany: {
            args: Prisma.UserAiAccountAccessDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserAiAccountAccessUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserAiAccountAccessUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>[];
          };
          upsert: {
            args: Prisma.UserAiAccountAccessUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiAccountAccessPayload>;
          };
          aggregate: {
            args: Prisma.UserAiAccountAccessAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserAiAccountAccess>;
          };
          groupBy: {
            args: Prisma.UserAiAccountAccessGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserAiAccountAccessGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserAiAccountAccessCountArgs<ExtArgs>;
            result: $Utils.Optional<UserAiAccountAccessCountAggregateOutputType> | number;
          };
        };
      };
      UserAiModelAccess: {
        payload: Prisma.$UserAiModelAccessPayload<ExtArgs>;
        fields: Prisma.UserAiModelAccessFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserAiModelAccessFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserAiModelAccessFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>;
          };
          findFirst: {
            args: Prisma.UserAiModelAccessFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserAiModelAccessFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>;
          };
          findMany: {
            args: Prisma.UserAiModelAccessFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>[];
          };
          create: {
            args: Prisma.UserAiModelAccessCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>;
          };
          createMany: {
            args: Prisma.UserAiModelAccessCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserAiModelAccessCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>[];
          };
          delete: {
            args: Prisma.UserAiModelAccessDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>;
          };
          update: {
            args: Prisma.UserAiModelAccessUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>;
          };
          deleteMany: {
            args: Prisma.UserAiModelAccessDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserAiModelAccessUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserAiModelAccessUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>[];
          };
          upsert: {
            args: Prisma.UserAiModelAccessUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiModelAccessPayload>;
          };
          aggregate: {
            args: Prisma.UserAiModelAccessAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserAiModelAccess>;
          };
          groupBy: {
            args: Prisma.UserAiModelAccessGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserAiModelAccessGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserAiModelAccessCountArgs<ExtArgs>;
            result: $Utils.Optional<UserAiModelAccessCountAggregateOutputType> | number;
          };
        };
      };
      UserAiBotAccess: {
        payload: Prisma.$UserAiBotAccessPayload<ExtArgs>;
        fields: Prisma.UserAiBotAccessFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserAiBotAccessFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserAiBotAccessFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>;
          };
          findFirst: {
            args: Prisma.UserAiBotAccessFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserAiBotAccessFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>;
          };
          findMany: {
            args: Prisma.UserAiBotAccessFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>[];
          };
          create: {
            args: Prisma.UserAiBotAccessCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>;
          };
          createMany: {
            args: Prisma.UserAiBotAccessCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserAiBotAccessCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>[];
          };
          delete: {
            args: Prisma.UserAiBotAccessDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>;
          };
          update: {
            args: Prisma.UserAiBotAccessUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>;
          };
          deleteMany: {
            args: Prisma.UserAiBotAccessDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserAiBotAccessUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserAiBotAccessUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>[];
          };
          upsert: {
            args: Prisma.UserAiBotAccessUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserAiBotAccessPayload>;
          };
          aggregate: {
            args: Prisma.UserAiBotAccessAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserAiBotAccess>;
          };
          groupBy: {
            args: Prisma.UserAiBotAccessGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserAiBotAccessGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserAiBotAccessCountArgs<ExtArgs>;
            result: $Utils.Optional<UserAiBotAccessCountAggregateOutputType> | number;
          };
        };
      };
      PaperlessInstance: {
        payload: Prisma.$PaperlessInstancePayload<ExtArgs>;
        fields: Prisma.PaperlessInstanceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaperlessInstanceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaperlessInstanceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>;
          };
          findFirst: {
            args: Prisma.PaperlessInstanceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaperlessInstanceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>;
          };
          findMany: {
            args: Prisma.PaperlessInstanceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>[];
          };
          create: {
            args: Prisma.PaperlessInstanceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>;
          };
          createMany: {
            args: Prisma.PaperlessInstanceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PaperlessInstanceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>[];
          };
          delete: {
            args: Prisma.PaperlessInstanceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>;
          };
          update: {
            args: Prisma.PaperlessInstanceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>;
          };
          deleteMany: {
            args: Prisma.PaperlessInstanceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaperlessInstanceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PaperlessInstanceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>[];
          };
          upsert: {
            args: Prisma.PaperlessInstanceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessInstancePayload>;
          };
          aggregate: {
            args: Prisma.PaperlessInstanceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePaperlessInstance>;
          };
          groupBy: {
            args: Prisma.PaperlessInstanceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaperlessInstanceGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaperlessInstanceCountArgs<ExtArgs>;
            result: $Utils.Optional<PaperlessInstanceCountAggregateOutputType> | number;
          };
        };
      };
      AiAccount: {
        payload: Prisma.$AiAccountPayload<ExtArgs>;
        fields: Prisma.AiAccountFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AiAccountFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AiAccountFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>;
          };
          findFirst: {
            args: Prisma.AiAccountFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AiAccountFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>;
          };
          findMany: {
            args: Prisma.AiAccountFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>[];
          };
          create: {
            args: Prisma.AiAccountCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>;
          };
          createMany: {
            args: Prisma.AiAccountCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AiAccountCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>[];
          };
          delete: {
            args: Prisma.AiAccountDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>;
          };
          update: {
            args: Prisma.AiAccountUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>;
          };
          deleteMany: {
            args: Prisma.AiAccountDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AiAccountUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AiAccountUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>[];
          };
          upsert: {
            args: Prisma.AiAccountUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiAccountPayload>;
          };
          aggregate: {
            args: Prisma.AiAccountAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAiAccount>;
          };
          groupBy: {
            args: Prisma.AiAccountGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AiAccountGroupByOutputType>[];
          };
          count: {
            args: Prisma.AiAccountCountArgs<ExtArgs>;
            result: $Utils.Optional<AiAccountCountAggregateOutputType> | number;
          };
        };
      };
      AiModel: {
        payload: Prisma.$AiModelPayload<ExtArgs>;
        fields: Prisma.AiModelFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AiModelFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AiModelFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>;
          };
          findFirst: {
            args: Prisma.AiModelFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AiModelFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>;
          };
          findMany: {
            args: Prisma.AiModelFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>[];
          };
          create: {
            args: Prisma.AiModelCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>;
          };
          createMany: {
            args: Prisma.AiModelCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AiModelCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>[];
          };
          delete: {
            args: Prisma.AiModelDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>;
          };
          update: {
            args: Prisma.AiModelUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>;
          };
          deleteMany: {
            args: Prisma.AiModelDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AiModelUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AiModelUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>[];
          };
          upsert: {
            args: Prisma.AiModelUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiModelPayload>;
          };
          aggregate: {
            args: Prisma.AiModelAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAiModel>;
          };
          groupBy: {
            args: Prisma.AiModelGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AiModelGroupByOutputType>[];
          };
          count: {
            args: Prisma.AiModelCountArgs<ExtArgs>;
            result: $Utils.Optional<AiModelCountAggregateOutputType> | number;
          };
        };
      };
      AiBot: {
        payload: Prisma.$AiBotPayload<ExtArgs>;
        fields: Prisma.AiBotFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AiBotFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AiBotFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>;
          };
          findFirst: {
            args: Prisma.AiBotFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AiBotFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>;
          };
          findMany: {
            args: Prisma.AiBotFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>[];
          };
          create: {
            args: Prisma.AiBotCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>;
          };
          createMany: {
            args: Prisma.AiBotCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AiBotCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>[];
          };
          delete: {
            args: Prisma.AiBotDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>;
          };
          update: {
            args: Prisma.AiBotUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>;
          };
          deleteMany: {
            args: Prisma.AiBotDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AiBotUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AiBotUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>[];
          };
          upsert: {
            args: Prisma.AiBotUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiBotPayload>;
          };
          aggregate: {
            args: Prisma.AiBotAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAiBot>;
          };
          groupBy: {
            args: Prisma.AiBotGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AiBotGroupByOutputType>[];
          };
          count: {
            args: Prisma.AiBotCountArgs<ExtArgs>;
            result: $Utils.Optional<AiBotCountAggregateOutputType> | number;
          };
        };
      };
      PaperlessDocument: {
        payload: Prisma.$PaperlessDocumentPayload<ExtArgs>;
        fields: Prisma.PaperlessDocumentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaperlessDocumentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaperlessDocumentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>;
          };
          findFirst: {
            args: Prisma.PaperlessDocumentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaperlessDocumentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>;
          };
          findMany: {
            args: Prisma.PaperlessDocumentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>[];
          };
          create: {
            args: Prisma.PaperlessDocumentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>;
          };
          createMany: {
            args: Prisma.PaperlessDocumentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PaperlessDocumentCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>[];
          };
          delete: {
            args: Prisma.PaperlessDocumentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>;
          };
          update: {
            args: Prisma.PaperlessDocumentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>;
          };
          deleteMany: {
            args: Prisma.PaperlessDocumentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaperlessDocumentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.PaperlessDocumentUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>[];
          };
          upsert: {
            args: Prisma.PaperlessDocumentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaperlessDocumentPayload>;
          };
          aggregate: {
            args: Prisma.PaperlessDocumentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePaperlessDocument>;
          };
          groupBy: {
            args: Prisma.PaperlessDocumentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaperlessDocumentGroupByOutputType>[];
          };
          count: {
            args: Prisma.PaperlessDocumentCountArgs<ExtArgs>;
            result: $Utils.Optional<PaperlessDocumentCountAggregateOutputType> | number;
          };
        };
      };
      DocumentProcessingResult: {
        payload: Prisma.$DocumentProcessingResultPayload<ExtArgs>;
        fields: Prisma.DocumentProcessingResultFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DocumentProcessingResultFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DocumentProcessingResultFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>;
          };
          findFirst: {
            args: Prisma.DocumentProcessingResultFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DocumentProcessingResultFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>;
          };
          findMany: {
            args: Prisma.DocumentProcessingResultFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>[];
          };
          create: {
            args: Prisma.DocumentProcessingResultCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>;
          };
          createMany: {
            args: Prisma.DocumentProcessingResultCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DocumentProcessingResultCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>[];
          };
          delete: {
            args: Prisma.DocumentProcessingResultDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>;
          };
          update: {
            args: Prisma.DocumentProcessingResultUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>;
          };
          deleteMany: {
            args: Prisma.DocumentProcessingResultDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DocumentProcessingResultUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.DocumentProcessingResultUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>[];
          };
          upsert: {
            args: Prisma.DocumentProcessingResultUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DocumentProcessingResultPayload>;
          };
          aggregate: {
            args: Prisma.DocumentProcessingResultAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDocumentProcessingResult>;
          };
          groupBy: {
            args: Prisma.DocumentProcessingResultGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DocumentProcessingResultGroupByOutputType>[];
          };
          count: {
            args: Prisma.DocumentProcessingResultCountArgs<ExtArgs>;
            result: $Utils.Optional<DocumentProcessingResultCountAggregateOutputType> | number;
          };
        };
      };
      ProcessingQueue: {
        payload: Prisma.$ProcessingQueuePayload<ExtArgs>;
        fields: Prisma.ProcessingQueueFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ProcessingQueueFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ProcessingQueueFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>;
          };
          findFirst: {
            args: Prisma.ProcessingQueueFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ProcessingQueueFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>;
          };
          findMany: {
            args: Prisma.ProcessingQueueFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>[];
          };
          create: {
            args: Prisma.ProcessingQueueCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>;
          };
          createMany: {
            args: Prisma.ProcessingQueueCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ProcessingQueueCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>[];
          };
          delete: {
            args: Prisma.ProcessingQueueDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>;
          };
          update: {
            args: Prisma.ProcessingQueueUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>;
          };
          deleteMany: {
            args: Prisma.ProcessingQueueDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ProcessingQueueUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ProcessingQueueUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>[];
          };
          upsert: {
            args: Prisma.ProcessingQueueUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ProcessingQueuePayload>;
          };
          aggregate: {
            args: Prisma.ProcessingQueueAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProcessingQueue>;
          };
          groupBy: {
            args: Prisma.ProcessingQueueGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ProcessingQueueGroupByOutputType>[];
          };
          count: {
            args: Prisma.ProcessingQueueCountArgs<ExtArgs>;
            result: $Utils.Optional<ProcessingQueueCountAggregateOutputType> | number;
          };
        };
      };
      ImportHistory: {
        payload: Prisma.$ImportHistoryPayload<ExtArgs>;
        fields: Prisma.ImportHistoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ImportHistoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ImportHistoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>;
          };
          findFirst: {
            args: Prisma.ImportHistoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ImportHistoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>;
          };
          findMany: {
            args: Prisma.ImportHistoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>[];
          };
          create: {
            args: Prisma.ImportHistoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>;
          };
          createMany: {
            args: Prisma.ImportHistoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ImportHistoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>[];
          };
          delete: {
            args: Prisma.ImportHistoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>;
          };
          update: {
            args: Prisma.ImportHistoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>;
          };
          deleteMany: {
            args: Prisma.ImportHistoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ImportHistoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ImportHistoryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>[];
          };
          upsert: {
            args: Prisma.ImportHistoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>;
          };
          aggregate: {
            args: Prisma.ImportHistoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateImportHistory>;
          };
          groupBy: {
            args: Prisma.ImportHistoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ImportHistoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.ImportHistoryCountArgs<ExtArgs>;
            result: $Utils.Optional<ImportHistoryCountAggregateOutputType> | number;
          };
        };
      };
      AiUsageMetric: {
        payload: Prisma.$AiUsageMetricPayload<ExtArgs>;
        fields: Prisma.AiUsageMetricFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AiUsageMetricFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AiUsageMetricFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>;
          };
          findFirst: {
            args: Prisma.AiUsageMetricFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AiUsageMetricFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>;
          };
          findMany: {
            args: Prisma.AiUsageMetricFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>[];
          };
          create: {
            args: Prisma.AiUsageMetricCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>;
          };
          createMany: {
            args: Prisma.AiUsageMetricCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AiUsageMetricCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>[];
          };
          delete: {
            args: Prisma.AiUsageMetricDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>;
          };
          update: {
            args: Prisma.AiUsageMetricUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>;
          };
          deleteMany: {
            args: Prisma.AiUsageMetricDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AiUsageMetricUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AiUsageMetricUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>[];
          };
          upsert: {
            args: Prisma.AiUsageMetricUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AiUsageMetricPayload>;
          };
          aggregate: {
            args: Prisma.AiUsageMetricAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAiUsageMetric>;
          };
          groupBy: {
            args: Prisma.AiUsageMetricGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AiUsageMetricGroupByOutputType>[];
          };
          count: {
            args: Prisma.AiUsageMetricCountArgs<ExtArgs>;
            result: $Utils.Optional<AiUsageMetricCountAggregateOutputType> | number;
          };
        };
      };
      WebAuthnCredential: {
        payload: Prisma.$WebAuthnCredentialPayload<ExtArgs>;
        fields: Prisma.WebAuthnCredentialFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WebAuthnCredentialFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>;
          };
          findFirst: {
            args: Prisma.WebAuthnCredentialFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>;
          };
          findMany: {
            args: Prisma.WebAuthnCredentialFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>[];
          };
          create: {
            args: Prisma.WebAuthnCredentialCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>;
          };
          createMany: {
            args: Prisma.WebAuthnCredentialCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WebAuthnCredentialCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>[];
          };
          delete: {
            args: Prisma.WebAuthnCredentialDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>;
          };
          update: {
            args: Prisma.WebAuthnCredentialUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>;
          };
          deleteMany: {
            args: Prisma.WebAuthnCredentialDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WebAuthnCredentialUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WebAuthnCredentialUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>[];
          };
          upsert: {
            args: Prisma.WebAuthnCredentialUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnCredentialPayload>;
          };
          aggregate: {
            args: Prisma.WebAuthnCredentialAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWebAuthnCredential>;
          };
          groupBy: {
            args: Prisma.WebAuthnCredentialGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WebAuthnCredentialGroupByOutputType>[];
          };
          count: {
            args: Prisma.WebAuthnCredentialCountArgs<ExtArgs>;
            result: $Utils.Optional<WebAuthnCredentialCountAggregateOutputType> | number;
          };
        };
      };
      WebAuthnChallenge: {
        payload: Prisma.$WebAuthnChallengePayload<ExtArgs>;
        fields: Prisma.WebAuthnChallengeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.WebAuthnChallengeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.WebAuthnChallengeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>;
          };
          findFirst: {
            args: Prisma.WebAuthnChallengeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.WebAuthnChallengeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>;
          };
          findMany: {
            args: Prisma.WebAuthnChallengeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>[];
          };
          create: {
            args: Prisma.WebAuthnChallengeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>;
          };
          createMany: {
            args: Prisma.WebAuthnChallengeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.WebAuthnChallengeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>[];
          };
          delete: {
            args: Prisma.WebAuthnChallengeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>;
          };
          update: {
            args: Prisma.WebAuthnChallengeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>;
          };
          deleteMany: {
            args: Prisma.WebAuthnChallengeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.WebAuthnChallengeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.WebAuthnChallengeUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>[];
          };
          upsert: {
            args: Prisma.WebAuthnChallengeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$WebAuthnChallengePayload>;
          };
          aggregate: {
            args: Prisma.WebAuthnChallengeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateWebAuthnChallenge>;
          };
          groupBy: {
            args: Prisma.WebAuthnChallengeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<WebAuthnChallengeGroupByOutputType>[];
          };
          count: {
            args: Prisma.WebAuthnChallengeCountArgs<ExtArgs>;
            result: $Utils.Optional<WebAuthnChallengeCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory;
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    setting?: SettingOmit;
    user?: UserOmit;
    userPaperlessInstanceAccess?: UserPaperlessInstanceAccessOmit;
    userAiAccountAccess?: UserAiAccountAccessOmit;
    userAiModelAccess?: UserAiModelAccessOmit;
    userAiBotAccess?: UserAiBotAccessOmit;
    paperlessInstance?: PaperlessInstanceOmit;
    aiAccount?: AiAccountOmit;
    aiModel?: AiModelOmit;
    aiBot?: AiBotOmit;
    paperlessDocument?: PaperlessDocumentOmit;
    documentProcessingResult?: DocumentProcessingResultOmit;
    processingQueue?: ProcessingQueueOmit;
    importHistory?: ImportHistoryOmit;
    aiUsageMetric?: AiUsageMetricOmit;
    webAuthnCredential?: WebAuthnCredentialOmit;
    webAuthnChallenge?: WebAuthnChallengeOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<T extends LogDefinition ? T['level'] : T>;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    ownedPaperlessInstances: number;
    ownedAiAccounts: number;
    ownedAiModels: number;
    ownedAiBots: number;
    sharedPaperlessInstances: number;
    sharedAiAccounts: number;
    sharedAiModels: number;
    sharedAiBots: number;
    aiUsageMetrics: number;
    webAuthnCredentials: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    ownedPaperlessInstances?: boolean | UserCountOutputTypeCountOwnedPaperlessInstancesArgs;
    ownedAiAccounts?: boolean | UserCountOutputTypeCountOwnedAiAccountsArgs;
    ownedAiModels?: boolean | UserCountOutputTypeCountOwnedAiModelsArgs;
    ownedAiBots?: boolean | UserCountOutputTypeCountOwnedAiBotsArgs;
    sharedPaperlessInstances?: boolean | UserCountOutputTypeCountSharedPaperlessInstancesArgs;
    sharedAiAccounts?: boolean | UserCountOutputTypeCountSharedAiAccountsArgs;
    sharedAiModels?: boolean | UserCountOutputTypeCountSharedAiModelsArgs;
    sharedAiBots?: boolean | UserCountOutputTypeCountSharedAiBotsArgs;
    aiUsageMetrics?: boolean | UserCountOutputTypeCountAiUsageMetricsArgs;
    webAuthnCredentials?: boolean | UserCountOutputTypeCountWebAuthnCredentialsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedPaperlessInstancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaperlessInstanceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedAiAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiAccountWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedAiModelsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiModelWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedAiBotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiBotWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedPaperlessInstancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserPaperlessInstanceAccessWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedAiAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiAccountAccessWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedAiModelsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiModelAccessWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedAiBotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiBotAccessWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiUsageMetricWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWebAuthnCredentialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WebAuthnCredentialWhereInput;
  };

  /**
   * Count Type PaperlessInstanceCountOutputType
   */

  export type PaperlessInstanceCountOutputType = {
    sharedWith: number;
    documents: number;
    processingQueue: number;
    importHistory: number;
  };

  export type PaperlessInstanceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sharedWith?: boolean | PaperlessInstanceCountOutputTypeCountSharedWithArgs;
    documents?: boolean | PaperlessInstanceCountOutputTypeCountDocumentsArgs;
    processingQueue?: boolean | PaperlessInstanceCountOutputTypeCountProcessingQueueArgs;
    importHistory?: boolean | PaperlessInstanceCountOutputTypeCountImportHistoryArgs;
  };

  // Custom InputTypes
  /**
   * PaperlessInstanceCountOutputType without action
   */
  export type PaperlessInstanceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstanceCountOutputType
     */
    select?: PaperlessInstanceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PaperlessInstanceCountOutputType without action
   */
  export type PaperlessInstanceCountOutputTypeCountSharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserPaperlessInstanceAccessWhereInput;
  };

  /**
   * PaperlessInstanceCountOutputType without action
   */
  export type PaperlessInstanceCountOutputTypeCountDocumentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaperlessDocumentWhereInput;
  };

  /**
   * PaperlessInstanceCountOutputType without action
   */
  export type PaperlessInstanceCountOutputTypeCountProcessingQueueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProcessingQueueWhereInput;
  };

  /**
   * PaperlessInstanceCountOutputType without action
   */
  export type PaperlessInstanceCountOutputTypeCountImportHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ImportHistoryWhereInput;
  };

  /**
   * Count Type AiAccountCountOutputType
   */

  export type AiAccountCountOutputType = {
    sharedWith: number;
    models: number;
    aiUsageMetrics: number;
  };

  export type AiAccountCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sharedWith?: boolean | AiAccountCountOutputTypeCountSharedWithArgs;
    models?: boolean | AiAccountCountOutputTypeCountModelsArgs;
    aiUsageMetrics?: boolean | AiAccountCountOutputTypeCountAiUsageMetricsArgs;
  };

  // Custom InputTypes
  /**
   * AiAccountCountOutputType without action
   */
  export type AiAccountCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccountCountOutputType
     */
    select?: AiAccountCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AiAccountCountOutputType without action
   */
  export type AiAccountCountOutputTypeCountSharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiAccountAccessWhereInput;
  };

  /**
   * AiAccountCountOutputType without action
   */
  export type AiAccountCountOutputTypeCountModelsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiModelWhereInput;
  };

  /**
   * AiAccountCountOutputType without action
   */
  export type AiAccountCountOutputTypeCountAiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiUsageMetricWhereInput;
  };

  /**
   * Count Type AiModelCountOutputType
   */

  export type AiModelCountOutputType = {
    sharedWith: number;
    bots: number;
    aiUsageMetrics: number;
  };

  export type AiModelCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sharedWith?: boolean | AiModelCountOutputTypeCountSharedWithArgs;
    bots?: boolean | AiModelCountOutputTypeCountBotsArgs;
    aiUsageMetrics?: boolean | AiModelCountOutputTypeCountAiUsageMetricsArgs;
  };

  // Custom InputTypes
  /**
   * AiModelCountOutputType without action
   */
  export type AiModelCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModelCountOutputType
     */
    select?: AiModelCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AiModelCountOutputType without action
   */
  export type AiModelCountOutputTypeCountSharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiModelAccessWhereInput;
  };

  /**
   * AiModelCountOutputType without action
   */
  export type AiModelCountOutputTypeCountBotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiBotWhereInput;
  };

  /**
   * AiModelCountOutputType without action
   */
  export type AiModelCountOutputTypeCountAiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiUsageMetricWhereInput;
  };

  /**
   * Count Type AiBotCountOutputType
   */

  export type AiBotCountOutputType = {
    sharedWith: number;
    aiUsageMetrics: number;
    defaultForInstances: number;
    processingQueueItems: number;
  };

  export type AiBotCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sharedWith?: boolean | AiBotCountOutputTypeCountSharedWithArgs;
    aiUsageMetrics?: boolean | AiBotCountOutputTypeCountAiUsageMetricsArgs;
    defaultForInstances?: boolean | AiBotCountOutputTypeCountDefaultForInstancesArgs;
    processingQueueItems?: boolean | AiBotCountOutputTypeCountProcessingQueueItemsArgs;
  };

  // Custom InputTypes
  /**
   * AiBotCountOutputType without action
   */
  export type AiBotCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBotCountOutputType
     */
    select?: AiBotCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AiBotCountOutputType without action
   */
  export type AiBotCountOutputTypeCountSharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiBotAccessWhereInput;
  };

  /**
   * AiBotCountOutputType without action
   */
  export type AiBotCountOutputTypeCountAiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiUsageMetricWhereInput;
  };

  /**
   * AiBotCountOutputType without action
   */
  export type AiBotCountOutputTypeCountDefaultForInstancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaperlessInstanceWhereInput;
  };

  /**
   * AiBotCountOutputType without action
   */
  export type AiBotCountOutputTypeCountProcessingQueueItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProcessingQueueWhereInput;
  };

  /**
   * Count Type PaperlessDocumentCountOutputType
   */

  export type PaperlessDocumentCountOutputType = {
    processingResults: number;
    processingQueueItems: number;
  };

  export type PaperlessDocumentCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    processingResults?: boolean | PaperlessDocumentCountOutputTypeCountProcessingResultsArgs;
    processingQueueItems?: boolean | PaperlessDocumentCountOutputTypeCountProcessingQueueItemsArgs;
  };

  // Custom InputTypes
  /**
   * PaperlessDocumentCountOutputType without action
   */
  export type PaperlessDocumentCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocumentCountOutputType
     */
    select?: PaperlessDocumentCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PaperlessDocumentCountOutputType without action
   */
  export type PaperlessDocumentCountOutputTypeCountProcessingResultsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentProcessingResultWhereInput;
  };

  /**
   * PaperlessDocumentCountOutputType without action
   */
  export type PaperlessDocumentCountOutputTypeCountProcessingQueueItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProcessingQueueWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null;
    _min: SettingMinAggregateOutputType | null;
    _max: SettingMaxAggregateOutputType | null;
  };

  export type SettingMinAggregateOutputType = {
    settingKey: string | null;
    settingValue: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SettingMaxAggregateOutputType = {
    settingKey: string | null;
    settingValue: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SettingCountAggregateOutputType = {
    settingKey: number;
    settingValue: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SettingMinAggregateInputType = {
    settingKey?: true;
    settingValue?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SettingMaxAggregateInputType = {
    settingKey?: true;
    settingValue?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SettingCountAggregateInputType = {
    settingKey?: true;
    settingValue?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SettingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Settings
     **/
    _count?: true | SettingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SettingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SettingMaxAggregateInputType;
  };

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
    [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>;
  };

  export type SettingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SettingWhereInput;
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[];
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum;
    having?: SettingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SettingCountAggregateInputType | true;
    _min?: SettingMinAggregateInputType;
    _max?: SettingMaxAggregateInputType;
  };

  export type SettingGroupByOutputType = {
    settingKey: string;
    settingValue: string;
    createdAt: Date;
    updatedAt: Date;
    _count: SettingCountAggregateOutputType | null;
    _min: SettingMinAggregateOutputType | null;
    _max: SettingMaxAggregateOutputType | null;
  };

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> & {
        [P in keyof T & keyof SettingGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
          : GetScalarType<T[P], SettingGroupByOutputType[P]>;
      }
    >
  >;

  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        settingKey?: boolean;
        settingValue?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
      },
      ExtArgs['result']['setting']
    >;

  export type SettingSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      settingKey?: boolean;
      settingValue?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['setting']
  >;

  export type SettingSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      settingKey?: boolean;
      settingValue?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['setting']
  >;

  export type SettingSelectScalar = {
    settingKey?: boolean;
    settingValue?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      'settingKey' | 'settingValue' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['setting']
    >;

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'Setting';
      objects: {};
      scalars: $Extensions.GetPayloadResult<
        {
          settingKey: string;
          settingValue: string;
          createdAt: Date;
          updatedAt: Date;
        },
        ExtArgs['result']['setting']
      >;
      composites: {};
    };

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> =
    $Result.GetResult<Prisma.$SettingPayload, S>;

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    SettingFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SettingCountAggregateInputType | true;
  };

  export interface SettingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting']; meta: { name: 'Setting' } };
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(
      args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(
      args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     *
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     *
     * // Only select the `settingKey`
     * const settingWithSettingKeyOnly = await prisma.setting.findMany({ select: { settingKey: true } })
     *
     */
    findMany<T extends SettingFindManyArgs>(
      args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     *
     */
    create<T extends SettingCreateArgs>(
      args: SelectSubset<T, SettingCreateArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SettingCreateManyArgs>(
      args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Settings and only return the `settingKey`
     * const settingWithSettingKeyOnly = await prisma.setting.createManyAndReturn({
     *   select: { settingKey: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SettingPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     *
     */
    delete<T extends SettingDeleteArgs>(
      args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SettingUpdateArgs>(
      args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SettingDeleteManyArgs>(
      args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SettingUpdateManyArgs>(
      args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Settings and only return the `settingKey`
     * const settingWithSettingKeyOnly = await prisma.setting.updateManyAndReturn({
     *   select: { settingKey: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SettingPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(
      args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>
    ): Prisma__SettingClient<
      $Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
     **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SettingAggregateArgs>(
      args: Subset<T, SettingAggregateArgs>
    ): Prisma.PrismaPromise<GetSettingAggregateType<T>>;

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Setting model
     */
    readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly settingKey: FieldRef<'Setting', 'String'>;
    readonly settingValue: FieldRef<'Setting', 'String'>;
    readonly createdAt: FieldRef<'Setting', 'DateTime'>;
    readonly updatedAt: FieldRef<'Setting', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[];
  };

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[];
  };

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Settings.
     */
    skip?: number;
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[];
  };

  /**
   * Setting create
   */
  export type SettingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>;
  };

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Setting update
   */
  export type SettingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>;
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>;
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput;
    /**
     * Limit how many Settings to update.
     */
    limit?: number;
  };

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>;
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput;
    /**
     * Limit how many Settings to update.
     */
    limit?: number;
  };

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput;
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>;
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>;
  };

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput;
  };

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput;
    /**
     * Limit how many Settings to delete.
     */
    limit?: number;
  };

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    username: string | null;
    passwordHash: string | null;
    role: $Enums.UserRole | null;
    mustChangePassword: boolean | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    username: string | null;
    passwordHash: string | null;
    role: $Enums.UserRole | null;
    mustChangePassword: boolean | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    username: number;
    passwordHash: number;
    role: number;
    mustChangePassword: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    username?: true;
    passwordHash?: true;
    role?: true;
    mustChangePassword?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    username?: true;
    passwordHash?: true;
    role?: true;
    mustChangePassword?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    username?: true;
    passwordHash?: true;
    role?: true;
    mustChangePassword?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: UserWhereInput;
      orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
      by: UserScalarFieldEnum[] | UserScalarFieldEnum;
      having?: UserScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: UserCountAggregateInputType | true;
      _min?: UserMinAggregateInputType;
      _max?: UserMaxAggregateInputType;
    };

  export type UserGroupByOutputType = {
    id: string;
    username: string;
    passwordHash: string;
    role: $Enums.UserRole;
    mustChangePassword: boolean;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        username?: boolean;
        passwordHash?: boolean;
        role?: boolean;
        mustChangePassword?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        ownedPaperlessInstances?: boolean | User$ownedPaperlessInstancesArgs<ExtArgs>;
        ownedAiAccounts?: boolean | User$ownedAiAccountsArgs<ExtArgs>;
        ownedAiModels?: boolean | User$ownedAiModelsArgs<ExtArgs>;
        ownedAiBots?: boolean | User$ownedAiBotsArgs<ExtArgs>;
        sharedPaperlessInstances?: boolean | User$sharedPaperlessInstancesArgs<ExtArgs>;
        sharedAiAccounts?: boolean | User$sharedAiAccountsArgs<ExtArgs>;
        sharedAiModels?: boolean | User$sharedAiModelsArgs<ExtArgs>;
        sharedAiBots?: boolean | User$sharedAiBotsArgs<ExtArgs>;
        aiUsageMetrics?: boolean | User$aiUsageMetricsArgs<ExtArgs>;
        webAuthnCredentials?: boolean | User$webAuthnCredentialsArgs<ExtArgs>;
        _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['user']
    >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      username?: boolean;
      passwordHash?: boolean;
      role?: boolean;
      mustChangePassword?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      username?: boolean;
      passwordHash?: boolean;
      role?: boolean;
      mustChangePassword?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    username?: boolean;
    passwordHash?: boolean;
    role?: boolean;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'username'
      | 'passwordHash'
      | 'role'
      | 'mustChangePassword'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt',
      ExtArgs['result']['user']
    >;
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ownedPaperlessInstances?: boolean | User$ownedPaperlessInstancesArgs<ExtArgs>;
    ownedAiAccounts?: boolean | User$ownedAiAccountsArgs<ExtArgs>;
    ownedAiModels?: boolean | User$ownedAiModelsArgs<ExtArgs>;
    ownedAiBots?: boolean | User$ownedAiBotsArgs<ExtArgs>;
    sharedPaperlessInstances?: boolean | User$sharedPaperlessInstancesArgs<ExtArgs>;
    sharedAiAccounts?: boolean | User$sharedAiAccountsArgs<ExtArgs>;
    sharedAiModels?: boolean | User$sharedAiModelsArgs<ExtArgs>;
    sharedAiBots?: boolean | User$sharedAiBotsArgs<ExtArgs>;
    aiUsageMetrics?: boolean | User$aiUsageMetricsArgs<ExtArgs>;
    webAuthnCredentials?: boolean | User$webAuthnCredentialsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'User';
    objects: {
      ownedPaperlessInstances: Prisma.$PaperlessInstancePayload<ExtArgs>[];
      ownedAiAccounts: Prisma.$AiAccountPayload<ExtArgs>[];
      ownedAiModels: Prisma.$AiModelPayload<ExtArgs>[];
      ownedAiBots: Prisma.$AiBotPayload<ExtArgs>[];
      sharedPaperlessInstances: Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>[];
      sharedAiAccounts: Prisma.$UserAiAccountAccessPayload<ExtArgs>[];
      sharedAiModels: Prisma.$UserAiModelAccessPayload<ExtArgs>[];
      sharedAiBots: Prisma.$UserAiBotAccessPayload<ExtArgs>[];
      aiUsageMetrics: Prisma.$AiUsageMetricPayload<ExtArgs>[];
      webAuthnCredentials: Prisma.$WebAuthnCredentialPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        username: string;
        passwordHash: string;
        role: $Enums.UserRole;
        mustChangePassword: boolean;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
    Prisma.$UserPayload,
    S
  >;

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    UserFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    ownedPaperlessInstances<T extends User$ownedPaperlessInstancesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ownedPaperlessInstancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaperlessInstancePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    ownedAiAccounts<T extends User$ownedAiAccountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ownedAiAccountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiAccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    ownedAiModels<T extends User$ownedAiModelsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ownedAiModelsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    ownedAiBots<T extends User$ownedAiBotsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$ownedAiBotsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    sharedPaperlessInstances<T extends User$sharedPaperlessInstancesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sharedPaperlessInstancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    sharedAiAccounts<T extends User$sharedAiAccountsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sharedAiAccountsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserAiAccountAccessPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    sharedAiModels<T extends User$sharedAiModelsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sharedAiModelsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserAiModelAccessPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    sharedAiBots<T extends User$sharedAiBotsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$sharedAiBotsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    aiUsageMetrics<T extends User$aiUsageMetricsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$aiUsageMetricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    webAuthnCredentials<T extends User$webAuthnCredentialsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$webAuthnCredentialsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$WebAuthnCredentialPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly username: FieldRef<'User', 'String'>;
    readonly passwordHash: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'UserRole'>;
    readonly mustChangePassword: FieldRef<'User', 'Boolean'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
    };

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.ownedPaperlessInstances
   */
  export type User$ownedPaperlessInstancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    where?: PaperlessInstanceWhereInput;
    orderBy?:
      | PaperlessInstanceOrderByWithRelationInput
      | PaperlessInstanceOrderByWithRelationInput[];
    cursor?: PaperlessInstanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaperlessInstanceScalarFieldEnum | PaperlessInstanceScalarFieldEnum[];
  };

  /**
   * User.ownedAiAccounts
   */
  export type User$ownedAiAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    where?: AiAccountWhereInput;
    orderBy?: AiAccountOrderByWithRelationInput | AiAccountOrderByWithRelationInput[];
    cursor?: AiAccountWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiAccountScalarFieldEnum | AiAccountScalarFieldEnum[];
  };

  /**
   * User.ownedAiModels
   */
  export type User$ownedAiModelsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    where?: AiModelWhereInput;
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[];
    cursor?: AiModelWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[];
  };

  /**
   * User.ownedAiBots
   */
  export type User$ownedAiBotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    where?: AiBotWhereInput;
    orderBy?: AiBotOrderByWithRelationInput | AiBotOrderByWithRelationInput[];
    cursor?: AiBotWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiBotScalarFieldEnum | AiBotScalarFieldEnum[];
  };

  /**
   * User.sharedPaperlessInstances
   */
  export type User$sharedPaperlessInstancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    where?: UserPaperlessInstanceAccessWhereInput;
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithRelationInput
      | UserPaperlessInstanceAccessOrderByWithRelationInput[];
    cursor?: UserPaperlessInstanceAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | UserPaperlessInstanceAccessScalarFieldEnum
      | UserPaperlessInstanceAccessScalarFieldEnum[];
  };

  /**
   * User.sharedAiAccounts
   */
  export type User$sharedAiAccountsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    where?: UserAiAccountAccessWhereInput;
    orderBy?:
      | UserAiAccountAccessOrderByWithRelationInput
      | UserAiAccountAccessOrderByWithRelationInput[];
    cursor?: UserAiAccountAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserAiAccountAccessScalarFieldEnum | UserAiAccountAccessScalarFieldEnum[];
  };

  /**
   * User.sharedAiModels
   */
  export type User$sharedAiModelsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    where?: UserAiModelAccessWhereInput;
    orderBy?:
      | UserAiModelAccessOrderByWithRelationInput
      | UserAiModelAccessOrderByWithRelationInput[];
    cursor?: UserAiModelAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserAiModelAccessScalarFieldEnum | UserAiModelAccessScalarFieldEnum[];
  };

  /**
   * User.sharedAiBots
   */
  export type User$sharedAiBotsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    where?: UserAiBotAccessWhereInput;
    orderBy?: UserAiBotAccessOrderByWithRelationInput | UserAiBotAccessOrderByWithRelationInput[];
    cursor?: UserAiBotAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserAiBotAccessScalarFieldEnum | UserAiBotAccessScalarFieldEnum[];
  };

  /**
   * User.aiUsageMetrics
   */
  export type User$aiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    where?: AiUsageMetricWhereInput;
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    cursor?: AiUsageMetricWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * User.webAuthnCredentials
   */
  export type User$webAuthnCredentialsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    where?: WebAuthnCredentialWhereInput;
    orderBy?:
      | WebAuthnCredentialOrderByWithRelationInput
      | WebAuthnCredentialOrderByWithRelationInput[];
    cursor?: WebAuthnCredentialWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
    };

  /**
   * Model UserPaperlessInstanceAccess
   */

  export type AggregateUserPaperlessInstanceAccess = {
    _count: UserPaperlessInstanceAccessCountAggregateOutputType | null;
    _min: UserPaperlessInstanceAccessMinAggregateOutputType | null;
    _max: UserPaperlessInstanceAccessMaxAggregateOutputType | null;
  };

  export type UserPaperlessInstanceAccessMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    instanceId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserPaperlessInstanceAccessMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    instanceId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserPaperlessInstanceAccessCountAggregateOutputType = {
    id: number;
    userId: number;
    instanceId: number;
    permission: number;
    createdAt: number;
    _all: number;
  };

  export type UserPaperlessInstanceAccessMinAggregateInputType = {
    id?: true;
    userId?: true;
    instanceId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserPaperlessInstanceAccessMaxAggregateInputType = {
    id?: true;
    userId?: true;
    instanceId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserPaperlessInstanceAccessCountAggregateInputType = {
    id?: true;
    userId?: true;
    instanceId?: true;
    permission?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserPaperlessInstanceAccessAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserPaperlessInstanceAccess to aggregate.
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserPaperlessInstanceAccesses to fetch.
     */
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithRelationInput
      | UserPaperlessInstanceAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserPaperlessInstanceAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserPaperlessInstanceAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserPaperlessInstanceAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserPaperlessInstanceAccesses
     **/
    _count?: true | UserPaperlessInstanceAccessCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserPaperlessInstanceAccessMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserPaperlessInstanceAccessMaxAggregateInputType;
  };

  export type GetUserPaperlessInstanceAccessAggregateType<
    T extends UserPaperlessInstanceAccessAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateUserPaperlessInstanceAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPaperlessInstanceAccess[P]>
      : GetScalarType<T[P], AggregateUserPaperlessInstanceAccess[P]>;
  };

  export type UserPaperlessInstanceAccessGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserPaperlessInstanceAccessWhereInput;
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithAggregationInput
      | UserPaperlessInstanceAccessOrderByWithAggregationInput[];
    by: UserPaperlessInstanceAccessScalarFieldEnum[] | UserPaperlessInstanceAccessScalarFieldEnum;
    having?: UserPaperlessInstanceAccessScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserPaperlessInstanceAccessCountAggregateInputType | true;
    _min?: UserPaperlessInstanceAccessMinAggregateInputType;
    _max?: UserPaperlessInstanceAccessMaxAggregateInputType;
  };

  export type UserPaperlessInstanceAccessGroupByOutputType = {
    id: string;
    userId: string | null;
    instanceId: string;
    permission: $Enums.Permission;
    createdAt: Date;
    _count: UserPaperlessInstanceAccessCountAggregateOutputType | null;
    _min: UserPaperlessInstanceAccessMinAggregateOutputType | null;
    _max: UserPaperlessInstanceAccessMaxAggregateOutputType | null;
  };

  type GetUserPaperlessInstanceAccessGroupByPayload<
    T extends UserPaperlessInstanceAccessGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPaperlessInstanceAccessGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserPaperlessInstanceAccessGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserPaperlessInstanceAccessGroupByOutputType[P]>
          : GetScalarType<T[P], UserPaperlessInstanceAccessGroupByOutputType[P]>;
      }
    >
  >;

  export type UserPaperlessInstanceAccessSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      instanceId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserPaperlessInstanceAccess$userArgs<ExtArgs>;
      instance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userPaperlessInstanceAccess']
  >;

  export type UserPaperlessInstanceAccessSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      instanceId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserPaperlessInstanceAccess$userArgs<ExtArgs>;
      instance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userPaperlessInstanceAccess']
  >;

  export type UserPaperlessInstanceAccessSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      instanceId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserPaperlessInstanceAccess$userArgs<ExtArgs>;
      instance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userPaperlessInstanceAccess']
  >;

  export type UserPaperlessInstanceAccessSelectScalar = {
    id?: boolean;
    userId?: boolean;
    instanceId?: boolean;
    permission?: boolean;
    createdAt?: boolean;
  };

  export type UserPaperlessInstanceAccessOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'instanceId' | 'permission' | 'createdAt',
    ExtArgs['result']['userPaperlessInstanceAccess']
  >;
  export type UserPaperlessInstanceAccessInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserPaperlessInstanceAccess$userArgs<ExtArgs>;
    instance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };
  export type UserPaperlessInstanceAccessIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserPaperlessInstanceAccess$userArgs<ExtArgs>;
    instance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };
  export type UserPaperlessInstanceAccessIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserPaperlessInstanceAccess$userArgs<ExtArgs>;
    instance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };

  export type $UserPaperlessInstanceAccessPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UserPaperlessInstanceAccess';
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      instance: Prisma.$PaperlessInstancePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string | null;
        instanceId: string;
        permission: $Enums.Permission;
        createdAt: Date;
      },
      ExtArgs['result']['userPaperlessInstanceAccess']
    >;
    composites: {};
  };

  type UserPaperlessInstanceAccessGetPayload<
    S extends boolean | null | undefined | UserPaperlessInstanceAccessDefaultArgs,
  > = $Result.GetResult<Prisma.$UserPaperlessInstanceAccessPayload, S>;

  type UserPaperlessInstanceAccessCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserPaperlessInstanceAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserPaperlessInstanceAccessCountAggregateInputType | true;
  };

  export interface UserPaperlessInstanceAccessDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserPaperlessInstanceAccess'];
      meta: { name: 'UserPaperlessInstanceAccess' };
    };
    /**
     * Find zero or one UserPaperlessInstanceAccess that matches the filter.
     * @param {UserPaperlessInstanceAccessFindUniqueArgs} args - Arguments to find a UserPaperlessInstanceAccess
     * @example
     * // Get one UserPaperlessInstanceAccess
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPaperlessInstanceAccessFindUniqueArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessFindUniqueArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserPaperlessInstanceAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPaperlessInstanceAccessFindUniqueOrThrowArgs} args - Arguments to find a UserPaperlessInstanceAccess
     * @example
     * // Get one UserPaperlessInstanceAccess
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPaperlessInstanceAccessFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserPaperlessInstanceAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessFindFirstArgs} args - Arguments to find a UserPaperlessInstanceAccess
     * @example
     * // Get one UserPaperlessInstanceAccess
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPaperlessInstanceAccessFindFirstArgs>(
      args?: SelectSubset<T, UserPaperlessInstanceAccessFindFirstArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserPaperlessInstanceAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessFindFirstOrThrowArgs} args - Arguments to find a UserPaperlessInstanceAccess
     * @example
     * // Get one UserPaperlessInstanceAccess
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPaperlessInstanceAccessFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserPaperlessInstanceAccessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserPaperlessInstanceAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPaperlessInstanceAccesses
     * const userPaperlessInstanceAccesses = await prisma.userPaperlessInstanceAccess.findMany()
     *
     * // Get first 10 UserPaperlessInstanceAccesses
     * const userPaperlessInstanceAccesses = await prisma.userPaperlessInstanceAccess.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userPaperlessInstanceAccessWithIdOnly = await prisma.userPaperlessInstanceAccess.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserPaperlessInstanceAccessFindManyArgs>(
      args?: SelectSubset<T, UserPaperlessInstanceAccessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserPaperlessInstanceAccess.
     * @param {UserPaperlessInstanceAccessCreateArgs} args - Arguments to create a UserPaperlessInstanceAccess.
     * @example
     * // Create one UserPaperlessInstanceAccess
     * const UserPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.create({
     *   data: {
     *     // ... data to create a UserPaperlessInstanceAccess
     *   }
     * })
     *
     */
    create<T extends UserPaperlessInstanceAccessCreateArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessCreateArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserPaperlessInstanceAccesses.
     * @param {UserPaperlessInstanceAccessCreateManyArgs} args - Arguments to create many UserPaperlessInstanceAccesses.
     * @example
     * // Create many UserPaperlessInstanceAccesses
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserPaperlessInstanceAccessCreateManyArgs>(
      args?: SelectSubset<T, UserPaperlessInstanceAccessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserPaperlessInstanceAccesses and returns the data saved in the database.
     * @param {UserPaperlessInstanceAccessCreateManyAndReturnArgs} args - Arguments to create many UserPaperlessInstanceAccesses.
     * @example
     * // Create many UserPaperlessInstanceAccesses
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserPaperlessInstanceAccesses and only return the `id`
     * const userPaperlessInstanceAccessWithIdOnly = await prisma.userPaperlessInstanceAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserPaperlessInstanceAccessCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserPaperlessInstanceAccessCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserPaperlessInstanceAccess.
     * @param {UserPaperlessInstanceAccessDeleteArgs} args - Arguments to delete one UserPaperlessInstanceAccess.
     * @example
     * // Delete one UserPaperlessInstanceAccess
     * const UserPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.delete({
     *   where: {
     *     // ... filter to delete one UserPaperlessInstanceAccess
     *   }
     * })
     *
     */
    delete<T extends UserPaperlessInstanceAccessDeleteArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessDeleteArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserPaperlessInstanceAccess.
     * @param {UserPaperlessInstanceAccessUpdateArgs} args - Arguments to update one UserPaperlessInstanceAccess.
     * @example
     * // Update one UserPaperlessInstanceAccess
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserPaperlessInstanceAccessUpdateArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessUpdateArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserPaperlessInstanceAccesses.
     * @param {UserPaperlessInstanceAccessDeleteManyArgs} args - Arguments to filter UserPaperlessInstanceAccesses to delete.
     * @example
     * // Delete a few UserPaperlessInstanceAccesses
     * const { count } = await prisma.userPaperlessInstanceAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserPaperlessInstanceAccessDeleteManyArgs>(
      args?: SelectSubset<T, UserPaperlessInstanceAccessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserPaperlessInstanceAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPaperlessInstanceAccesses
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserPaperlessInstanceAccessUpdateManyArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserPaperlessInstanceAccesses and returns the data updated in the database.
     * @param {UserPaperlessInstanceAccessUpdateManyAndReturnArgs} args - Arguments to update many UserPaperlessInstanceAccesses.
     * @example
     * // Update many UserPaperlessInstanceAccesses
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserPaperlessInstanceAccesses and only return the `id`
     * const userPaperlessInstanceAccessWithIdOnly = await prisma.userPaperlessInstanceAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserPaperlessInstanceAccessUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserPaperlessInstanceAccess.
     * @param {UserPaperlessInstanceAccessUpsertArgs} args - Arguments to update or create a UserPaperlessInstanceAccess.
     * @example
     * // Update or create a UserPaperlessInstanceAccess
     * const userPaperlessInstanceAccess = await prisma.userPaperlessInstanceAccess.upsert({
     *   create: {
     *     // ... data to create a UserPaperlessInstanceAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPaperlessInstanceAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserPaperlessInstanceAccessUpsertArgs>(
      args: SelectSubset<T, UserPaperlessInstanceAccessUpsertArgs<ExtArgs>>
    ): Prisma__UserPaperlessInstanceAccessClient<
      $Result.GetResult<
        Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserPaperlessInstanceAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessCountArgs} args - Arguments to filter UserPaperlessInstanceAccesses to count.
     * @example
     * // Count the number of UserPaperlessInstanceAccesses
     * const count = await prisma.userPaperlessInstanceAccess.count({
     *   where: {
     *     // ... the filter for the UserPaperlessInstanceAccesses we want to count
     *   }
     * })
     **/
    count<T extends UserPaperlessInstanceAccessCountArgs>(
      args?: Subset<T, UserPaperlessInstanceAccessCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPaperlessInstanceAccessCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserPaperlessInstanceAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserPaperlessInstanceAccessAggregateArgs>(
      args: Subset<T, UserPaperlessInstanceAccessAggregateArgs>
    ): Prisma.PrismaPromise<GetUserPaperlessInstanceAccessAggregateType<T>>;

    /**
     * Group by UserPaperlessInstanceAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPaperlessInstanceAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserPaperlessInstanceAccessGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPaperlessInstanceAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserPaperlessInstanceAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserPaperlessInstanceAccessGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserPaperlessInstanceAccessGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserPaperlessInstanceAccess model
     */
    readonly fields: UserPaperlessInstanceAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPaperlessInstanceAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPaperlessInstanceAccessClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserPaperlessInstanceAccess$userArgs<ExtArgs> = {}>(
      args?: Subset<T, UserPaperlessInstanceAccess$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    instance<T extends PaperlessInstanceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstanceDefaultArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      | $Result.GetResult<
          Prisma.$PaperlessInstancePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserPaperlessInstanceAccess model
   */
  interface UserPaperlessInstanceAccessFieldRefs {
    readonly id: FieldRef<'UserPaperlessInstanceAccess', 'String'>;
    readonly userId: FieldRef<'UserPaperlessInstanceAccess', 'String'>;
    readonly instanceId: FieldRef<'UserPaperlessInstanceAccess', 'String'>;
    readonly permission: FieldRef<'UserPaperlessInstanceAccess', 'Permission'>;
    readonly createdAt: FieldRef<'UserPaperlessInstanceAccess', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserPaperlessInstanceAccess findUnique
   */
  export type UserPaperlessInstanceAccessFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserPaperlessInstanceAccess to fetch.
     */
    where: UserPaperlessInstanceAccessWhereUniqueInput;
  };

  /**
   * UserPaperlessInstanceAccess findUniqueOrThrow
   */
  export type UserPaperlessInstanceAccessFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserPaperlessInstanceAccess to fetch.
     */
    where: UserPaperlessInstanceAccessWhereUniqueInput;
  };

  /**
   * UserPaperlessInstanceAccess findFirst
   */
  export type UserPaperlessInstanceAccessFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserPaperlessInstanceAccess to fetch.
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserPaperlessInstanceAccesses to fetch.
     */
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithRelationInput
      | UserPaperlessInstanceAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserPaperlessInstanceAccesses.
     */
    cursor?: UserPaperlessInstanceAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserPaperlessInstanceAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserPaperlessInstanceAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserPaperlessInstanceAccesses.
     */
    distinct?:
      | UserPaperlessInstanceAccessScalarFieldEnum
      | UserPaperlessInstanceAccessScalarFieldEnum[];
  };

  /**
   * UserPaperlessInstanceAccess findFirstOrThrow
   */
  export type UserPaperlessInstanceAccessFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserPaperlessInstanceAccess to fetch.
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserPaperlessInstanceAccesses to fetch.
     */
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithRelationInput
      | UserPaperlessInstanceAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserPaperlessInstanceAccesses.
     */
    cursor?: UserPaperlessInstanceAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserPaperlessInstanceAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserPaperlessInstanceAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserPaperlessInstanceAccesses.
     */
    distinct?:
      | UserPaperlessInstanceAccessScalarFieldEnum
      | UserPaperlessInstanceAccessScalarFieldEnum[];
  };

  /**
   * UserPaperlessInstanceAccess findMany
   */
  export type UserPaperlessInstanceAccessFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserPaperlessInstanceAccesses to fetch.
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserPaperlessInstanceAccesses to fetch.
     */
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithRelationInput
      | UserPaperlessInstanceAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserPaperlessInstanceAccesses.
     */
    cursor?: UserPaperlessInstanceAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserPaperlessInstanceAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserPaperlessInstanceAccesses.
     */
    skip?: number;
    distinct?:
      | UserPaperlessInstanceAccessScalarFieldEnum
      | UserPaperlessInstanceAccessScalarFieldEnum[];
  };

  /**
   * UserPaperlessInstanceAccess create
   */
  export type UserPaperlessInstanceAccessCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserPaperlessInstanceAccess.
     */
    data: XOR<
      UserPaperlessInstanceAccessCreateInput,
      UserPaperlessInstanceAccessUncheckedCreateInput
    >;
  };

  /**
   * UserPaperlessInstanceAccess createMany
   */
  export type UserPaperlessInstanceAccessCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserPaperlessInstanceAccesses.
     */
    data: UserPaperlessInstanceAccessCreateManyInput | UserPaperlessInstanceAccessCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserPaperlessInstanceAccess createManyAndReturn
   */
  export type UserPaperlessInstanceAccessCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * The data used to create many UserPaperlessInstanceAccesses.
     */
    data: UserPaperlessInstanceAccessCreateManyInput | UserPaperlessInstanceAccessCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserPaperlessInstanceAccess update
   */
  export type UserPaperlessInstanceAccessUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserPaperlessInstanceAccess.
     */
    data: XOR<
      UserPaperlessInstanceAccessUpdateInput,
      UserPaperlessInstanceAccessUncheckedUpdateInput
    >;
    /**
     * Choose, which UserPaperlessInstanceAccess to update.
     */
    where: UserPaperlessInstanceAccessWhereUniqueInput;
  };

  /**
   * UserPaperlessInstanceAccess updateMany
   */
  export type UserPaperlessInstanceAccessUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserPaperlessInstanceAccesses.
     */
    data: XOR<
      UserPaperlessInstanceAccessUpdateManyMutationInput,
      UserPaperlessInstanceAccessUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserPaperlessInstanceAccesses to update
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * Limit how many UserPaperlessInstanceAccesses to update.
     */
    limit?: number;
  };

  /**
   * UserPaperlessInstanceAccess updateManyAndReturn
   */
  export type UserPaperlessInstanceAccessUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * The data used to update UserPaperlessInstanceAccesses.
     */
    data: XOR<
      UserPaperlessInstanceAccessUpdateManyMutationInput,
      UserPaperlessInstanceAccessUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserPaperlessInstanceAccesses to update
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * Limit how many UserPaperlessInstanceAccesses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserPaperlessInstanceAccess upsert
   */
  export type UserPaperlessInstanceAccessUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserPaperlessInstanceAccess to update in case it exists.
     */
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    /**
     * In case the UserPaperlessInstanceAccess found by the `where` argument doesn't exist, create a new UserPaperlessInstanceAccess with this data.
     */
    create: XOR<
      UserPaperlessInstanceAccessCreateInput,
      UserPaperlessInstanceAccessUncheckedCreateInput
    >;
    /**
     * In case the UserPaperlessInstanceAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      UserPaperlessInstanceAccessUpdateInput,
      UserPaperlessInstanceAccessUncheckedUpdateInput
    >;
  };

  /**
   * UserPaperlessInstanceAccess delete
   */
  export type UserPaperlessInstanceAccessDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    /**
     * Filter which UserPaperlessInstanceAccess to delete.
     */
    where: UserPaperlessInstanceAccessWhereUniqueInput;
  };

  /**
   * UserPaperlessInstanceAccess deleteMany
   */
  export type UserPaperlessInstanceAccessDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserPaperlessInstanceAccesses to delete
     */
    where?: UserPaperlessInstanceAccessWhereInput;
    /**
     * Limit how many UserPaperlessInstanceAccesses to delete.
     */
    limit?: number;
  };

  /**
   * UserPaperlessInstanceAccess.user
   */
  export type UserPaperlessInstanceAccess$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * UserPaperlessInstanceAccess without action
   */
  export type UserPaperlessInstanceAccessDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
  };

  /**
   * Model UserAiAccountAccess
   */

  export type AggregateUserAiAccountAccess = {
    _count: UserAiAccountAccessCountAggregateOutputType | null;
    _min: UserAiAccountAccessMinAggregateOutputType | null;
    _max: UserAiAccountAccessMaxAggregateOutputType | null;
  };

  export type UserAiAccountAccessMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    aiAccountId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserAiAccountAccessMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    aiAccountId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserAiAccountAccessCountAggregateOutputType = {
    id: number;
    userId: number;
    aiAccountId: number;
    permission: number;
    createdAt: number;
    _all: number;
  };

  export type UserAiAccountAccessMinAggregateInputType = {
    id?: true;
    userId?: true;
    aiAccountId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserAiAccountAccessMaxAggregateInputType = {
    id?: true;
    userId?: true;
    aiAccountId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserAiAccountAccessCountAggregateInputType = {
    id?: true;
    userId?: true;
    aiAccountId?: true;
    permission?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserAiAccountAccessAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserAiAccountAccess to aggregate.
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiAccountAccesses to fetch.
     */
    orderBy?:
      | UserAiAccountAccessOrderByWithRelationInput
      | UserAiAccountAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserAiAccountAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiAccountAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiAccountAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserAiAccountAccesses
     **/
    _count?: true | UserAiAccountAccessCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserAiAccountAccessMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserAiAccountAccessMaxAggregateInputType;
  };

  export type GetUserAiAccountAccessAggregateType<T extends UserAiAccountAccessAggregateArgs> = {
    [P in keyof T & keyof AggregateUserAiAccountAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAiAccountAccess[P]>
      : GetScalarType<T[P], AggregateUserAiAccountAccess[P]>;
  };

  export type UserAiAccountAccessGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiAccountAccessWhereInput;
    orderBy?:
      | UserAiAccountAccessOrderByWithAggregationInput
      | UserAiAccountAccessOrderByWithAggregationInput[];
    by: UserAiAccountAccessScalarFieldEnum[] | UserAiAccountAccessScalarFieldEnum;
    having?: UserAiAccountAccessScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserAiAccountAccessCountAggregateInputType | true;
    _min?: UserAiAccountAccessMinAggregateInputType;
    _max?: UserAiAccountAccessMaxAggregateInputType;
  };

  export type UserAiAccountAccessGroupByOutputType = {
    id: string;
    userId: string | null;
    aiAccountId: string;
    permission: $Enums.Permission;
    createdAt: Date;
    _count: UserAiAccountAccessCountAggregateOutputType | null;
    _min: UserAiAccountAccessMinAggregateOutputType | null;
    _max: UserAiAccountAccessMaxAggregateOutputType | null;
  };

  type GetUserAiAccountAccessGroupByPayload<T extends UserAiAccountAccessGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserAiAccountAccessGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UserAiAccountAccessGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAiAccountAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserAiAccountAccessGroupByOutputType[P]>;
        }
      >
    >;

  export type UserAiAccountAccessSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiAccountId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiAccountAccess$userArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiAccountAccess']
  >;

  export type UserAiAccountAccessSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiAccountId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiAccountAccess$userArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiAccountAccess']
  >;

  export type UserAiAccountAccessSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiAccountId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiAccountAccess$userArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiAccountAccess']
  >;

  export type UserAiAccountAccessSelectScalar = {
    id?: boolean;
    userId?: boolean;
    aiAccountId?: boolean;
    permission?: boolean;
    createdAt?: boolean;
  };

  export type UserAiAccountAccessOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'aiAccountId' | 'permission' | 'createdAt',
    ExtArgs['result']['userAiAccountAccess']
  >;
  export type UserAiAccountAccessInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiAccountAccess$userArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
  };
  export type UserAiAccountAccessIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiAccountAccess$userArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
  };
  export type UserAiAccountAccessIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiAccountAccess$userArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
  };

  export type $UserAiAccountAccessPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UserAiAccountAccess';
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      aiAccount: Prisma.$AiAccountPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string | null;
        aiAccountId: string;
        permission: $Enums.Permission;
        createdAt: Date;
      },
      ExtArgs['result']['userAiAccountAccess']
    >;
    composites: {};
  };

  type UserAiAccountAccessGetPayload<
    S extends boolean | null | undefined | UserAiAccountAccessDefaultArgs,
  > = $Result.GetResult<Prisma.$UserAiAccountAccessPayload, S>;

  type UserAiAccountAccessCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserAiAccountAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserAiAccountAccessCountAggregateInputType | true;
  };

  export interface UserAiAccountAccessDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserAiAccountAccess'];
      meta: { name: 'UserAiAccountAccess' };
    };
    /**
     * Find zero or one UserAiAccountAccess that matches the filter.
     * @param {UserAiAccountAccessFindUniqueArgs} args - Arguments to find a UserAiAccountAccess
     * @example
     * // Get one UserAiAccountAccess
     * const userAiAccountAccess = await prisma.userAiAccountAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAiAccountAccessFindUniqueArgs>(
      args: SelectSubset<T, UserAiAccountAccessFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserAiAccountAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAiAccountAccessFindUniqueOrThrowArgs} args - Arguments to find a UserAiAccountAccess
     * @example
     * // Get one UserAiAccountAccess
     * const userAiAccountAccess = await prisma.userAiAccountAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAiAccountAccessFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserAiAccountAccessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserAiAccountAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessFindFirstArgs} args - Arguments to find a UserAiAccountAccess
     * @example
     * // Get one UserAiAccountAccess
     * const userAiAccountAccess = await prisma.userAiAccountAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAiAccountAccessFindFirstArgs>(
      args?: SelectSubset<T, UserAiAccountAccessFindFirstArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserAiAccountAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessFindFirstOrThrowArgs} args - Arguments to find a UserAiAccountAccess
     * @example
     * // Get one UserAiAccountAccess
     * const userAiAccountAccess = await prisma.userAiAccountAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAiAccountAccessFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserAiAccountAccessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserAiAccountAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAiAccountAccesses
     * const userAiAccountAccesses = await prisma.userAiAccountAccess.findMany()
     *
     * // Get first 10 UserAiAccountAccesses
     * const userAiAccountAccesses = await prisma.userAiAccountAccess.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userAiAccountAccessWithIdOnly = await prisma.userAiAccountAccess.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserAiAccountAccessFindManyArgs>(
      args?: SelectSubset<T, UserAiAccountAccessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a UserAiAccountAccess.
     * @param {UserAiAccountAccessCreateArgs} args - Arguments to create a UserAiAccountAccess.
     * @example
     * // Create one UserAiAccountAccess
     * const UserAiAccountAccess = await prisma.userAiAccountAccess.create({
     *   data: {
     *     // ... data to create a UserAiAccountAccess
     *   }
     * })
     *
     */
    create<T extends UserAiAccountAccessCreateArgs>(
      args: SelectSubset<T, UserAiAccountAccessCreateArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserAiAccountAccesses.
     * @param {UserAiAccountAccessCreateManyArgs} args - Arguments to create many UserAiAccountAccesses.
     * @example
     * // Create many UserAiAccountAccesses
     * const userAiAccountAccess = await prisma.userAiAccountAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserAiAccountAccessCreateManyArgs>(
      args?: SelectSubset<T, UserAiAccountAccessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserAiAccountAccesses and returns the data saved in the database.
     * @param {UserAiAccountAccessCreateManyAndReturnArgs} args - Arguments to create many UserAiAccountAccesses.
     * @example
     * // Create many UserAiAccountAccesses
     * const userAiAccountAccess = await prisma.userAiAccountAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserAiAccountAccesses and only return the `id`
     * const userAiAccountAccessWithIdOnly = await prisma.userAiAccountAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserAiAccountAccessCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserAiAccountAccessCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserAiAccountAccess.
     * @param {UserAiAccountAccessDeleteArgs} args - Arguments to delete one UserAiAccountAccess.
     * @example
     * // Delete one UserAiAccountAccess
     * const UserAiAccountAccess = await prisma.userAiAccountAccess.delete({
     *   where: {
     *     // ... filter to delete one UserAiAccountAccess
     *   }
     * })
     *
     */
    delete<T extends UserAiAccountAccessDeleteArgs>(
      args: SelectSubset<T, UserAiAccountAccessDeleteArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserAiAccountAccess.
     * @param {UserAiAccountAccessUpdateArgs} args - Arguments to update one UserAiAccountAccess.
     * @example
     * // Update one UserAiAccountAccess
     * const userAiAccountAccess = await prisma.userAiAccountAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserAiAccountAccessUpdateArgs>(
      args: SelectSubset<T, UserAiAccountAccessUpdateArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserAiAccountAccesses.
     * @param {UserAiAccountAccessDeleteManyArgs} args - Arguments to filter UserAiAccountAccesses to delete.
     * @example
     * // Delete a few UserAiAccountAccesses
     * const { count } = await prisma.userAiAccountAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserAiAccountAccessDeleteManyArgs>(
      args?: SelectSubset<T, UserAiAccountAccessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserAiAccountAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAiAccountAccesses
     * const userAiAccountAccess = await prisma.userAiAccountAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserAiAccountAccessUpdateManyArgs>(
      args: SelectSubset<T, UserAiAccountAccessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserAiAccountAccesses and returns the data updated in the database.
     * @param {UserAiAccountAccessUpdateManyAndReturnArgs} args - Arguments to update many UserAiAccountAccesses.
     * @example
     * // Update many UserAiAccountAccesses
     * const userAiAccountAccess = await prisma.userAiAccountAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserAiAccountAccesses and only return the `id`
     * const userAiAccountAccessWithIdOnly = await prisma.userAiAccountAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserAiAccountAccessUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserAiAccountAccessUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserAiAccountAccess.
     * @param {UserAiAccountAccessUpsertArgs} args - Arguments to update or create a UserAiAccountAccess.
     * @example
     * // Update or create a UserAiAccountAccess
     * const userAiAccountAccess = await prisma.userAiAccountAccess.upsert({
     *   create: {
     *     // ... data to create a UserAiAccountAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAiAccountAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserAiAccountAccessUpsertArgs>(
      args: SelectSubset<T, UserAiAccountAccessUpsertArgs<ExtArgs>>
    ): Prisma__UserAiAccountAccessClient<
      $Result.GetResult<
        Prisma.$UserAiAccountAccessPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserAiAccountAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessCountArgs} args - Arguments to filter UserAiAccountAccesses to count.
     * @example
     * // Count the number of UserAiAccountAccesses
     * const count = await prisma.userAiAccountAccess.count({
     *   where: {
     *     // ... the filter for the UserAiAccountAccesses we want to count
     *   }
     * })
     **/
    count<T extends UserAiAccountAccessCountArgs>(
      args?: Subset<T, UserAiAccountAccessCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAiAccountAccessCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserAiAccountAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAiAccountAccessAggregateArgs>(
      args: Subset<T, UserAiAccountAccessAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAiAccountAccessAggregateType<T>>;

    /**
     * Group by UserAiAccountAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiAccountAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserAiAccountAccessGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAiAccountAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserAiAccountAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserAiAccountAccessGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserAiAccountAccessGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserAiAccountAccess model
     */
    readonly fields: UserAiAccountAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAiAccountAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAiAccountAccessClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserAiAccountAccess$userArgs<ExtArgs> = {}>(
      args?: Subset<T, UserAiAccountAccess$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiAccount<T extends AiAccountDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AiAccountDefaultArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      | $Result.GetResult<
          Prisma.$AiAccountPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserAiAccountAccess model
   */
  interface UserAiAccountAccessFieldRefs {
    readonly id: FieldRef<'UserAiAccountAccess', 'String'>;
    readonly userId: FieldRef<'UserAiAccountAccess', 'String'>;
    readonly aiAccountId: FieldRef<'UserAiAccountAccess', 'String'>;
    readonly permission: FieldRef<'UserAiAccountAccess', 'Permission'>;
    readonly createdAt: FieldRef<'UserAiAccountAccess', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserAiAccountAccess findUnique
   */
  export type UserAiAccountAccessFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiAccountAccess to fetch.
     */
    where: UserAiAccountAccessWhereUniqueInput;
  };

  /**
   * UserAiAccountAccess findUniqueOrThrow
   */
  export type UserAiAccountAccessFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiAccountAccess to fetch.
     */
    where: UserAiAccountAccessWhereUniqueInput;
  };

  /**
   * UserAiAccountAccess findFirst
   */
  export type UserAiAccountAccessFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiAccountAccess to fetch.
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiAccountAccesses to fetch.
     */
    orderBy?:
      | UserAiAccountAccessOrderByWithRelationInput
      | UserAiAccountAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserAiAccountAccesses.
     */
    cursor?: UserAiAccountAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiAccountAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiAccountAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserAiAccountAccesses.
     */
    distinct?: UserAiAccountAccessScalarFieldEnum | UserAiAccountAccessScalarFieldEnum[];
  };

  /**
   * UserAiAccountAccess findFirstOrThrow
   */
  export type UserAiAccountAccessFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiAccountAccess to fetch.
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiAccountAccesses to fetch.
     */
    orderBy?:
      | UserAiAccountAccessOrderByWithRelationInput
      | UserAiAccountAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserAiAccountAccesses.
     */
    cursor?: UserAiAccountAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiAccountAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiAccountAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserAiAccountAccesses.
     */
    distinct?: UserAiAccountAccessScalarFieldEnum | UserAiAccountAccessScalarFieldEnum[];
  };

  /**
   * UserAiAccountAccess findMany
   */
  export type UserAiAccountAccessFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiAccountAccesses to fetch.
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiAccountAccesses to fetch.
     */
    orderBy?:
      | UserAiAccountAccessOrderByWithRelationInput
      | UserAiAccountAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserAiAccountAccesses.
     */
    cursor?: UserAiAccountAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiAccountAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiAccountAccesses.
     */
    skip?: number;
    distinct?: UserAiAccountAccessScalarFieldEnum | UserAiAccountAccessScalarFieldEnum[];
  };

  /**
   * UserAiAccountAccess create
   */
  export type UserAiAccountAccessCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserAiAccountAccess.
     */
    data: XOR<UserAiAccountAccessCreateInput, UserAiAccountAccessUncheckedCreateInput>;
  };

  /**
   * UserAiAccountAccess createMany
   */
  export type UserAiAccountAccessCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserAiAccountAccesses.
     */
    data: UserAiAccountAccessCreateManyInput | UserAiAccountAccessCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserAiAccountAccess createManyAndReturn
   */
  export type UserAiAccountAccessCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * The data used to create many UserAiAccountAccesses.
     */
    data: UserAiAccountAccessCreateManyInput | UserAiAccountAccessCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserAiAccountAccess update
   */
  export type UserAiAccountAccessUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserAiAccountAccess.
     */
    data: XOR<UserAiAccountAccessUpdateInput, UserAiAccountAccessUncheckedUpdateInput>;
    /**
     * Choose, which UserAiAccountAccess to update.
     */
    where: UserAiAccountAccessWhereUniqueInput;
  };

  /**
   * UserAiAccountAccess updateMany
   */
  export type UserAiAccountAccessUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserAiAccountAccesses.
     */
    data: XOR<
      UserAiAccountAccessUpdateManyMutationInput,
      UserAiAccountAccessUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserAiAccountAccesses to update
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * Limit how many UserAiAccountAccesses to update.
     */
    limit?: number;
  };

  /**
   * UserAiAccountAccess updateManyAndReturn
   */
  export type UserAiAccountAccessUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * The data used to update UserAiAccountAccesses.
     */
    data: XOR<
      UserAiAccountAccessUpdateManyMutationInput,
      UserAiAccountAccessUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserAiAccountAccesses to update
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * Limit how many UserAiAccountAccesses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserAiAccountAccess upsert
   */
  export type UserAiAccountAccessUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserAiAccountAccess to update in case it exists.
     */
    where: UserAiAccountAccessWhereUniqueInput;
    /**
     * In case the UserAiAccountAccess found by the `where` argument doesn't exist, create a new UserAiAccountAccess with this data.
     */
    create: XOR<UserAiAccountAccessCreateInput, UserAiAccountAccessUncheckedCreateInput>;
    /**
     * In case the UserAiAccountAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAiAccountAccessUpdateInput, UserAiAccountAccessUncheckedUpdateInput>;
  };

  /**
   * UserAiAccountAccess delete
   */
  export type UserAiAccountAccessDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    /**
     * Filter which UserAiAccountAccess to delete.
     */
    where: UserAiAccountAccessWhereUniqueInput;
  };

  /**
   * UserAiAccountAccess deleteMany
   */
  export type UserAiAccountAccessDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserAiAccountAccesses to delete
     */
    where?: UserAiAccountAccessWhereInput;
    /**
     * Limit how many UserAiAccountAccesses to delete.
     */
    limit?: number;
  };

  /**
   * UserAiAccountAccess.user
   */
  export type UserAiAccountAccess$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * UserAiAccountAccess without action
   */
  export type UserAiAccountAccessDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
  };

  /**
   * Model UserAiModelAccess
   */

  export type AggregateUserAiModelAccess = {
    _count: UserAiModelAccessCountAggregateOutputType | null;
    _min: UserAiModelAccessMinAggregateOutputType | null;
    _max: UserAiModelAccessMaxAggregateOutputType | null;
  };

  export type UserAiModelAccessMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    aiModelId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserAiModelAccessMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    aiModelId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserAiModelAccessCountAggregateOutputType = {
    id: number;
    userId: number;
    aiModelId: number;
    permission: number;
    createdAt: number;
    _all: number;
  };

  export type UserAiModelAccessMinAggregateInputType = {
    id?: true;
    userId?: true;
    aiModelId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserAiModelAccessMaxAggregateInputType = {
    id?: true;
    userId?: true;
    aiModelId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserAiModelAccessCountAggregateInputType = {
    id?: true;
    userId?: true;
    aiModelId?: true;
    permission?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserAiModelAccessAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserAiModelAccess to aggregate.
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiModelAccesses to fetch.
     */
    orderBy?:
      | UserAiModelAccessOrderByWithRelationInput
      | UserAiModelAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserAiModelAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiModelAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiModelAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserAiModelAccesses
     **/
    _count?: true | UserAiModelAccessCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserAiModelAccessMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserAiModelAccessMaxAggregateInputType;
  };

  export type GetUserAiModelAccessAggregateType<T extends UserAiModelAccessAggregateArgs> = {
    [P in keyof T & keyof AggregateUserAiModelAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAiModelAccess[P]>
      : GetScalarType<T[P], AggregateUserAiModelAccess[P]>;
  };

  export type UserAiModelAccessGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiModelAccessWhereInput;
    orderBy?:
      | UserAiModelAccessOrderByWithAggregationInput
      | UserAiModelAccessOrderByWithAggregationInput[];
    by: UserAiModelAccessScalarFieldEnum[] | UserAiModelAccessScalarFieldEnum;
    having?: UserAiModelAccessScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserAiModelAccessCountAggregateInputType | true;
    _min?: UserAiModelAccessMinAggregateInputType;
    _max?: UserAiModelAccessMaxAggregateInputType;
  };

  export type UserAiModelAccessGroupByOutputType = {
    id: string;
    userId: string | null;
    aiModelId: string;
    permission: $Enums.Permission;
    createdAt: Date;
    _count: UserAiModelAccessCountAggregateOutputType | null;
    _min: UserAiModelAccessMinAggregateOutputType | null;
    _max: UserAiModelAccessMaxAggregateOutputType | null;
  };

  type GetUserAiModelAccessGroupByPayload<T extends UserAiModelAccessGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserAiModelAccessGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UserAiModelAccessGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAiModelAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserAiModelAccessGroupByOutputType[P]>;
        }
      >
    >;

  export type UserAiModelAccessSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiModelId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiModelAccess$userArgs<ExtArgs>;
      aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiModelAccess']
  >;

  export type UserAiModelAccessSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiModelId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiModelAccess$userArgs<ExtArgs>;
      aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiModelAccess']
  >;

  export type UserAiModelAccessSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiModelId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiModelAccess$userArgs<ExtArgs>;
      aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiModelAccess']
  >;

  export type UserAiModelAccessSelectScalar = {
    id?: boolean;
    userId?: boolean;
    aiModelId?: boolean;
    permission?: boolean;
    createdAt?: boolean;
  };

  export type UserAiModelAccessOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'aiModelId' | 'permission' | 'createdAt',
    ExtArgs['result']['userAiModelAccess']
  >;
  export type UserAiModelAccessInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiModelAccess$userArgs<ExtArgs>;
    aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
  };
  export type UserAiModelAccessIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiModelAccess$userArgs<ExtArgs>;
    aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
  };
  export type UserAiModelAccessIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiModelAccess$userArgs<ExtArgs>;
    aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
  };

  export type $UserAiModelAccessPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UserAiModelAccess';
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      aiModel: Prisma.$AiModelPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string | null;
        aiModelId: string;
        permission: $Enums.Permission;
        createdAt: Date;
      },
      ExtArgs['result']['userAiModelAccess']
    >;
    composites: {};
  };

  type UserAiModelAccessGetPayload<
    S extends boolean | null | undefined | UserAiModelAccessDefaultArgs,
  > = $Result.GetResult<Prisma.$UserAiModelAccessPayload, S>;

  type UserAiModelAccessCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserAiModelAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserAiModelAccessCountAggregateInputType | true;
  };

  export interface UserAiModelAccessDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserAiModelAccess'];
      meta: { name: 'UserAiModelAccess' };
    };
    /**
     * Find zero or one UserAiModelAccess that matches the filter.
     * @param {UserAiModelAccessFindUniqueArgs} args - Arguments to find a UserAiModelAccess
     * @example
     * // Get one UserAiModelAccess
     * const userAiModelAccess = await prisma.userAiModelAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAiModelAccessFindUniqueArgs>(
      args: SelectSubset<T, UserAiModelAccessFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<
        Prisma.$UserAiModelAccessPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserAiModelAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAiModelAccessFindUniqueOrThrowArgs} args - Arguments to find a UserAiModelAccess
     * @example
     * // Get one UserAiModelAccess
     * const userAiModelAccess = await prisma.userAiModelAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAiModelAccessFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserAiModelAccessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<
        Prisma.$UserAiModelAccessPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserAiModelAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessFindFirstArgs} args - Arguments to find a UserAiModelAccess
     * @example
     * // Get one UserAiModelAccess
     * const userAiModelAccess = await prisma.userAiModelAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAiModelAccessFindFirstArgs>(
      args?: SelectSubset<T, UserAiModelAccessFindFirstArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<
        Prisma.$UserAiModelAccessPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserAiModelAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessFindFirstOrThrowArgs} args - Arguments to find a UserAiModelAccess
     * @example
     * // Get one UserAiModelAccess
     * const userAiModelAccess = await prisma.userAiModelAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAiModelAccessFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserAiModelAccessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<
        Prisma.$UserAiModelAccessPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserAiModelAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAiModelAccesses
     * const userAiModelAccesses = await prisma.userAiModelAccess.findMany()
     *
     * // Get first 10 UserAiModelAccesses
     * const userAiModelAccesses = await prisma.userAiModelAccess.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userAiModelAccessWithIdOnly = await prisma.userAiModelAccess.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserAiModelAccessFindManyArgs>(
      args?: SelectSubset<T, UserAiModelAccessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserAiModelAccessPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a UserAiModelAccess.
     * @param {UserAiModelAccessCreateArgs} args - Arguments to create a UserAiModelAccess.
     * @example
     * // Create one UserAiModelAccess
     * const UserAiModelAccess = await prisma.userAiModelAccess.create({
     *   data: {
     *     // ... data to create a UserAiModelAccess
     *   }
     * })
     *
     */
    create<T extends UserAiModelAccessCreateArgs>(
      args: SelectSubset<T, UserAiModelAccessCreateArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<Prisma.$UserAiModelAccessPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserAiModelAccesses.
     * @param {UserAiModelAccessCreateManyArgs} args - Arguments to create many UserAiModelAccesses.
     * @example
     * // Create many UserAiModelAccesses
     * const userAiModelAccess = await prisma.userAiModelAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserAiModelAccessCreateManyArgs>(
      args?: SelectSubset<T, UserAiModelAccessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserAiModelAccesses and returns the data saved in the database.
     * @param {UserAiModelAccessCreateManyAndReturnArgs} args - Arguments to create many UserAiModelAccesses.
     * @example
     * // Create many UserAiModelAccesses
     * const userAiModelAccess = await prisma.userAiModelAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserAiModelAccesses and only return the `id`
     * const userAiModelAccessWithIdOnly = await prisma.userAiModelAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserAiModelAccessCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserAiModelAccessCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiModelAccessPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserAiModelAccess.
     * @param {UserAiModelAccessDeleteArgs} args - Arguments to delete one UserAiModelAccess.
     * @example
     * // Delete one UserAiModelAccess
     * const UserAiModelAccess = await prisma.userAiModelAccess.delete({
     *   where: {
     *     // ... filter to delete one UserAiModelAccess
     *   }
     * })
     *
     */
    delete<T extends UserAiModelAccessDeleteArgs>(
      args: SelectSubset<T, UserAiModelAccessDeleteArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<Prisma.$UserAiModelAccessPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserAiModelAccess.
     * @param {UserAiModelAccessUpdateArgs} args - Arguments to update one UserAiModelAccess.
     * @example
     * // Update one UserAiModelAccess
     * const userAiModelAccess = await prisma.userAiModelAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserAiModelAccessUpdateArgs>(
      args: SelectSubset<T, UserAiModelAccessUpdateArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<Prisma.$UserAiModelAccessPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserAiModelAccesses.
     * @param {UserAiModelAccessDeleteManyArgs} args - Arguments to filter UserAiModelAccesses to delete.
     * @example
     * // Delete a few UserAiModelAccesses
     * const { count } = await prisma.userAiModelAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserAiModelAccessDeleteManyArgs>(
      args?: SelectSubset<T, UserAiModelAccessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserAiModelAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAiModelAccesses
     * const userAiModelAccess = await prisma.userAiModelAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserAiModelAccessUpdateManyArgs>(
      args: SelectSubset<T, UserAiModelAccessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserAiModelAccesses and returns the data updated in the database.
     * @param {UserAiModelAccessUpdateManyAndReturnArgs} args - Arguments to update many UserAiModelAccesses.
     * @example
     * // Update many UserAiModelAccesses
     * const userAiModelAccess = await prisma.userAiModelAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserAiModelAccesses and only return the `id`
     * const userAiModelAccessWithIdOnly = await prisma.userAiModelAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserAiModelAccessUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserAiModelAccessUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiModelAccessPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserAiModelAccess.
     * @param {UserAiModelAccessUpsertArgs} args - Arguments to update or create a UserAiModelAccess.
     * @example
     * // Update or create a UserAiModelAccess
     * const userAiModelAccess = await prisma.userAiModelAccess.upsert({
     *   create: {
     *     // ... data to create a UserAiModelAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAiModelAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserAiModelAccessUpsertArgs>(
      args: SelectSubset<T, UserAiModelAccessUpsertArgs<ExtArgs>>
    ): Prisma__UserAiModelAccessClient<
      $Result.GetResult<Prisma.$UserAiModelAccessPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserAiModelAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessCountArgs} args - Arguments to filter UserAiModelAccesses to count.
     * @example
     * // Count the number of UserAiModelAccesses
     * const count = await prisma.userAiModelAccess.count({
     *   where: {
     *     // ... the filter for the UserAiModelAccesses we want to count
     *   }
     * })
     **/
    count<T extends UserAiModelAccessCountArgs>(
      args?: Subset<T, UserAiModelAccessCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAiModelAccessCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserAiModelAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAiModelAccessAggregateArgs>(
      args: Subset<T, UserAiModelAccessAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAiModelAccessAggregateType<T>>;

    /**
     * Group by UserAiModelAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiModelAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserAiModelAccessGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAiModelAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserAiModelAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserAiModelAccessGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserAiModelAccessGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserAiModelAccess model
     */
    readonly fields: UserAiModelAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAiModelAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAiModelAccessClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserAiModelAccess$userArgs<ExtArgs> = {}>(
      args?: Subset<T, UserAiModelAccess$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiModel<T extends AiModelDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AiModelDefaultArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      | $Result.GetResult<
          Prisma.$AiModelPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserAiModelAccess model
   */
  interface UserAiModelAccessFieldRefs {
    readonly id: FieldRef<'UserAiModelAccess', 'String'>;
    readonly userId: FieldRef<'UserAiModelAccess', 'String'>;
    readonly aiModelId: FieldRef<'UserAiModelAccess', 'String'>;
    readonly permission: FieldRef<'UserAiModelAccess', 'Permission'>;
    readonly createdAt: FieldRef<'UserAiModelAccess', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserAiModelAccess findUnique
   */
  export type UserAiModelAccessFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiModelAccess to fetch.
     */
    where: UserAiModelAccessWhereUniqueInput;
  };

  /**
   * UserAiModelAccess findUniqueOrThrow
   */
  export type UserAiModelAccessFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiModelAccess to fetch.
     */
    where: UserAiModelAccessWhereUniqueInput;
  };

  /**
   * UserAiModelAccess findFirst
   */
  export type UserAiModelAccessFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiModelAccess to fetch.
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiModelAccesses to fetch.
     */
    orderBy?:
      | UserAiModelAccessOrderByWithRelationInput
      | UserAiModelAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserAiModelAccesses.
     */
    cursor?: UserAiModelAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiModelAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiModelAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserAiModelAccesses.
     */
    distinct?: UserAiModelAccessScalarFieldEnum | UserAiModelAccessScalarFieldEnum[];
  };

  /**
   * UserAiModelAccess findFirstOrThrow
   */
  export type UserAiModelAccessFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiModelAccess to fetch.
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiModelAccesses to fetch.
     */
    orderBy?:
      | UserAiModelAccessOrderByWithRelationInput
      | UserAiModelAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserAiModelAccesses.
     */
    cursor?: UserAiModelAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiModelAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiModelAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserAiModelAccesses.
     */
    distinct?: UserAiModelAccessScalarFieldEnum | UserAiModelAccessScalarFieldEnum[];
  };

  /**
   * UserAiModelAccess findMany
   */
  export type UserAiModelAccessFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiModelAccesses to fetch.
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiModelAccesses to fetch.
     */
    orderBy?:
      | UserAiModelAccessOrderByWithRelationInput
      | UserAiModelAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserAiModelAccesses.
     */
    cursor?: UserAiModelAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiModelAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiModelAccesses.
     */
    skip?: number;
    distinct?: UserAiModelAccessScalarFieldEnum | UserAiModelAccessScalarFieldEnum[];
  };

  /**
   * UserAiModelAccess create
   */
  export type UserAiModelAccessCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserAiModelAccess.
     */
    data: XOR<UserAiModelAccessCreateInput, UserAiModelAccessUncheckedCreateInput>;
  };

  /**
   * UserAiModelAccess createMany
   */
  export type UserAiModelAccessCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserAiModelAccesses.
     */
    data: UserAiModelAccessCreateManyInput | UserAiModelAccessCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserAiModelAccess createManyAndReturn
   */
  export type UserAiModelAccessCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * The data used to create many UserAiModelAccesses.
     */
    data: UserAiModelAccessCreateManyInput | UserAiModelAccessCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserAiModelAccess update
   */
  export type UserAiModelAccessUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserAiModelAccess.
     */
    data: XOR<UserAiModelAccessUpdateInput, UserAiModelAccessUncheckedUpdateInput>;
    /**
     * Choose, which UserAiModelAccess to update.
     */
    where: UserAiModelAccessWhereUniqueInput;
  };

  /**
   * UserAiModelAccess updateMany
   */
  export type UserAiModelAccessUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserAiModelAccesses.
     */
    data: XOR<UserAiModelAccessUpdateManyMutationInput, UserAiModelAccessUncheckedUpdateManyInput>;
    /**
     * Filter which UserAiModelAccesses to update
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * Limit how many UserAiModelAccesses to update.
     */
    limit?: number;
  };

  /**
   * UserAiModelAccess updateManyAndReturn
   */
  export type UserAiModelAccessUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * The data used to update UserAiModelAccesses.
     */
    data: XOR<UserAiModelAccessUpdateManyMutationInput, UserAiModelAccessUncheckedUpdateManyInput>;
    /**
     * Filter which UserAiModelAccesses to update
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * Limit how many UserAiModelAccesses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserAiModelAccess upsert
   */
  export type UserAiModelAccessUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserAiModelAccess to update in case it exists.
     */
    where: UserAiModelAccessWhereUniqueInput;
    /**
     * In case the UserAiModelAccess found by the `where` argument doesn't exist, create a new UserAiModelAccess with this data.
     */
    create: XOR<UserAiModelAccessCreateInput, UserAiModelAccessUncheckedCreateInput>;
    /**
     * In case the UserAiModelAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAiModelAccessUpdateInput, UserAiModelAccessUncheckedUpdateInput>;
  };

  /**
   * UserAiModelAccess delete
   */
  export type UserAiModelAccessDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    /**
     * Filter which UserAiModelAccess to delete.
     */
    where: UserAiModelAccessWhereUniqueInput;
  };

  /**
   * UserAiModelAccess deleteMany
   */
  export type UserAiModelAccessDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserAiModelAccesses to delete
     */
    where?: UserAiModelAccessWhereInput;
    /**
     * Limit how many UserAiModelAccesses to delete.
     */
    limit?: number;
  };

  /**
   * UserAiModelAccess.user
   */
  export type UserAiModelAccess$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * UserAiModelAccess without action
   */
  export type UserAiModelAccessDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
  };

  /**
   * Model UserAiBotAccess
   */

  export type AggregateUserAiBotAccess = {
    _count: UserAiBotAccessCountAggregateOutputType | null;
    _min: UserAiBotAccessMinAggregateOutputType | null;
    _max: UserAiBotAccessMaxAggregateOutputType | null;
  };

  export type UserAiBotAccessMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    aiBotId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserAiBotAccessMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    aiBotId: string | null;
    permission: $Enums.Permission | null;
    createdAt: Date | null;
  };

  export type UserAiBotAccessCountAggregateOutputType = {
    id: number;
    userId: number;
    aiBotId: number;
    permission: number;
    createdAt: number;
    _all: number;
  };

  export type UserAiBotAccessMinAggregateInputType = {
    id?: true;
    userId?: true;
    aiBotId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserAiBotAccessMaxAggregateInputType = {
    id?: true;
    userId?: true;
    aiBotId?: true;
    permission?: true;
    createdAt?: true;
  };

  export type UserAiBotAccessCountAggregateInputType = {
    id?: true;
    userId?: true;
    aiBotId?: true;
    permission?: true;
    createdAt?: true;
    _all?: true;
  };

  export type UserAiBotAccessAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserAiBotAccess to aggregate.
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiBotAccesses to fetch.
     */
    orderBy?: UserAiBotAccessOrderByWithRelationInput | UserAiBotAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserAiBotAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiBotAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiBotAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserAiBotAccesses
     **/
    _count?: true | UserAiBotAccessCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserAiBotAccessMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserAiBotAccessMaxAggregateInputType;
  };

  export type GetUserAiBotAccessAggregateType<T extends UserAiBotAccessAggregateArgs> = {
    [P in keyof T & keyof AggregateUserAiBotAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAiBotAccess[P]>
      : GetScalarType<T[P], AggregateUserAiBotAccess[P]>;
  };

  export type UserAiBotAccessGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserAiBotAccessWhereInput;
    orderBy?:
      | UserAiBotAccessOrderByWithAggregationInput
      | UserAiBotAccessOrderByWithAggregationInput[];
    by: UserAiBotAccessScalarFieldEnum[] | UserAiBotAccessScalarFieldEnum;
    having?: UserAiBotAccessScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserAiBotAccessCountAggregateInputType | true;
    _min?: UserAiBotAccessMinAggregateInputType;
    _max?: UserAiBotAccessMaxAggregateInputType;
  };

  export type UserAiBotAccessGroupByOutputType = {
    id: string;
    userId: string | null;
    aiBotId: string;
    permission: $Enums.Permission;
    createdAt: Date;
    _count: UserAiBotAccessCountAggregateOutputType | null;
    _min: UserAiBotAccessMinAggregateOutputType | null;
    _max: UserAiBotAccessMaxAggregateOutputType | null;
  };

  type GetUserAiBotAccessGroupByPayload<T extends UserAiBotAccessGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserAiBotAccessGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UserAiBotAccessGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAiBotAccessGroupByOutputType[P]>
            : GetScalarType<T[P], UserAiBotAccessGroupByOutputType[P]>;
        }
      >
    >;

  export type UserAiBotAccessSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiBotId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiBotAccess$userArgs<ExtArgs>;
      aiBot?: boolean | AiBotDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiBotAccess']
  >;

  export type UserAiBotAccessSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiBotId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiBotAccess$userArgs<ExtArgs>;
      aiBot?: boolean | AiBotDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiBotAccess']
  >;

  export type UserAiBotAccessSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      aiBotId?: boolean;
      permission?: boolean;
      createdAt?: boolean;
      user?: boolean | UserAiBotAccess$userArgs<ExtArgs>;
      aiBot?: boolean | AiBotDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userAiBotAccess']
  >;

  export type UserAiBotAccessSelectScalar = {
    id?: boolean;
    userId?: boolean;
    aiBotId?: boolean;
    permission?: boolean;
    createdAt?: boolean;
  };

  export type UserAiBotAccessOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'userId' | 'aiBotId' | 'permission' | 'createdAt',
    ExtArgs['result']['userAiBotAccess']
  >;
  export type UserAiBotAccessInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiBotAccess$userArgs<ExtArgs>;
    aiBot?: boolean | AiBotDefaultArgs<ExtArgs>;
  };
  export type UserAiBotAccessIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiBotAccess$userArgs<ExtArgs>;
    aiBot?: boolean | AiBotDefaultArgs<ExtArgs>;
  };
  export type UserAiBotAccessIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserAiBotAccess$userArgs<ExtArgs>;
    aiBot?: boolean | AiBotDefaultArgs<ExtArgs>;
  };

  export type $UserAiBotAccessPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UserAiBotAccess';
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
      aiBot: Prisma.$AiBotPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string | null;
        aiBotId: string;
        permission: $Enums.Permission;
        createdAt: Date;
      },
      ExtArgs['result']['userAiBotAccess']
    >;
    composites: {};
  };

  type UserAiBotAccessGetPayload<
    S extends boolean | null | undefined | UserAiBotAccessDefaultArgs,
  > = $Result.GetResult<Prisma.$UserAiBotAccessPayload, S>;

  type UserAiBotAccessCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserAiBotAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserAiBotAccessCountAggregateInputType | true;
  };

  export interface UserAiBotAccessDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserAiBotAccess'];
      meta: { name: 'UserAiBotAccess' };
    };
    /**
     * Find zero or one UserAiBotAccess that matches the filter.
     * @param {UserAiBotAccessFindUniqueArgs} args - Arguments to find a UserAiBotAccess
     * @example
     * // Get one UserAiBotAccess
     * const userAiBotAccess = await prisma.userAiBotAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAiBotAccessFindUniqueArgs>(
      args: SelectSubset<T, UserAiBotAccessFindUniqueArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<
        Prisma.$UserAiBotAccessPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one UserAiBotAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAiBotAccessFindUniqueOrThrowArgs} args - Arguments to find a UserAiBotAccess
     * @example
     * // Get one UserAiBotAccess
     * const userAiBotAccess = await prisma.userAiBotAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAiBotAccessFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserAiBotAccessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<
        Prisma.$UserAiBotAccessPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserAiBotAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessFindFirstArgs} args - Arguments to find a UserAiBotAccess
     * @example
     * // Get one UserAiBotAccess
     * const userAiBotAccess = await prisma.userAiBotAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAiBotAccessFindFirstArgs>(
      args?: SelectSubset<T, UserAiBotAccessFindFirstArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<
        Prisma.$UserAiBotAccessPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first UserAiBotAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessFindFirstOrThrowArgs} args - Arguments to find a UserAiBotAccess
     * @example
     * // Get one UserAiBotAccess
     * const userAiBotAccess = await prisma.userAiBotAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAiBotAccessFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserAiBotAccessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<
        Prisma.$UserAiBotAccessPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more UserAiBotAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAiBotAccesses
     * const userAiBotAccesses = await prisma.userAiBotAccess.findMany()
     *
     * // Get first 10 UserAiBotAccesses
     * const userAiBotAccesses = await prisma.userAiBotAccess.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userAiBotAccessWithIdOnly = await prisma.userAiBotAccess.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserAiBotAccessFindManyArgs>(
      args?: SelectSubset<T, UserAiBotAccessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a UserAiBotAccess.
     * @param {UserAiBotAccessCreateArgs} args - Arguments to create a UserAiBotAccess.
     * @example
     * // Create one UserAiBotAccess
     * const UserAiBotAccess = await prisma.userAiBotAccess.create({
     *   data: {
     *     // ... data to create a UserAiBotAccess
     *   }
     * })
     *
     */
    create<T extends UserAiBotAccessCreateArgs>(
      args: SelectSubset<T, UserAiBotAccessCreateArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many UserAiBotAccesses.
     * @param {UserAiBotAccessCreateManyArgs} args - Arguments to create many UserAiBotAccesses.
     * @example
     * // Create many UserAiBotAccesses
     * const userAiBotAccess = await prisma.userAiBotAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserAiBotAccessCreateManyArgs>(
      args?: SelectSubset<T, UserAiBotAccessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserAiBotAccesses and returns the data saved in the database.
     * @param {UserAiBotAccessCreateManyAndReturnArgs} args - Arguments to create many UserAiBotAccesses.
     * @example
     * // Create many UserAiBotAccesses
     * const userAiBotAccess = await prisma.userAiBotAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserAiBotAccesses and only return the `id`
     * const userAiBotAccessWithIdOnly = await prisma.userAiBotAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserAiBotAccessCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserAiBotAccessCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiBotAccessPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a UserAiBotAccess.
     * @param {UserAiBotAccessDeleteArgs} args - Arguments to delete one UserAiBotAccess.
     * @example
     * // Delete one UserAiBotAccess
     * const UserAiBotAccess = await prisma.userAiBotAccess.delete({
     *   where: {
     *     // ... filter to delete one UserAiBotAccess
     *   }
     * })
     *
     */
    delete<T extends UserAiBotAccessDeleteArgs>(
      args: SelectSubset<T, UserAiBotAccessDeleteArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one UserAiBotAccess.
     * @param {UserAiBotAccessUpdateArgs} args - Arguments to update one UserAiBotAccess.
     * @example
     * // Update one UserAiBotAccess
     * const userAiBotAccess = await prisma.userAiBotAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserAiBotAccessUpdateArgs>(
      args: SelectSubset<T, UserAiBotAccessUpdateArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more UserAiBotAccesses.
     * @param {UserAiBotAccessDeleteManyArgs} args - Arguments to filter UserAiBotAccesses to delete.
     * @example
     * // Delete a few UserAiBotAccesses
     * const { count } = await prisma.userAiBotAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserAiBotAccessDeleteManyArgs>(
      args?: SelectSubset<T, UserAiBotAccessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserAiBotAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAiBotAccesses
     * const userAiBotAccess = await prisma.userAiBotAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserAiBotAccessUpdateManyArgs>(
      args: SelectSubset<T, UserAiBotAccessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserAiBotAccesses and returns the data updated in the database.
     * @param {UserAiBotAccessUpdateManyAndReturnArgs} args - Arguments to update many UserAiBotAccesses.
     * @example
     * // Update many UserAiBotAccesses
     * const userAiBotAccess = await prisma.userAiBotAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more UserAiBotAccesses and only return the `id`
     * const userAiBotAccessWithIdOnly = await prisma.userAiBotAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserAiBotAccessUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserAiBotAccessUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserAiBotAccessPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one UserAiBotAccess.
     * @param {UserAiBotAccessUpsertArgs} args - Arguments to update or create a UserAiBotAccess.
     * @example
     * // Update or create a UserAiBotAccess
     * const userAiBotAccess = await prisma.userAiBotAccess.upsert({
     *   create: {
     *     // ... data to create a UserAiBotAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAiBotAccess we want to update
     *   }
     * })
     */
    upsert<T extends UserAiBotAccessUpsertArgs>(
      args: SelectSubset<T, UserAiBotAccessUpsertArgs<ExtArgs>>
    ): Prisma__UserAiBotAccessClient<
      $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of UserAiBotAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessCountArgs} args - Arguments to filter UserAiBotAccesses to count.
     * @example
     * // Count the number of UserAiBotAccesses
     * const count = await prisma.userAiBotAccess.count({
     *   where: {
     *     // ... the filter for the UserAiBotAccesses we want to count
     *   }
     * })
     **/
    count<T extends UserAiBotAccessCountArgs>(
      args?: Subset<T, UserAiBotAccessCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAiBotAccessCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserAiBotAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAiBotAccessAggregateArgs>(
      args: Subset<T, UserAiBotAccessAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAiBotAccessAggregateType<T>>;

    /**
     * Group by UserAiBotAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAiBotAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserAiBotAccessGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAiBotAccessGroupByArgs['orderBy'] }
        : { orderBy?: UserAiBotAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserAiBotAccessGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserAiBotAccessGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserAiBotAccess model
     */
    readonly fields: UserAiBotAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAiBotAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAiBotAccessClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserAiBotAccess$userArgs<ExtArgs> = {}>(
      args?: Subset<T, UserAiBotAccess$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiBot<T extends AiBotDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AiBotDefaultArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      | $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserAiBotAccess model
   */
  interface UserAiBotAccessFieldRefs {
    readonly id: FieldRef<'UserAiBotAccess', 'String'>;
    readonly userId: FieldRef<'UserAiBotAccess', 'String'>;
    readonly aiBotId: FieldRef<'UserAiBotAccess', 'String'>;
    readonly permission: FieldRef<'UserAiBotAccess', 'Permission'>;
    readonly createdAt: FieldRef<'UserAiBotAccess', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserAiBotAccess findUnique
   */
  export type UserAiBotAccessFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiBotAccess to fetch.
     */
    where: UserAiBotAccessWhereUniqueInput;
  };

  /**
   * UserAiBotAccess findUniqueOrThrow
   */
  export type UserAiBotAccessFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiBotAccess to fetch.
     */
    where: UserAiBotAccessWhereUniqueInput;
  };

  /**
   * UserAiBotAccess findFirst
   */
  export type UserAiBotAccessFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiBotAccess to fetch.
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiBotAccesses to fetch.
     */
    orderBy?: UserAiBotAccessOrderByWithRelationInput | UserAiBotAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserAiBotAccesses.
     */
    cursor?: UserAiBotAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiBotAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiBotAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserAiBotAccesses.
     */
    distinct?: UserAiBotAccessScalarFieldEnum | UserAiBotAccessScalarFieldEnum[];
  };

  /**
   * UserAiBotAccess findFirstOrThrow
   */
  export type UserAiBotAccessFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiBotAccess to fetch.
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiBotAccesses to fetch.
     */
    orderBy?: UserAiBotAccessOrderByWithRelationInput | UserAiBotAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserAiBotAccesses.
     */
    cursor?: UserAiBotAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiBotAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiBotAccesses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserAiBotAccesses.
     */
    distinct?: UserAiBotAccessScalarFieldEnum | UserAiBotAccessScalarFieldEnum[];
  };

  /**
   * UserAiBotAccess findMany
   */
  export type UserAiBotAccessFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * Filter, which UserAiBotAccesses to fetch.
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserAiBotAccesses to fetch.
     */
    orderBy?: UserAiBotAccessOrderByWithRelationInput | UserAiBotAccessOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserAiBotAccesses.
     */
    cursor?: UserAiBotAccessWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserAiBotAccesses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserAiBotAccesses.
     */
    skip?: number;
    distinct?: UserAiBotAccessScalarFieldEnum | UserAiBotAccessScalarFieldEnum[];
  };

  /**
   * UserAiBotAccess create
   */
  export type UserAiBotAccessCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserAiBotAccess.
     */
    data: XOR<UserAiBotAccessCreateInput, UserAiBotAccessUncheckedCreateInput>;
  };

  /**
   * UserAiBotAccess createMany
   */
  export type UserAiBotAccessCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserAiBotAccesses.
     */
    data: UserAiBotAccessCreateManyInput | UserAiBotAccessCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserAiBotAccess createManyAndReturn
   */
  export type UserAiBotAccessCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * The data used to create many UserAiBotAccesses.
     */
    data: UserAiBotAccessCreateManyInput | UserAiBotAccessCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserAiBotAccess update
   */
  export type UserAiBotAccessUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserAiBotAccess.
     */
    data: XOR<UserAiBotAccessUpdateInput, UserAiBotAccessUncheckedUpdateInput>;
    /**
     * Choose, which UserAiBotAccess to update.
     */
    where: UserAiBotAccessWhereUniqueInput;
  };

  /**
   * UserAiBotAccess updateMany
   */
  export type UserAiBotAccessUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserAiBotAccesses.
     */
    data: XOR<UserAiBotAccessUpdateManyMutationInput, UserAiBotAccessUncheckedUpdateManyInput>;
    /**
     * Filter which UserAiBotAccesses to update
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * Limit how many UserAiBotAccesses to update.
     */
    limit?: number;
  };

  /**
   * UserAiBotAccess updateManyAndReturn
   */
  export type UserAiBotAccessUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * The data used to update UserAiBotAccesses.
     */
    data: XOR<UserAiBotAccessUpdateManyMutationInput, UserAiBotAccessUncheckedUpdateManyInput>;
    /**
     * Filter which UserAiBotAccesses to update
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * Limit how many UserAiBotAccesses to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserAiBotAccess upsert
   */
  export type UserAiBotAccessUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserAiBotAccess to update in case it exists.
     */
    where: UserAiBotAccessWhereUniqueInput;
    /**
     * In case the UserAiBotAccess found by the `where` argument doesn't exist, create a new UserAiBotAccess with this data.
     */
    create: XOR<UserAiBotAccessCreateInput, UserAiBotAccessUncheckedCreateInput>;
    /**
     * In case the UserAiBotAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAiBotAccessUpdateInput, UserAiBotAccessUncheckedUpdateInput>;
  };

  /**
   * UserAiBotAccess delete
   */
  export type UserAiBotAccessDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    /**
     * Filter which UserAiBotAccess to delete.
     */
    where: UserAiBotAccessWhereUniqueInput;
  };

  /**
   * UserAiBotAccess deleteMany
   */
  export type UserAiBotAccessDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserAiBotAccesses to delete
     */
    where?: UserAiBotAccessWhereInput;
    /**
     * Limit how many UserAiBotAccesses to delete.
     */
    limit?: number;
  };

  /**
   * UserAiBotAccess.user
   */
  export type UserAiBotAccess$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * UserAiBotAccess without action
   */
  export type UserAiBotAccessDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
  };

  /**
   * Model PaperlessInstance
   */

  export type AggregatePaperlessInstance = {
    _count: PaperlessInstanceCountAggregateOutputType | null;
    _avg: PaperlessInstanceAvgAggregateOutputType | null;
    _sum: PaperlessInstanceSumAggregateOutputType | null;
    _min: PaperlessInstanceMinAggregateOutputType | null;
    _max: PaperlessInstanceMaxAggregateOutputType | null;
  };

  export type PaperlessInstanceAvgAggregateOutputType = {
    importFilterTags: number | null;
  };

  export type PaperlessInstanceSumAggregateOutputType = {
    importFilterTags: number[];
  };

  export type PaperlessInstanceMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    apiUrl: string | null;
    apiToken: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    autoProcessEnabled: boolean | null;
    scanCronExpression: string | null;
    lastScanAt: Date | null;
    nextScanAt: Date | null;
    defaultAiBotId: string | null;
    autoApplyTitle: boolean | null;
    autoApplyCorrespondent: boolean | null;
    autoApplyDocumentType: boolean | null;
    autoApplyTags: boolean | null;
    autoApplyDate: boolean | null;
    ownerId: string | null;
  };

  export type PaperlessInstanceMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    apiUrl: string | null;
    apiToken: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    autoProcessEnabled: boolean | null;
    scanCronExpression: string | null;
    lastScanAt: Date | null;
    nextScanAt: Date | null;
    defaultAiBotId: string | null;
    autoApplyTitle: boolean | null;
    autoApplyCorrespondent: boolean | null;
    autoApplyDocumentType: boolean | null;
    autoApplyTags: boolean | null;
    autoApplyDate: boolean | null;
    ownerId: string | null;
  };

  export type PaperlessInstanceCountAggregateOutputType = {
    id: number;
    name: number;
    apiUrl: number;
    apiToken: number;
    importFilterTags: number;
    createdAt: number;
    updatedAt: number;
    autoProcessEnabled: number;
    scanCronExpression: number;
    lastScanAt: number;
    nextScanAt: number;
    defaultAiBotId: number;
    autoApplyTitle: number;
    autoApplyCorrespondent: number;
    autoApplyDocumentType: number;
    autoApplyTags: number;
    autoApplyDate: number;
    ownerId: number;
    _all: number;
  };

  export type PaperlessInstanceAvgAggregateInputType = {
    importFilterTags?: true;
  };

  export type PaperlessInstanceSumAggregateInputType = {
    importFilterTags?: true;
  };

  export type PaperlessInstanceMinAggregateInputType = {
    id?: true;
    name?: true;
    apiUrl?: true;
    apiToken?: true;
    createdAt?: true;
    updatedAt?: true;
    autoProcessEnabled?: true;
    scanCronExpression?: true;
    lastScanAt?: true;
    nextScanAt?: true;
    defaultAiBotId?: true;
    autoApplyTitle?: true;
    autoApplyCorrespondent?: true;
    autoApplyDocumentType?: true;
    autoApplyTags?: true;
    autoApplyDate?: true;
    ownerId?: true;
  };

  export type PaperlessInstanceMaxAggregateInputType = {
    id?: true;
    name?: true;
    apiUrl?: true;
    apiToken?: true;
    createdAt?: true;
    updatedAt?: true;
    autoProcessEnabled?: true;
    scanCronExpression?: true;
    lastScanAt?: true;
    nextScanAt?: true;
    defaultAiBotId?: true;
    autoApplyTitle?: true;
    autoApplyCorrespondent?: true;
    autoApplyDocumentType?: true;
    autoApplyTags?: true;
    autoApplyDate?: true;
    ownerId?: true;
  };

  export type PaperlessInstanceCountAggregateInputType = {
    id?: true;
    name?: true;
    apiUrl?: true;
    apiToken?: true;
    importFilterTags?: true;
    createdAt?: true;
    updatedAt?: true;
    autoProcessEnabled?: true;
    scanCronExpression?: true;
    lastScanAt?: true;
    nextScanAt?: true;
    defaultAiBotId?: true;
    autoApplyTitle?: true;
    autoApplyCorrespondent?: true;
    autoApplyDocumentType?: true;
    autoApplyTags?: true;
    autoApplyDate?: true;
    ownerId?: true;
    _all?: true;
  };

  export type PaperlessInstanceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PaperlessInstance to aggregate.
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessInstances to fetch.
     */
    orderBy?:
      | PaperlessInstanceOrderByWithRelationInput
      | PaperlessInstanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaperlessInstanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessInstances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessInstances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PaperlessInstances
     **/
    _count?: true | PaperlessInstanceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaperlessInstanceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaperlessInstanceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaperlessInstanceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaperlessInstanceMaxAggregateInputType;
  };

  export type GetPaperlessInstanceAggregateType<T extends PaperlessInstanceAggregateArgs> = {
    [P in keyof T & keyof AggregatePaperlessInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaperlessInstance[P]>
      : GetScalarType<T[P], AggregatePaperlessInstance[P]>;
  };

  export type PaperlessInstanceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaperlessInstanceWhereInput;
    orderBy?:
      | PaperlessInstanceOrderByWithAggregationInput
      | PaperlessInstanceOrderByWithAggregationInput[];
    by: PaperlessInstanceScalarFieldEnum[] | PaperlessInstanceScalarFieldEnum;
    having?: PaperlessInstanceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaperlessInstanceCountAggregateInputType | true;
    _avg?: PaperlessInstanceAvgAggregateInputType;
    _sum?: PaperlessInstanceSumAggregateInputType;
    _min?: PaperlessInstanceMinAggregateInputType;
    _max?: PaperlessInstanceMaxAggregateInputType;
  };

  export type PaperlessInstanceGroupByOutputType = {
    id: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags: number[];
    createdAt: Date;
    updatedAt: Date;
    autoProcessEnabled: boolean;
    scanCronExpression: string;
    lastScanAt: Date | null;
    nextScanAt: Date | null;
    defaultAiBotId: string | null;
    autoApplyTitle: boolean;
    autoApplyCorrespondent: boolean;
    autoApplyDocumentType: boolean;
    autoApplyTags: boolean;
    autoApplyDate: boolean;
    ownerId: string;
    _count: PaperlessInstanceCountAggregateOutputType | null;
    _avg: PaperlessInstanceAvgAggregateOutputType | null;
    _sum: PaperlessInstanceSumAggregateOutputType | null;
    _min: PaperlessInstanceMinAggregateOutputType | null;
    _max: PaperlessInstanceMaxAggregateOutputType | null;
  };

  type GetPaperlessInstanceGroupByPayload<T extends PaperlessInstanceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PaperlessInstanceGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PaperlessInstanceGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaperlessInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], PaperlessInstanceGroupByOutputType[P]>;
        }
      >
    >;

  export type PaperlessInstanceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      apiUrl?: boolean;
      apiToken?: boolean;
      importFilterTags?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      autoProcessEnabled?: boolean;
      scanCronExpression?: boolean;
      lastScanAt?: boolean;
      nextScanAt?: boolean;
      defaultAiBotId?: boolean;
      autoApplyTitle?: boolean;
      autoApplyCorrespondent?: boolean;
      autoApplyDocumentType?: boolean;
      autoApplyTags?: boolean;
      autoApplyDate?: boolean;
      ownerId?: boolean;
      defaultAiBot?: boolean | PaperlessInstance$defaultAiBotArgs<ExtArgs>;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      sharedWith?: boolean | PaperlessInstance$sharedWithArgs<ExtArgs>;
      documents?: boolean | PaperlessInstance$documentsArgs<ExtArgs>;
      processingQueue?: boolean | PaperlessInstance$processingQueueArgs<ExtArgs>;
      importHistory?: boolean | PaperlessInstance$importHistoryArgs<ExtArgs>;
      _count?: boolean | PaperlessInstanceCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paperlessInstance']
  >;

  export type PaperlessInstanceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      apiUrl?: boolean;
      apiToken?: boolean;
      importFilterTags?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      autoProcessEnabled?: boolean;
      scanCronExpression?: boolean;
      lastScanAt?: boolean;
      nextScanAt?: boolean;
      defaultAiBotId?: boolean;
      autoApplyTitle?: boolean;
      autoApplyCorrespondent?: boolean;
      autoApplyDocumentType?: boolean;
      autoApplyTags?: boolean;
      autoApplyDate?: boolean;
      ownerId?: boolean;
      defaultAiBot?: boolean | PaperlessInstance$defaultAiBotArgs<ExtArgs>;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paperlessInstance']
  >;

  export type PaperlessInstanceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      apiUrl?: boolean;
      apiToken?: boolean;
      importFilterTags?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      autoProcessEnabled?: boolean;
      scanCronExpression?: boolean;
      lastScanAt?: boolean;
      nextScanAt?: boolean;
      defaultAiBotId?: boolean;
      autoApplyTitle?: boolean;
      autoApplyCorrespondent?: boolean;
      autoApplyDocumentType?: boolean;
      autoApplyTags?: boolean;
      autoApplyDate?: boolean;
      ownerId?: boolean;
      defaultAiBot?: boolean | PaperlessInstance$defaultAiBotArgs<ExtArgs>;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paperlessInstance']
  >;

  export type PaperlessInstanceSelectScalar = {
    id?: boolean;
    name?: boolean;
    apiUrl?: boolean;
    apiToken?: boolean;
    importFilterTags?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    autoProcessEnabled?: boolean;
    scanCronExpression?: boolean;
    lastScanAt?: boolean;
    nextScanAt?: boolean;
    defaultAiBotId?: boolean;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId?: boolean;
  };

  export type PaperlessInstanceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'apiUrl'
    | 'apiToken'
    | 'importFilterTags'
    | 'createdAt'
    | 'updatedAt'
    | 'autoProcessEnabled'
    | 'scanCronExpression'
    | 'lastScanAt'
    | 'nextScanAt'
    | 'defaultAiBotId'
    | 'autoApplyTitle'
    | 'autoApplyCorrespondent'
    | 'autoApplyDocumentType'
    | 'autoApplyTags'
    | 'autoApplyDate'
    | 'ownerId',
    ExtArgs['result']['paperlessInstance']
  >;
  export type PaperlessInstanceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    defaultAiBot?: boolean | PaperlessInstance$defaultAiBotArgs<ExtArgs>;
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    sharedWith?: boolean | PaperlessInstance$sharedWithArgs<ExtArgs>;
    documents?: boolean | PaperlessInstance$documentsArgs<ExtArgs>;
    processingQueue?: boolean | PaperlessInstance$processingQueueArgs<ExtArgs>;
    importHistory?: boolean | PaperlessInstance$importHistoryArgs<ExtArgs>;
    _count?: boolean | PaperlessInstanceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PaperlessInstanceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    defaultAiBot?: boolean | PaperlessInstance$defaultAiBotArgs<ExtArgs>;
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PaperlessInstanceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    defaultAiBot?: boolean | PaperlessInstance$defaultAiBotArgs<ExtArgs>;
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PaperlessInstancePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PaperlessInstance';
    objects: {
      defaultAiBot: Prisma.$AiBotPayload<ExtArgs> | null;
      owner: Prisma.$UserPayload<ExtArgs>;
      sharedWith: Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>[];
      documents: Prisma.$PaperlessDocumentPayload<ExtArgs>[];
      processingQueue: Prisma.$ProcessingQueuePayload<ExtArgs>[];
      importHistory: Prisma.$ImportHistoryPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        apiUrl: string;
        apiToken: string;
        importFilterTags: number[];
        createdAt: Date;
        updatedAt: Date;
        autoProcessEnabled: boolean;
        scanCronExpression: string;
        lastScanAt: Date | null;
        nextScanAt: Date | null;
        defaultAiBotId: string | null;
        autoApplyTitle: boolean;
        autoApplyCorrespondent: boolean;
        autoApplyDocumentType: boolean;
        autoApplyTags: boolean;
        autoApplyDate: boolean;
        ownerId: string;
      },
      ExtArgs['result']['paperlessInstance']
    >;
    composites: {};
  };

  type PaperlessInstanceGetPayload<
    S extends boolean | null | undefined | PaperlessInstanceDefaultArgs,
  > = $Result.GetResult<Prisma.$PaperlessInstancePayload, S>;

  type PaperlessInstanceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PaperlessInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PaperlessInstanceCountAggregateInputType | true;
  };

  export interface PaperlessInstanceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PaperlessInstance'];
      meta: { name: 'PaperlessInstance' };
    };
    /**
     * Find zero or one PaperlessInstance that matches the filter.
     * @param {PaperlessInstanceFindUniqueArgs} args - Arguments to find a PaperlessInstance
     * @example
     * // Get one PaperlessInstance
     * const paperlessInstance = await prisma.paperlessInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaperlessInstanceFindUniqueArgs>(
      args: SelectSubset<T, PaperlessInstanceFindUniqueArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<
        Prisma.$PaperlessInstancePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PaperlessInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaperlessInstanceFindUniqueOrThrowArgs} args - Arguments to find a PaperlessInstance
     * @example
     * // Get one PaperlessInstance
     * const paperlessInstance = await prisma.paperlessInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaperlessInstanceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaperlessInstanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<
        Prisma.$PaperlessInstancePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaperlessInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceFindFirstArgs} args - Arguments to find a PaperlessInstance
     * @example
     * // Get one PaperlessInstance
     * const paperlessInstance = await prisma.paperlessInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaperlessInstanceFindFirstArgs>(
      args?: SelectSubset<T, PaperlessInstanceFindFirstArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<
        Prisma.$PaperlessInstancePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaperlessInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceFindFirstOrThrowArgs} args - Arguments to find a PaperlessInstance
     * @example
     * // Get one PaperlessInstance
     * const paperlessInstance = await prisma.paperlessInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaperlessInstanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaperlessInstanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<
        Prisma.$PaperlessInstancePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PaperlessInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaperlessInstances
     * const paperlessInstances = await prisma.paperlessInstance.findMany()
     *
     * // Get first 10 PaperlessInstances
     * const paperlessInstances = await prisma.paperlessInstance.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paperlessInstanceWithIdOnly = await prisma.paperlessInstance.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaperlessInstanceFindManyArgs>(
      args?: SelectSubset<T, PaperlessInstanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaperlessInstancePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a PaperlessInstance.
     * @param {PaperlessInstanceCreateArgs} args - Arguments to create a PaperlessInstance.
     * @example
     * // Create one PaperlessInstance
     * const PaperlessInstance = await prisma.paperlessInstance.create({
     *   data: {
     *     // ... data to create a PaperlessInstance
     *   }
     * })
     *
     */
    create<T extends PaperlessInstanceCreateArgs>(
      args: SelectSubset<T, PaperlessInstanceCreateArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<Prisma.$PaperlessInstancePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PaperlessInstances.
     * @param {PaperlessInstanceCreateManyArgs} args - Arguments to create many PaperlessInstances.
     * @example
     * // Create many PaperlessInstances
     * const paperlessInstance = await prisma.paperlessInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaperlessInstanceCreateManyArgs>(
      args?: SelectSubset<T, PaperlessInstanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PaperlessInstances and returns the data saved in the database.
     * @param {PaperlessInstanceCreateManyAndReturnArgs} args - Arguments to create many PaperlessInstances.
     * @example
     * // Create many PaperlessInstances
     * const paperlessInstance = await prisma.paperlessInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PaperlessInstances and only return the `id`
     * const paperlessInstanceWithIdOnly = await prisma.paperlessInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaperlessInstanceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PaperlessInstanceCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaperlessInstancePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a PaperlessInstance.
     * @param {PaperlessInstanceDeleteArgs} args - Arguments to delete one PaperlessInstance.
     * @example
     * // Delete one PaperlessInstance
     * const PaperlessInstance = await prisma.paperlessInstance.delete({
     *   where: {
     *     // ... filter to delete one PaperlessInstance
     *   }
     * })
     *
     */
    delete<T extends PaperlessInstanceDeleteArgs>(
      args: SelectSubset<T, PaperlessInstanceDeleteArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<Prisma.$PaperlessInstancePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PaperlessInstance.
     * @param {PaperlessInstanceUpdateArgs} args - Arguments to update one PaperlessInstance.
     * @example
     * // Update one PaperlessInstance
     * const paperlessInstance = await prisma.paperlessInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaperlessInstanceUpdateArgs>(
      args: SelectSubset<T, PaperlessInstanceUpdateArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<Prisma.$PaperlessInstancePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PaperlessInstances.
     * @param {PaperlessInstanceDeleteManyArgs} args - Arguments to filter PaperlessInstances to delete.
     * @example
     * // Delete a few PaperlessInstances
     * const { count } = await prisma.paperlessInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaperlessInstanceDeleteManyArgs>(
      args?: SelectSubset<T, PaperlessInstanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaperlessInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaperlessInstances
     * const paperlessInstance = await prisma.paperlessInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaperlessInstanceUpdateManyArgs>(
      args: SelectSubset<T, PaperlessInstanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaperlessInstances and returns the data updated in the database.
     * @param {PaperlessInstanceUpdateManyAndReturnArgs} args - Arguments to update many PaperlessInstances.
     * @example
     * // Update many PaperlessInstances
     * const paperlessInstance = await prisma.paperlessInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PaperlessInstances and only return the `id`
     * const paperlessInstanceWithIdOnly = await prisma.paperlessInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PaperlessInstanceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PaperlessInstanceUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaperlessInstancePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one PaperlessInstance.
     * @param {PaperlessInstanceUpsertArgs} args - Arguments to update or create a PaperlessInstance.
     * @example
     * // Update or create a PaperlessInstance
     * const paperlessInstance = await prisma.paperlessInstance.upsert({
     *   create: {
     *     // ... data to create a PaperlessInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaperlessInstance we want to update
     *   }
     * })
     */
    upsert<T extends PaperlessInstanceUpsertArgs>(
      args: SelectSubset<T, PaperlessInstanceUpsertArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      $Result.GetResult<Prisma.$PaperlessInstancePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PaperlessInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceCountArgs} args - Arguments to filter PaperlessInstances to count.
     * @example
     * // Count the number of PaperlessInstances
     * const count = await prisma.paperlessInstance.count({
     *   where: {
     *     // ... the filter for the PaperlessInstances we want to count
     *   }
     * })
     **/
    count<T extends PaperlessInstanceCountArgs>(
      args?: Subset<T, PaperlessInstanceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaperlessInstanceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PaperlessInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaperlessInstanceAggregateArgs>(
      args: Subset<T, PaperlessInstanceAggregateArgs>
    ): Prisma.PrismaPromise<GetPaperlessInstanceAggregateType<T>>;

    /**
     * Group by PaperlessInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaperlessInstanceGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaperlessInstanceGroupByArgs['orderBy'] }
        : { orderBy?: PaperlessInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaperlessInstanceGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPaperlessInstanceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PaperlessInstance model
     */
    readonly fields: PaperlessInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaperlessInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaperlessInstanceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    defaultAiBot<T extends PaperlessInstance$defaultAiBotArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstance$defaultAiBotArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<
        Prisma.$AiBotPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    sharedWith<T extends PaperlessInstance$sharedWithArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstance$sharedWithArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserPaperlessInstanceAccessPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    documents<T extends PaperlessInstance$documentsArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstance$documentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaperlessDocumentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    processingQueue<T extends PaperlessInstance$processingQueueArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstance$processingQueueArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    importHistory<T extends PaperlessInstance$importHistoryArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstance$importHistoryArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PaperlessInstance model
   */
  interface PaperlessInstanceFieldRefs {
    readonly id: FieldRef<'PaperlessInstance', 'String'>;
    readonly name: FieldRef<'PaperlessInstance', 'String'>;
    readonly apiUrl: FieldRef<'PaperlessInstance', 'String'>;
    readonly apiToken: FieldRef<'PaperlessInstance', 'String'>;
    readonly importFilterTags: FieldRef<'PaperlessInstance', 'Int[]'>;
    readonly createdAt: FieldRef<'PaperlessInstance', 'DateTime'>;
    readonly updatedAt: FieldRef<'PaperlessInstance', 'DateTime'>;
    readonly autoProcessEnabled: FieldRef<'PaperlessInstance', 'Boolean'>;
    readonly scanCronExpression: FieldRef<'PaperlessInstance', 'String'>;
    readonly lastScanAt: FieldRef<'PaperlessInstance', 'DateTime'>;
    readonly nextScanAt: FieldRef<'PaperlessInstance', 'DateTime'>;
    readonly defaultAiBotId: FieldRef<'PaperlessInstance', 'String'>;
    readonly autoApplyTitle: FieldRef<'PaperlessInstance', 'Boolean'>;
    readonly autoApplyCorrespondent: FieldRef<'PaperlessInstance', 'Boolean'>;
    readonly autoApplyDocumentType: FieldRef<'PaperlessInstance', 'Boolean'>;
    readonly autoApplyTags: FieldRef<'PaperlessInstance', 'Boolean'>;
    readonly autoApplyDate: FieldRef<'PaperlessInstance', 'Boolean'>;
    readonly ownerId: FieldRef<'PaperlessInstance', 'String'>;
  }

  // Custom InputTypes
  /**
   * PaperlessInstance findUnique
   */
  export type PaperlessInstanceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessInstance to fetch.
     */
    where: PaperlessInstanceWhereUniqueInput;
  };

  /**
   * PaperlessInstance findUniqueOrThrow
   */
  export type PaperlessInstanceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessInstance to fetch.
     */
    where: PaperlessInstanceWhereUniqueInput;
  };

  /**
   * PaperlessInstance findFirst
   */
  export type PaperlessInstanceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessInstance to fetch.
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessInstances to fetch.
     */
    orderBy?:
      | PaperlessInstanceOrderByWithRelationInput
      | PaperlessInstanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaperlessInstances.
     */
    cursor?: PaperlessInstanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessInstances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessInstances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaperlessInstances.
     */
    distinct?: PaperlessInstanceScalarFieldEnum | PaperlessInstanceScalarFieldEnum[];
  };

  /**
   * PaperlessInstance findFirstOrThrow
   */
  export type PaperlessInstanceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessInstance to fetch.
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessInstances to fetch.
     */
    orderBy?:
      | PaperlessInstanceOrderByWithRelationInput
      | PaperlessInstanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaperlessInstances.
     */
    cursor?: PaperlessInstanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessInstances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessInstances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaperlessInstances.
     */
    distinct?: PaperlessInstanceScalarFieldEnum | PaperlessInstanceScalarFieldEnum[];
  };

  /**
   * PaperlessInstance findMany
   */
  export type PaperlessInstanceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessInstances to fetch.
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessInstances to fetch.
     */
    orderBy?:
      | PaperlessInstanceOrderByWithRelationInput
      | PaperlessInstanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PaperlessInstances.
     */
    cursor?: PaperlessInstanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessInstances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessInstances.
     */
    skip?: number;
    distinct?: PaperlessInstanceScalarFieldEnum | PaperlessInstanceScalarFieldEnum[];
  };

  /**
   * PaperlessInstance create
   */
  export type PaperlessInstanceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * The data needed to create a PaperlessInstance.
     */
    data: XOR<PaperlessInstanceCreateInput, PaperlessInstanceUncheckedCreateInput>;
  };

  /**
   * PaperlessInstance createMany
   */
  export type PaperlessInstanceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PaperlessInstances.
     */
    data: PaperlessInstanceCreateManyInput | PaperlessInstanceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PaperlessInstance createManyAndReturn
   */
  export type PaperlessInstanceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * The data used to create many PaperlessInstances.
     */
    data: PaperlessInstanceCreateManyInput | PaperlessInstanceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PaperlessInstance update
   */
  export type PaperlessInstanceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * The data needed to update a PaperlessInstance.
     */
    data: XOR<PaperlessInstanceUpdateInput, PaperlessInstanceUncheckedUpdateInput>;
    /**
     * Choose, which PaperlessInstance to update.
     */
    where: PaperlessInstanceWhereUniqueInput;
  };

  /**
   * PaperlessInstance updateMany
   */
  export type PaperlessInstanceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PaperlessInstances.
     */
    data: XOR<PaperlessInstanceUpdateManyMutationInput, PaperlessInstanceUncheckedUpdateManyInput>;
    /**
     * Filter which PaperlessInstances to update
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * Limit how many PaperlessInstances to update.
     */
    limit?: number;
  };

  /**
   * PaperlessInstance updateManyAndReturn
   */
  export type PaperlessInstanceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * The data used to update PaperlessInstances.
     */
    data: XOR<PaperlessInstanceUpdateManyMutationInput, PaperlessInstanceUncheckedUpdateManyInput>;
    /**
     * Filter which PaperlessInstances to update
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * Limit how many PaperlessInstances to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PaperlessInstance upsert
   */
  export type PaperlessInstanceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * The filter to search for the PaperlessInstance to update in case it exists.
     */
    where: PaperlessInstanceWhereUniqueInput;
    /**
     * In case the PaperlessInstance found by the `where` argument doesn't exist, create a new PaperlessInstance with this data.
     */
    create: XOR<PaperlessInstanceCreateInput, PaperlessInstanceUncheckedCreateInput>;
    /**
     * In case the PaperlessInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaperlessInstanceUpdateInput, PaperlessInstanceUncheckedUpdateInput>;
  };

  /**
   * PaperlessInstance delete
   */
  export type PaperlessInstanceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    /**
     * Filter which PaperlessInstance to delete.
     */
    where: PaperlessInstanceWhereUniqueInput;
  };

  /**
   * PaperlessInstance deleteMany
   */
  export type PaperlessInstanceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PaperlessInstances to delete
     */
    where?: PaperlessInstanceWhereInput;
    /**
     * Limit how many PaperlessInstances to delete.
     */
    limit?: number;
  };

  /**
   * PaperlessInstance.defaultAiBot
   */
  export type PaperlessInstance$defaultAiBotArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    where?: AiBotWhereInput;
  };

  /**
   * PaperlessInstance.sharedWith
   */
  export type PaperlessInstance$sharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserPaperlessInstanceAccess
     */
    select?: UserPaperlessInstanceAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserPaperlessInstanceAccess
     */
    omit?: UserPaperlessInstanceAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPaperlessInstanceAccessInclude<ExtArgs> | null;
    where?: UserPaperlessInstanceAccessWhereInput;
    orderBy?:
      | UserPaperlessInstanceAccessOrderByWithRelationInput
      | UserPaperlessInstanceAccessOrderByWithRelationInput[];
    cursor?: UserPaperlessInstanceAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | UserPaperlessInstanceAccessScalarFieldEnum
      | UserPaperlessInstanceAccessScalarFieldEnum[];
  };

  /**
   * PaperlessInstance.documents
   */
  export type PaperlessInstance$documentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    where?: PaperlessDocumentWhereInput;
    orderBy?:
      | PaperlessDocumentOrderByWithRelationInput
      | PaperlessDocumentOrderByWithRelationInput[];
    cursor?: PaperlessDocumentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaperlessDocumentScalarFieldEnum | PaperlessDocumentScalarFieldEnum[];
  };

  /**
   * PaperlessInstance.processingQueue
   */
  export type PaperlessInstance$processingQueueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    where?: ProcessingQueueWhereInput;
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    cursor?: ProcessingQueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProcessingQueueScalarFieldEnum | ProcessingQueueScalarFieldEnum[];
  };

  /**
   * PaperlessInstance.importHistory
   */
  export type PaperlessInstance$importHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    where?: ImportHistoryWhereInput;
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[];
    cursor?: ImportHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[];
  };

  /**
   * PaperlessInstance without action
   */
  export type PaperlessInstanceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
  };

  /**
   * Model AiAccount
   */

  export type AggregateAiAccount = {
    _count: AiAccountCountAggregateOutputType | null;
    _min: AiAccountMinAggregateOutputType | null;
    _max: AiAccountMaxAggregateOutputType | null;
  };

  export type AiAccountMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    provider: string | null;
    apiKey: string | null;
    baseUrl: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ownerId: string | null;
  };

  export type AiAccountMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    provider: string | null;
    apiKey: string | null;
    baseUrl: string | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ownerId: string | null;
  };

  export type AiAccountCountAggregateOutputType = {
    id: number;
    name: number;
    provider: number;
    apiKey: number;
    baseUrl: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    ownerId: number;
    _all: number;
  };

  export type AiAccountMinAggregateInputType = {
    id?: true;
    name?: true;
    provider?: true;
    apiKey?: true;
    baseUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
  };

  export type AiAccountMaxAggregateInputType = {
    id?: true;
    name?: true;
    provider?: true;
    apiKey?: true;
    baseUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
  };

  export type AiAccountCountAggregateInputType = {
    id?: true;
    name?: true;
    provider?: true;
    apiKey?: true;
    baseUrl?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    _all?: true;
  };

  export type AiAccountAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiAccount to aggregate.
     */
    where?: AiAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiAccounts to fetch.
     */
    orderBy?: AiAccountOrderByWithRelationInput | AiAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AiAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiAccounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AiAccounts
     **/
    _count?: true | AiAccountCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AiAccountMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AiAccountMaxAggregateInputType;
  };

  export type GetAiAccountAggregateType<T extends AiAccountAggregateArgs> = {
    [P in keyof T & keyof AggregateAiAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiAccount[P]>
      : GetScalarType<T[P], AggregateAiAccount[P]>;
  };

  export type AiAccountGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiAccountWhereInput;
    orderBy?: AiAccountOrderByWithAggregationInput | AiAccountOrderByWithAggregationInput[];
    by: AiAccountScalarFieldEnum[] | AiAccountScalarFieldEnum;
    having?: AiAccountScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AiAccountCountAggregateInputType | true;
    _min?: AiAccountMinAggregateInputType;
    _max?: AiAccountMaxAggregateInputType;
  };

  export type AiAccountGroupByOutputType = {
    id: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl: string | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    ownerId: string;
    _count: AiAccountCountAggregateOutputType | null;
    _min: AiAccountMinAggregateOutputType | null;
    _max: AiAccountMaxAggregateOutputType | null;
  };

  type GetAiAccountGroupByPayload<T extends AiAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiAccountGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AiAccountGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AiAccountGroupByOutputType[P]>
          : GetScalarType<T[P], AiAccountGroupByOutputType[P]>;
      }
    >
  >;

  export type AiAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        provider?: boolean;
        apiKey?: boolean;
        baseUrl?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        ownerId?: boolean;
        owner?: boolean | UserDefaultArgs<ExtArgs>;
        sharedWith?: boolean | AiAccount$sharedWithArgs<ExtArgs>;
        models?: boolean | AiAccount$modelsArgs<ExtArgs>;
        aiUsageMetrics?: boolean | AiAccount$aiUsageMetricsArgs<ExtArgs>;
        _count?: boolean | AiAccountCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['aiAccount']
    >;

  export type AiAccountSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      provider?: boolean;
      apiKey?: boolean;
      baseUrl?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ownerId?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['aiAccount']
  >;

  export type AiAccountSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      provider?: boolean;
      apiKey?: boolean;
      baseUrl?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ownerId?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['aiAccount']
  >;

  export type AiAccountSelectScalar = {
    id?: boolean;
    name?: boolean;
    provider?: boolean;
    apiKey?: boolean;
    baseUrl?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ownerId?: boolean;
  };

  export type AiAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'provider'
      | 'apiKey'
      | 'baseUrl'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt'
      | 'ownerId',
      ExtArgs['result']['aiAccount']
    >;
  export type AiAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      sharedWith?: boolean | AiAccount$sharedWithArgs<ExtArgs>;
      models?: boolean | AiAccount$modelsArgs<ExtArgs>;
      aiUsageMetrics?: boolean | AiAccount$aiUsageMetricsArgs<ExtArgs>;
      _count?: boolean | AiAccountCountOutputTypeDefaultArgs<ExtArgs>;
    };
  export type AiAccountIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AiAccountIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AiAccountPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AiAccount';
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>;
      sharedWith: Prisma.$UserAiAccountAccessPayload<ExtArgs>[];
      models: Prisma.$AiModelPayload<ExtArgs>[];
      aiUsageMetrics: Prisma.$AiUsageMetricPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        provider: string;
        apiKey: string;
        baseUrl: string | null;
        isActive: boolean;
        createdAt: Date;
        updatedAt: Date;
        ownerId: string;
      },
      ExtArgs['result']['aiAccount']
    >;
    composites: {};
  };

  type AiAccountGetPayload<S extends boolean | null | undefined | AiAccountDefaultArgs> =
    $Result.GetResult<Prisma.$AiAccountPayload, S>;

  type AiAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiAccountCountAggregateInputType | true;
    };

  export interface AiAccountDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AiAccount'];
      meta: { name: 'AiAccount' };
    };
    /**
     * Find zero or one AiAccount that matches the filter.
     * @param {AiAccountFindUniqueArgs} args - Arguments to find a AiAccount
     * @example
     * // Get one AiAccount
     * const aiAccount = await prisma.aiAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiAccountFindUniqueArgs>(
      args: SelectSubset<T, AiAccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<
        Prisma.$AiAccountPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AiAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiAccountFindUniqueOrThrowArgs} args - Arguments to find a AiAccount
     * @example
     * // Get one AiAccount
     * const aiAccount = await prisma.aiAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiAccountFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AiAccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<
        Prisma.$AiAccountPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountFindFirstArgs} args - Arguments to find a AiAccount
     * @example
     * // Get one AiAccount
     * const aiAccount = await prisma.aiAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiAccountFindFirstArgs>(
      args?: SelectSubset<T, AiAccountFindFirstArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<
        Prisma.$AiAccountPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountFindFirstOrThrowArgs} args - Arguments to find a AiAccount
     * @example
     * // Get one AiAccount
     * const aiAccount = await prisma.aiAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiAccountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AiAccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<
        Prisma.$AiAccountPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AiAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiAccounts
     * const aiAccounts = await prisma.aiAccount.findMany()
     *
     * // Get first 10 AiAccounts
     * const aiAccounts = await prisma.aiAccount.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const aiAccountWithIdOnly = await prisma.aiAccount.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AiAccountFindManyArgs>(
      args?: SelectSubset<T, AiAccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiAccountPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a AiAccount.
     * @param {AiAccountCreateArgs} args - Arguments to create a AiAccount.
     * @example
     * // Create one AiAccount
     * const AiAccount = await prisma.aiAccount.create({
     *   data: {
     *     // ... data to create a AiAccount
     *   }
     * })
     *
     */
    create<T extends AiAccountCreateArgs>(
      args: SelectSubset<T, AiAccountCreateArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<Prisma.$AiAccountPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AiAccounts.
     * @param {AiAccountCreateManyArgs} args - Arguments to create many AiAccounts.
     * @example
     * // Create many AiAccounts
     * const aiAccount = await prisma.aiAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AiAccountCreateManyArgs>(
      args?: SelectSubset<T, AiAccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AiAccounts and returns the data saved in the database.
     * @param {AiAccountCreateManyAndReturnArgs} args - Arguments to create many AiAccounts.
     * @example
     * // Create many AiAccounts
     * const aiAccount = await prisma.aiAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AiAccounts and only return the `id`
     * const aiAccountWithIdOnly = await prisma.aiAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AiAccountCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AiAccountCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AiAccountPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AiAccount.
     * @param {AiAccountDeleteArgs} args - Arguments to delete one AiAccount.
     * @example
     * // Delete one AiAccount
     * const AiAccount = await prisma.aiAccount.delete({
     *   where: {
     *     // ... filter to delete one AiAccount
     *   }
     * })
     *
     */
    delete<T extends AiAccountDeleteArgs>(
      args: SelectSubset<T, AiAccountDeleteArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<Prisma.$AiAccountPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AiAccount.
     * @param {AiAccountUpdateArgs} args - Arguments to update one AiAccount.
     * @example
     * // Update one AiAccount
     * const aiAccount = await prisma.aiAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AiAccountUpdateArgs>(
      args: SelectSubset<T, AiAccountUpdateArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<Prisma.$AiAccountPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AiAccounts.
     * @param {AiAccountDeleteManyArgs} args - Arguments to filter AiAccounts to delete.
     * @example
     * // Delete a few AiAccounts
     * const { count } = await prisma.aiAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AiAccountDeleteManyArgs>(
      args?: SelectSubset<T, AiAccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiAccounts
     * const aiAccount = await prisma.aiAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AiAccountUpdateManyArgs>(
      args: SelectSubset<T, AiAccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiAccounts and returns the data updated in the database.
     * @param {AiAccountUpdateManyAndReturnArgs} args - Arguments to update many AiAccounts.
     * @example
     * // Update many AiAccounts
     * const aiAccount = await prisma.aiAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AiAccounts and only return the `id`
     * const aiAccountWithIdOnly = await prisma.aiAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AiAccountUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AiAccountUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AiAccountPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AiAccount.
     * @param {AiAccountUpsertArgs} args - Arguments to update or create a AiAccount.
     * @example
     * // Update or create a AiAccount
     * const aiAccount = await prisma.aiAccount.upsert({
     *   create: {
     *     // ... data to create a AiAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiAccount we want to update
     *   }
     * })
     */
    upsert<T extends AiAccountUpsertArgs>(
      args: SelectSubset<T, AiAccountUpsertArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      $Result.GetResult<Prisma.$AiAccountPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AiAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountCountArgs} args - Arguments to filter AiAccounts to count.
     * @example
     * // Count the number of AiAccounts
     * const count = await prisma.aiAccount.count({
     *   where: {
     *     // ... the filter for the AiAccounts we want to count
     *   }
     * })
     **/
    count<T extends AiAccountCountArgs>(
      args?: Subset<T, AiAccountCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiAccountCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AiAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AiAccountAggregateArgs>(
      args: Subset<T, AiAccountAggregateArgs>
    ): Prisma.PrismaPromise<GetAiAccountAggregateType<T>>;

    /**
     * Group by AiAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AiAccountGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiAccountGroupByArgs['orderBy'] }
        : { orderBy?: AiAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AiAccountGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAiAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AiAccount model
     */
    readonly fields: AiAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiAccountClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    sharedWith<T extends AiAccount$sharedWithArgs<ExtArgs> = {}>(
      args?: Subset<T, AiAccount$sharedWithArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserAiAccountAccessPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    models<T extends AiAccount$modelsArgs<ExtArgs> = {}>(
      args?: Subset<T, AiAccount$modelsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    aiUsageMetrics<T extends AiAccount$aiUsageMetricsArgs<ExtArgs> = {}>(
      args?: Subset<T, AiAccount$aiUsageMetricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AiAccount model
   */
  interface AiAccountFieldRefs {
    readonly id: FieldRef<'AiAccount', 'String'>;
    readonly name: FieldRef<'AiAccount', 'String'>;
    readonly provider: FieldRef<'AiAccount', 'String'>;
    readonly apiKey: FieldRef<'AiAccount', 'String'>;
    readonly baseUrl: FieldRef<'AiAccount', 'String'>;
    readonly isActive: FieldRef<'AiAccount', 'Boolean'>;
    readonly createdAt: FieldRef<'AiAccount', 'DateTime'>;
    readonly updatedAt: FieldRef<'AiAccount', 'DateTime'>;
    readonly ownerId: FieldRef<'AiAccount', 'String'>;
  }

  // Custom InputTypes
  /**
   * AiAccount findUnique
   */
  export type AiAccountFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * Filter, which AiAccount to fetch.
     */
    where: AiAccountWhereUniqueInput;
  };

  /**
   * AiAccount findUniqueOrThrow
   */
  export type AiAccountFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * Filter, which AiAccount to fetch.
     */
    where: AiAccountWhereUniqueInput;
  };

  /**
   * AiAccount findFirst
   */
  export type AiAccountFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * Filter, which AiAccount to fetch.
     */
    where?: AiAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiAccounts to fetch.
     */
    orderBy?: AiAccountOrderByWithRelationInput | AiAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiAccounts.
     */
    cursor?: AiAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiAccounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiAccounts.
     */
    distinct?: AiAccountScalarFieldEnum | AiAccountScalarFieldEnum[];
  };

  /**
   * AiAccount findFirstOrThrow
   */
  export type AiAccountFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * Filter, which AiAccount to fetch.
     */
    where?: AiAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiAccounts to fetch.
     */
    orderBy?: AiAccountOrderByWithRelationInput | AiAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiAccounts.
     */
    cursor?: AiAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiAccounts.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiAccounts.
     */
    distinct?: AiAccountScalarFieldEnum | AiAccountScalarFieldEnum[];
  };

  /**
   * AiAccount findMany
   */
  export type AiAccountFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * Filter, which AiAccounts to fetch.
     */
    where?: AiAccountWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiAccounts to fetch.
     */
    orderBy?: AiAccountOrderByWithRelationInput | AiAccountOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AiAccounts.
     */
    cursor?: AiAccountWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiAccounts from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiAccounts.
     */
    skip?: number;
    distinct?: AiAccountScalarFieldEnum | AiAccountScalarFieldEnum[];
  };

  /**
   * AiAccount create
   */
  export type AiAccountCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * The data needed to create a AiAccount.
     */
    data: XOR<AiAccountCreateInput, AiAccountUncheckedCreateInput>;
  };

  /**
   * AiAccount createMany
   */
  export type AiAccountCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AiAccounts.
     */
    data: AiAccountCreateManyInput | AiAccountCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AiAccount createManyAndReturn
   */
  export type AiAccountCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * The data used to create many AiAccounts.
     */
    data: AiAccountCreateManyInput | AiAccountCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiAccount update
   */
  export type AiAccountUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * The data needed to update a AiAccount.
     */
    data: XOR<AiAccountUpdateInput, AiAccountUncheckedUpdateInput>;
    /**
     * Choose, which AiAccount to update.
     */
    where: AiAccountWhereUniqueInput;
  };

  /**
   * AiAccount updateMany
   */
  export type AiAccountUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AiAccounts.
     */
    data: XOR<AiAccountUpdateManyMutationInput, AiAccountUncheckedUpdateManyInput>;
    /**
     * Filter which AiAccounts to update
     */
    where?: AiAccountWhereInput;
    /**
     * Limit how many AiAccounts to update.
     */
    limit?: number;
  };

  /**
   * AiAccount updateManyAndReturn
   */
  export type AiAccountUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * The data used to update AiAccounts.
     */
    data: XOR<AiAccountUpdateManyMutationInput, AiAccountUncheckedUpdateManyInput>;
    /**
     * Filter which AiAccounts to update
     */
    where?: AiAccountWhereInput;
    /**
     * Limit how many AiAccounts to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiAccount upsert
   */
  export type AiAccountUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * The filter to search for the AiAccount to update in case it exists.
     */
    where: AiAccountWhereUniqueInput;
    /**
     * In case the AiAccount found by the `where` argument doesn't exist, create a new AiAccount with this data.
     */
    create: XOR<AiAccountCreateInput, AiAccountUncheckedCreateInput>;
    /**
     * In case the AiAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiAccountUpdateInput, AiAccountUncheckedUpdateInput>;
  };

  /**
   * AiAccount delete
   */
  export type AiAccountDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
    /**
     * Filter which AiAccount to delete.
     */
    where: AiAccountWhereUniqueInput;
  };

  /**
   * AiAccount deleteMany
   */
  export type AiAccountDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiAccounts to delete
     */
    where?: AiAccountWhereInput;
    /**
     * Limit how many AiAccounts to delete.
     */
    limit?: number;
  };

  /**
   * AiAccount.sharedWith
   */
  export type AiAccount$sharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiAccountAccess
     */
    select?: UserAiAccountAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiAccountAccess
     */
    omit?: UserAiAccountAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiAccountAccessInclude<ExtArgs> | null;
    where?: UserAiAccountAccessWhereInput;
    orderBy?:
      | UserAiAccountAccessOrderByWithRelationInput
      | UserAiAccountAccessOrderByWithRelationInput[];
    cursor?: UserAiAccountAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserAiAccountAccessScalarFieldEnum | UserAiAccountAccessScalarFieldEnum[];
  };

  /**
   * AiAccount.models
   */
  export type AiAccount$modelsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    where?: AiModelWhereInput;
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[];
    cursor?: AiModelWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[];
  };

  /**
   * AiAccount.aiUsageMetrics
   */
  export type AiAccount$aiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    where?: AiUsageMetricWhereInput;
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    cursor?: AiUsageMetricWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * AiAccount without action
   */
  export type AiAccountDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiAccount
     */
    select?: AiAccountSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiAccount
     */
    omit?: AiAccountOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiAccountInclude<ExtArgs> | null;
  };

  /**
   * Model AiModel
   */

  export type AggregateAiModel = {
    _count: AiModelCountAggregateOutputType | null;
    _avg: AiModelAvgAggregateOutputType | null;
    _sum: AiModelSumAggregateOutputType | null;
    _min: AiModelMinAggregateOutputType | null;
    _max: AiModelMaxAggregateOutputType | null;
  };

  export type AiModelAvgAggregateOutputType = {
    inputTokenPrice: number | null;
    outputTokenPrice: number | null;
  };

  export type AiModelSumAggregateOutputType = {
    inputTokenPrice: number | null;
    outputTokenPrice: number | null;
  };

  export type AiModelMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    modelIdentifier: string | null;
    inputTokenPrice: number | null;
    outputTokenPrice: number | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ownerId: string | null;
    aiAccountId: string | null;
  };

  export type AiModelMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    modelIdentifier: string | null;
    inputTokenPrice: number | null;
    outputTokenPrice: number | null;
    isActive: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ownerId: string | null;
    aiAccountId: string | null;
  };

  export type AiModelCountAggregateOutputType = {
    id: number;
    name: number;
    modelIdentifier: number;
    inputTokenPrice: number;
    outputTokenPrice: number;
    isActive: number;
    createdAt: number;
    updatedAt: number;
    ownerId: number;
    aiAccountId: number;
    _all: number;
  };

  export type AiModelAvgAggregateInputType = {
    inputTokenPrice?: true;
    outputTokenPrice?: true;
  };

  export type AiModelSumAggregateInputType = {
    inputTokenPrice?: true;
    outputTokenPrice?: true;
  };

  export type AiModelMinAggregateInputType = {
    id?: true;
    name?: true;
    modelIdentifier?: true;
    inputTokenPrice?: true;
    outputTokenPrice?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    aiAccountId?: true;
  };

  export type AiModelMaxAggregateInputType = {
    id?: true;
    name?: true;
    modelIdentifier?: true;
    inputTokenPrice?: true;
    outputTokenPrice?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    aiAccountId?: true;
  };

  export type AiModelCountAggregateInputType = {
    id?: true;
    name?: true;
    modelIdentifier?: true;
    inputTokenPrice?: true;
    outputTokenPrice?: true;
    isActive?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    aiAccountId?: true;
    _all?: true;
  };

  export type AiModelAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiModel to aggregate.
     */
    where?: AiModelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AiModelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiModels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AiModels
     **/
    _count?: true | AiModelCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AiModelAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AiModelSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AiModelMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AiModelMaxAggregateInputType;
  };

  export type GetAiModelAggregateType<T extends AiModelAggregateArgs> = {
    [P in keyof T & keyof AggregateAiModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiModel[P]>
      : GetScalarType<T[P], AggregateAiModel[P]>;
  };

  export type AiModelGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiModelWhereInput;
    orderBy?: AiModelOrderByWithAggregationInput | AiModelOrderByWithAggregationInput[];
    by: AiModelScalarFieldEnum[] | AiModelScalarFieldEnum;
    having?: AiModelScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AiModelCountAggregateInputType | true;
    _avg?: AiModelAvgAggregateInputType;
    _sum?: AiModelSumAggregateInputType;
    _min?: AiModelMinAggregateInputType;
    _max?: AiModelMaxAggregateInputType;
  };

  export type AiModelGroupByOutputType = {
    id: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice: number | null;
    outputTokenPrice: number | null;
    isActive: boolean;
    createdAt: Date;
    updatedAt: Date;
    ownerId: string;
    aiAccountId: string;
    _count: AiModelCountAggregateOutputType | null;
    _avg: AiModelAvgAggregateOutputType | null;
    _sum: AiModelSumAggregateOutputType | null;
    _min: AiModelMinAggregateOutputType | null;
    _max: AiModelMaxAggregateOutputType | null;
  };

  type GetAiModelGroupByPayload<T extends AiModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiModelGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AiModelGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AiModelGroupByOutputType[P]>
          : GetScalarType<T[P], AiModelGroupByOutputType[P]>;
      }
    >
  >;

  export type AiModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        modelIdentifier?: boolean;
        inputTokenPrice?: boolean;
        outputTokenPrice?: boolean;
        isActive?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        ownerId?: boolean;
        aiAccountId?: boolean;
        owner?: boolean | UserDefaultArgs<ExtArgs>;
        aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
        sharedWith?: boolean | AiModel$sharedWithArgs<ExtArgs>;
        bots?: boolean | AiModel$botsArgs<ExtArgs>;
        aiUsageMetrics?: boolean | AiModel$aiUsageMetricsArgs<ExtArgs>;
        _count?: boolean | AiModelCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['aiModel']
    >;

  export type AiModelSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      modelIdentifier?: boolean;
      inputTokenPrice?: boolean;
      outputTokenPrice?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ownerId?: boolean;
      aiAccountId?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['aiModel']
  >;

  export type AiModelSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      modelIdentifier?: boolean;
      inputTokenPrice?: boolean;
      outputTokenPrice?: boolean;
      isActive?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ownerId?: boolean;
      aiAccountId?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['aiModel']
  >;

  export type AiModelSelectScalar = {
    id?: boolean;
    name?: boolean;
    modelIdentifier?: boolean;
    inputTokenPrice?: boolean;
    outputTokenPrice?: boolean;
    isActive?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ownerId?: boolean;
    aiAccountId?: boolean;
  };

  export type AiModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'modelIdentifier'
      | 'inputTokenPrice'
      | 'outputTokenPrice'
      | 'isActive'
      | 'createdAt'
      | 'updatedAt'
      | 'ownerId'
      | 'aiAccountId',
      ExtArgs['result']['aiModel']
    >;
  export type AiModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    sharedWith?: boolean | AiModel$sharedWithArgs<ExtArgs>;
    bots?: boolean | AiModel$botsArgs<ExtArgs>;
    aiUsageMetrics?: boolean | AiModel$aiUsageMetricsArgs<ExtArgs>;
    _count?: boolean | AiModelCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AiModelIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
  };
  export type AiModelIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
  };

  export type $AiModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      name: 'AiModel';
      objects: {
        owner: Prisma.$UserPayload<ExtArgs>;
        aiAccount: Prisma.$AiAccountPayload<ExtArgs>;
        sharedWith: Prisma.$UserAiModelAccessPayload<ExtArgs>[];
        bots: Prisma.$AiBotPayload<ExtArgs>[];
        aiUsageMetrics: Prisma.$AiUsageMetricPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
        {
          id: string;
          name: string;
          modelIdentifier: string;
          inputTokenPrice: number | null;
          outputTokenPrice: number | null;
          isActive: boolean;
          createdAt: Date;
          updatedAt: Date;
          ownerId: string;
          aiAccountId: string;
        },
        ExtArgs['result']['aiModel']
      >;
      composites: {};
    };

  type AiModelGetPayload<S extends boolean | null | undefined | AiModelDefaultArgs> =
    $Result.GetResult<Prisma.$AiModelPayload, S>;

  type AiModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AiModelFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AiModelCountAggregateInputType | true;
  };

  export interface AiModelDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiModel']; meta: { name: 'AiModel' } };
    /**
     * Find zero or one AiModel that matches the filter.
     * @param {AiModelFindUniqueArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiModelFindUniqueArgs>(
      args: SelectSubset<T, AiModelFindUniqueArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AiModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiModelFindUniqueOrThrowArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiModelFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AiModelFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelFindFirstArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiModelFindFirstArgs>(
      args?: SelectSubset<T, AiModelFindFirstArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelFindFirstOrThrowArgs} args - Arguments to find a AiModel
     * @example
     * // Get one AiModel
     * const aiModel = await prisma.aiModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiModelFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AiModelFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AiModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiModels
     * const aiModels = await prisma.aiModel.findMany()
     *
     * // Get first 10 AiModels
     * const aiModels = await prisma.aiModel.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const aiModelWithIdOnly = await prisma.aiModel.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AiModelFindManyArgs>(
      args?: SelectSubset<T, AiModelFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a AiModel.
     * @param {AiModelCreateArgs} args - Arguments to create a AiModel.
     * @example
     * // Create one AiModel
     * const AiModel = await prisma.aiModel.create({
     *   data: {
     *     // ... data to create a AiModel
     *   }
     * })
     *
     */
    create<T extends AiModelCreateArgs>(
      args: SelectSubset<T, AiModelCreateArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AiModels.
     * @param {AiModelCreateManyArgs} args - Arguments to create many AiModels.
     * @example
     * // Create many AiModels
     * const aiModel = await prisma.aiModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AiModelCreateManyArgs>(
      args?: SelectSubset<T, AiModelCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AiModels and returns the data saved in the database.
     * @param {AiModelCreateManyAndReturnArgs} args - Arguments to create many AiModels.
     * @example
     * // Create many AiModels
     * const aiModel = await prisma.aiModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AiModels and only return the `id`
     * const aiModelWithIdOnly = await prisma.aiModel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AiModelCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AiModelCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AiModelPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AiModel.
     * @param {AiModelDeleteArgs} args - Arguments to delete one AiModel.
     * @example
     * // Delete one AiModel
     * const AiModel = await prisma.aiModel.delete({
     *   where: {
     *     // ... filter to delete one AiModel
     *   }
     * })
     *
     */
    delete<T extends AiModelDeleteArgs>(
      args: SelectSubset<T, AiModelDeleteArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AiModel.
     * @param {AiModelUpdateArgs} args - Arguments to update one AiModel.
     * @example
     * // Update one AiModel
     * const aiModel = await prisma.aiModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AiModelUpdateArgs>(
      args: SelectSubset<T, AiModelUpdateArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AiModels.
     * @param {AiModelDeleteManyArgs} args - Arguments to filter AiModels to delete.
     * @example
     * // Delete a few AiModels
     * const { count } = await prisma.aiModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AiModelDeleteManyArgs>(
      args?: SelectSubset<T, AiModelDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiModels
     * const aiModel = await prisma.aiModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AiModelUpdateManyArgs>(
      args: SelectSubset<T, AiModelUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiModels and returns the data updated in the database.
     * @param {AiModelUpdateManyAndReturnArgs} args - Arguments to update many AiModels.
     * @example
     * // Update many AiModels
     * const aiModel = await prisma.aiModel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AiModels and only return the `id`
     * const aiModelWithIdOnly = await prisma.aiModel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AiModelUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AiModelUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AiModelPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AiModel.
     * @param {AiModelUpsertArgs} args - Arguments to update or create a AiModel.
     * @example
     * // Update or create a AiModel
     * const aiModel = await prisma.aiModel.upsert({
     *   create: {
     *     // ... data to create a AiModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiModel we want to update
     *   }
     * })
     */
    upsert<T extends AiModelUpsertArgs>(
      args: SelectSubset<T, AiModelUpsertArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<Prisma.$AiModelPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AiModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelCountArgs} args - Arguments to filter AiModels to count.
     * @example
     * // Count the number of AiModels
     * const count = await prisma.aiModel.count({
     *   where: {
     *     // ... the filter for the AiModels we want to count
     *   }
     * })
     **/
    count<T extends AiModelCountArgs>(
      args?: Subset<T, AiModelCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiModelCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AiModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AiModelAggregateArgs>(
      args: Subset<T, AiModelAggregateArgs>
    ): Prisma.PrismaPromise<GetAiModelAggregateType<T>>;

    /**
     * Group by AiModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AiModelGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiModelGroupByArgs['orderBy'] }
        : { orderBy?: AiModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AiModelGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAiModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AiModel model
     */
    readonly fields: AiModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiModelClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiAccount<T extends AiAccountDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AiAccountDefaultArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      | $Result.GetResult<
          Prisma.$AiAccountPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    sharedWith<T extends AiModel$sharedWithArgs<ExtArgs> = {}>(
      args?: Subset<T, AiModel$sharedWithArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserAiModelAccessPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    bots<T extends AiModel$botsArgs<ExtArgs> = {}>(
      args?: Subset<T, AiModel$botsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
    >;
    aiUsageMetrics<T extends AiModel$aiUsageMetricsArgs<ExtArgs> = {}>(
      args?: Subset<T, AiModel$aiUsageMetricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AiModel model
   */
  interface AiModelFieldRefs {
    readonly id: FieldRef<'AiModel', 'String'>;
    readonly name: FieldRef<'AiModel', 'String'>;
    readonly modelIdentifier: FieldRef<'AiModel', 'String'>;
    readonly inputTokenPrice: FieldRef<'AiModel', 'Float'>;
    readonly outputTokenPrice: FieldRef<'AiModel', 'Float'>;
    readonly isActive: FieldRef<'AiModel', 'Boolean'>;
    readonly createdAt: FieldRef<'AiModel', 'DateTime'>;
    readonly updatedAt: FieldRef<'AiModel', 'DateTime'>;
    readonly ownerId: FieldRef<'AiModel', 'String'>;
    readonly aiAccountId: FieldRef<'AiModel', 'String'>;
  }

  // Custom InputTypes
  /**
   * AiModel findUnique
   */
  export type AiModelFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * Filter, which AiModel to fetch.
     */
    where: AiModelWhereUniqueInput;
  };

  /**
   * AiModel findUniqueOrThrow
   */
  export type AiModelFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * Filter, which AiModel to fetch.
     */
    where: AiModelWhereUniqueInput;
  };

  /**
   * AiModel findFirst
   */
  export type AiModelFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * Filter, which AiModel to fetch.
     */
    where?: AiModelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiModels.
     */
    cursor?: AiModelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiModels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiModels.
     */
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[];
  };

  /**
   * AiModel findFirstOrThrow
   */
  export type AiModelFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * Filter, which AiModel to fetch.
     */
    where?: AiModelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiModels.
     */
    cursor?: AiModelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiModels.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiModels.
     */
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[];
  };

  /**
   * AiModel findMany
   */
  export type AiModelFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * Filter, which AiModels to fetch.
     */
    where?: AiModelWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiModels to fetch.
     */
    orderBy?: AiModelOrderByWithRelationInput | AiModelOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AiModels.
     */
    cursor?: AiModelWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiModels from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiModels.
     */
    skip?: number;
    distinct?: AiModelScalarFieldEnum | AiModelScalarFieldEnum[];
  };

  /**
   * AiModel create
   */
  export type AiModelCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * The data needed to create a AiModel.
     */
    data: XOR<AiModelCreateInput, AiModelUncheckedCreateInput>;
  };

  /**
   * AiModel createMany
   */
  export type AiModelCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AiModels.
     */
    data: AiModelCreateManyInput | AiModelCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AiModel createManyAndReturn
   */
  export type AiModelCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * The data used to create many AiModels.
     */
    data: AiModelCreateManyInput | AiModelCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiModel update
   */
  export type AiModelUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * The data needed to update a AiModel.
     */
    data: XOR<AiModelUpdateInput, AiModelUncheckedUpdateInput>;
    /**
     * Choose, which AiModel to update.
     */
    where: AiModelWhereUniqueInput;
  };

  /**
   * AiModel updateMany
   */
  export type AiModelUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AiModels.
     */
    data: XOR<AiModelUpdateManyMutationInput, AiModelUncheckedUpdateManyInput>;
    /**
     * Filter which AiModels to update
     */
    where?: AiModelWhereInput;
    /**
     * Limit how many AiModels to update.
     */
    limit?: number;
  };

  /**
   * AiModel updateManyAndReturn
   */
  export type AiModelUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * The data used to update AiModels.
     */
    data: XOR<AiModelUpdateManyMutationInput, AiModelUncheckedUpdateManyInput>;
    /**
     * Filter which AiModels to update
     */
    where?: AiModelWhereInput;
    /**
     * Limit how many AiModels to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiModel upsert
   */
  export type AiModelUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * The filter to search for the AiModel to update in case it exists.
     */
    where: AiModelWhereUniqueInput;
    /**
     * In case the AiModel found by the `where` argument doesn't exist, create a new AiModel with this data.
     */
    create: XOR<AiModelCreateInput, AiModelUncheckedCreateInput>;
    /**
     * In case the AiModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiModelUpdateInput, AiModelUncheckedUpdateInput>;
  };

  /**
   * AiModel delete
   */
  export type AiModelDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    /**
     * Filter which AiModel to delete.
     */
    where: AiModelWhereUniqueInput;
  };

  /**
   * AiModel deleteMany
   */
  export type AiModelDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiModels to delete
     */
    where?: AiModelWhereInput;
    /**
     * Limit how many AiModels to delete.
     */
    limit?: number;
  };

  /**
   * AiModel.sharedWith
   */
  export type AiModel$sharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiModelAccess
     */
    select?: UserAiModelAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiModelAccess
     */
    omit?: UserAiModelAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiModelAccessInclude<ExtArgs> | null;
    where?: UserAiModelAccessWhereInput;
    orderBy?:
      | UserAiModelAccessOrderByWithRelationInput
      | UserAiModelAccessOrderByWithRelationInput[];
    cursor?: UserAiModelAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserAiModelAccessScalarFieldEnum | UserAiModelAccessScalarFieldEnum[];
  };

  /**
   * AiModel.bots
   */
  export type AiModel$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the AiBot
       */
      select?: AiBotSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the AiBot
       */
      omit?: AiBotOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: AiBotInclude<ExtArgs> | null;
      where?: AiBotWhereInput;
      orderBy?: AiBotOrderByWithRelationInput | AiBotOrderByWithRelationInput[];
      cursor?: AiBotWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: AiBotScalarFieldEnum | AiBotScalarFieldEnum[];
    };

  /**
   * AiModel.aiUsageMetrics
   */
  export type AiModel$aiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    where?: AiUsageMetricWhereInput;
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    cursor?: AiUsageMetricWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * AiModel without action
   */
  export type AiModelDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
  };

  /**
   * Model AiBot
   */

  export type AggregateAiBot = {
    _count: AiBotCountAggregateOutputType | null;
    _min: AiBotMinAggregateOutputType | null;
    _max: AiBotMaxAggregateOutputType | null;
  };

  export type AiBotMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    systemPrompt: string | null;
    responseLanguage: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ownerId: string | null;
    aiModelId: string | null;
  };

  export type AiBotMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    systemPrompt: string | null;
    responseLanguage: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    ownerId: string | null;
    aiModelId: string | null;
  };

  export type AiBotCountAggregateOutputType = {
    id: number;
    name: number;
    systemPrompt: number;
    responseLanguage: number;
    createdAt: number;
    updatedAt: number;
    ownerId: number;
    aiModelId: number;
    _all: number;
  };

  export type AiBotMinAggregateInputType = {
    id?: true;
    name?: true;
    systemPrompt?: true;
    responseLanguage?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    aiModelId?: true;
  };

  export type AiBotMaxAggregateInputType = {
    id?: true;
    name?: true;
    systemPrompt?: true;
    responseLanguage?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    aiModelId?: true;
  };

  export type AiBotCountAggregateInputType = {
    id?: true;
    name?: true;
    systemPrompt?: true;
    responseLanguage?: true;
    createdAt?: true;
    updatedAt?: true;
    ownerId?: true;
    aiModelId?: true;
    _all?: true;
  };

  export type AiBotAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiBot to aggregate.
     */
    where?: AiBotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiBots to fetch.
     */
    orderBy?: AiBotOrderByWithRelationInput | AiBotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AiBotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiBots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiBots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AiBots
     **/
    _count?: true | AiBotCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AiBotMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AiBotMaxAggregateInputType;
  };

  export type GetAiBotAggregateType<T extends AiBotAggregateArgs> = {
    [P in keyof T & keyof AggregateAiBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiBot[P]>
      : GetScalarType<T[P], AggregateAiBot[P]>;
  };

  export type AiBotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      where?: AiBotWhereInput;
      orderBy?: AiBotOrderByWithAggregationInput | AiBotOrderByWithAggregationInput[];
      by: AiBotScalarFieldEnum[] | AiBotScalarFieldEnum;
      having?: AiBotScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: AiBotCountAggregateInputType | true;
      _min?: AiBotMinAggregateInputType;
      _max?: AiBotMaxAggregateInputType;
    };

  export type AiBotGroupByOutputType = {
    id: string;
    name: string;
    systemPrompt: string;
    responseLanguage: string;
    createdAt: Date;
    updatedAt: Date;
    ownerId: string;
    aiModelId: string;
    _count: AiBotCountAggregateOutputType | null;
    _min: AiBotMinAggregateOutputType | null;
    _max: AiBotMaxAggregateOutputType | null;
  };

  type GetAiBotGroupByPayload<T extends AiBotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiBotGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AiBotGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AiBotGroupByOutputType[P]>
          : GetScalarType<T[P], AiBotGroupByOutputType[P]>;
      }
    >
  >;

  export type AiBotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetSelect<
      {
        id?: boolean;
        name?: boolean;
        systemPrompt?: boolean;
        responseLanguage?: boolean;
        createdAt?: boolean;
        updatedAt?: boolean;
        ownerId?: boolean;
        aiModelId?: boolean;
        owner?: boolean | UserDefaultArgs<ExtArgs>;
        aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
        sharedWith?: boolean | AiBot$sharedWithArgs<ExtArgs>;
        aiUsageMetrics?: boolean | AiBot$aiUsageMetricsArgs<ExtArgs>;
        defaultForInstances?: boolean | AiBot$defaultForInstancesArgs<ExtArgs>;
        processingQueueItems?: boolean | AiBot$processingQueueItemsArgs<ExtArgs>;
        _count?: boolean | AiBotCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['aiBot']
    >;

  export type AiBotSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      systemPrompt?: boolean;
      responseLanguage?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ownerId?: boolean;
      aiModelId?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['aiBot']
  >;

  export type AiBotSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      systemPrompt?: boolean;
      responseLanguage?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      ownerId?: boolean;
      aiModelId?: boolean;
      owner?: boolean | UserDefaultArgs<ExtArgs>;
      aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['aiBot']
  >;

  export type AiBotSelectScalar = {
    id?: boolean;
    name?: boolean;
    systemPrompt?: boolean;
    responseLanguage?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    ownerId?: boolean;
    aiModelId?: boolean;
  };

  export type AiBotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    $Extensions.GetOmit<
      | 'id'
      | 'name'
      | 'systemPrompt'
      | 'responseLanguage'
      | 'createdAt'
      | 'updatedAt'
      | 'ownerId'
      | 'aiModelId',
      ExtArgs['result']['aiBot']
    >;
  export type AiBotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
    sharedWith?: boolean | AiBot$sharedWithArgs<ExtArgs>;
    aiUsageMetrics?: boolean | AiBot$aiUsageMetricsArgs<ExtArgs>;
    defaultForInstances?: boolean | AiBot$defaultForInstancesArgs<ExtArgs>;
    processingQueueItems?: boolean | AiBot$processingQueueItemsArgs<ExtArgs>;
    _count?: boolean | AiBotCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type AiBotIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
  };
  export type AiBotIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    owner?: boolean | UserDefaultArgs<ExtArgs>;
    aiModel?: boolean | AiModelDefaultArgs<ExtArgs>;
  };

  export type $AiBotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: 'AiBot';
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>;
      aiModel: Prisma.$AiModelPayload<ExtArgs>;
      sharedWith: Prisma.$UserAiBotAccessPayload<ExtArgs>[];
      aiUsageMetrics: Prisma.$AiUsageMetricPayload<ExtArgs>[];
      defaultForInstances: Prisma.$PaperlessInstancePayload<ExtArgs>[];
      processingQueueItems: Prisma.$ProcessingQueuePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        systemPrompt: string;
        responseLanguage: string;
        createdAt: Date;
        updatedAt: Date;
        ownerId: string;
        aiModelId: string;
      },
      ExtArgs['result']['aiBot']
    >;
    composites: {};
  };

  type AiBotGetPayload<S extends boolean | null | undefined | AiBotDefaultArgs> = $Result.GetResult<
    Prisma.$AiBotPayload,
    S
  >;

  type AiBotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
    AiBotFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AiBotCountAggregateInputType | true;
  };

  export interface AiBotDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiBot']; meta: { name: 'AiBot' } };
    /**
     * Find zero or one AiBot that matches the filter.
     * @param {AiBotFindUniqueArgs} args - Arguments to find a AiBot
     * @example
     * // Get one AiBot
     * const aiBot = await prisma.aiBot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiBotFindUniqueArgs>(
      args: SelectSubset<T, AiBotFindUniqueArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AiBot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiBotFindUniqueOrThrowArgs} args - Arguments to find a AiBot
     * @example
     * // Get one AiBot
     * const aiBot = await prisma.aiBot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiBotFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AiBotFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiBot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotFindFirstArgs} args - Arguments to find a AiBot
     * @example
     * // Get one AiBot
     * const aiBot = await prisma.aiBot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiBotFindFirstArgs>(
      args?: SelectSubset<T, AiBotFindFirstArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiBot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotFindFirstOrThrowArgs} args - Arguments to find a AiBot
     * @example
     * // Get one AiBot
     * const aiBot = await prisma.aiBot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiBotFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AiBotFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AiBots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiBots
     * const aiBots = await prisma.aiBot.findMany()
     *
     * // Get first 10 AiBots
     * const aiBots = await prisma.aiBot.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const aiBotWithIdOnly = await prisma.aiBot.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AiBotFindManyArgs>(
      args?: SelectSubset<T, AiBotFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a AiBot.
     * @param {AiBotCreateArgs} args - Arguments to create a AiBot.
     * @example
     * // Create one AiBot
     * const AiBot = await prisma.aiBot.create({
     *   data: {
     *     // ... data to create a AiBot
     *   }
     * })
     *
     */
    create<T extends AiBotCreateArgs>(
      args: SelectSubset<T, AiBotCreateArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AiBots.
     * @param {AiBotCreateManyArgs} args - Arguments to create many AiBots.
     * @example
     * // Create many AiBots
     * const aiBot = await prisma.aiBot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AiBotCreateManyArgs>(
      args?: SelectSubset<T, AiBotCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AiBots and returns the data saved in the database.
     * @param {AiBotCreateManyAndReturnArgs} args - Arguments to create many AiBots.
     * @example
     * // Create many AiBots
     * const aiBot = await prisma.aiBot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AiBots and only return the `id`
     * const aiBotWithIdOnly = await prisma.aiBot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AiBotCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AiBotCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'createManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Delete a AiBot.
     * @param {AiBotDeleteArgs} args - Arguments to delete one AiBot.
     * @example
     * // Delete one AiBot
     * const AiBot = await prisma.aiBot.delete({
     *   where: {
     *     // ... filter to delete one AiBot
     *   }
     * })
     *
     */
    delete<T extends AiBotDeleteArgs>(
      args: SelectSubset<T, AiBotDeleteArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AiBot.
     * @param {AiBotUpdateArgs} args - Arguments to update one AiBot.
     * @example
     * // Update one AiBot
     * const aiBot = await prisma.aiBot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AiBotUpdateArgs>(
      args: SelectSubset<T, AiBotUpdateArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AiBots.
     * @param {AiBotDeleteManyArgs} args - Arguments to filter AiBots to delete.
     * @example
     * // Delete a few AiBots
     * const { count } = await prisma.aiBot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AiBotDeleteManyArgs>(
      args?: SelectSubset<T, AiBotDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiBots
     * const aiBot = await prisma.aiBot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AiBotUpdateManyArgs>(
      args: SelectSubset<T, AiBotUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiBots and returns the data updated in the database.
     * @param {AiBotUpdateManyAndReturnArgs} args - Arguments to update many AiBots.
     * @example
     * // Update many AiBots
     * const aiBot = await prisma.aiBot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AiBots and only return the `id`
     * const aiBotWithIdOnly = await prisma.aiBot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AiBotUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AiBotUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'updateManyAndReturn', GlobalOmitOptions>
    >;

    /**
     * Create or update one AiBot.
     * @param {AiBotUpsertArgs} args - Arguments to update or create a AiBot.
     * @example
     * // Update or create a AiBot
     * const aiBot = await prisma.aiBot.upsert({
     *   create: {
     *     // ... data to create a AiBot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiBot we want to update
     *   }
     * })
     */
    upsert<T extends AiBotUpsertArgs>(
      args: SelectSubset<T, AiBotUpsertArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<Prisma.$AiBotPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AiBots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotCountArgs} args - Arguments to filter AiBots to count.
     * @example
     * // Count the number of AiBots
     * const count = await prisma.aiBot.count({
     *   where: {
     *     // ... the filter for the AiBots we want to count
     *   }
     * })
     **/
    count<T extends AiBotCountArgs>(
      args?: Subset<T, AiBotCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiBotCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AiBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AiBotAggregateArgs>(
      args: Subset<T, AiBotAggregateArgs>
    ): Prisma.PrismaPromise<GetAiBotAggregateType<T>>;

    /**
     * Group by AiBot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiBotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AiBotGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiBotGroupByArgs['orderBy'] }
        : { orderBy?: AiBotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AiBotGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors ? GetAiBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AiBot model
     */
    readonly fields: AiBotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiBot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiBotClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiModel<T extends AiModelDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AiModelDefaultArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      | $Result.GetResult<
          Prisma.$AiModelPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    sharedWith<T extends AiBot$sharedWithArgs<ExtArgs> = {}>(
      args?: Subset<T, AiBot$sharedWithArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$UserAiBotAccessPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    aiUsageMetrics<T extends AiBot$aiUsageMetricsArgs<ExtArgs> = {}>(
      args?: Subset<T, AiBot$aiUsageMetricsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    defaultForInstances<T extends AiBot$defaultForInstancesArgs<ExtArgs> = {}>(
      args?: Subset<T, AiBot$defaultForInstancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaperlessInstancePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    processingQueueItems<T extends AiBot$processingQueueItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, AiBot$processingQueueItemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AiBot model
   */
  interface AiBotFieldRefs {
    readonly id: FieldRef<'AiBot', 'String'>;
    readonly name: FieldRef<'AiBot', 'String'>;
    readonly systemPrompt: FieldRef<'AiBot', 'String'>;
    readonly responseLanguage: FieldRef<'AiBot', 'String'>;
    readonly createdAt: FieldRef<'AiBot', 'DateTime'>;
    readonly updatedAt: FieldRef<'AiBot', 'DateTime'>;
    readonly ownerId: FieldRef<'AiBot', 'String'>;
    readonly aiModelId: FieldRef<'AiBot', 'String'>;
  }

  // Custom InputTypes
  /**
   * AiBot findUnique
   */
  export type AiBotFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    /**
     * Filter, which AiBot to fetch.
     */
    where: AiBotWhereUniqueInput;
  };

  /**
   * AiBot findUniqueOrThrow
   */
  export type AiBotFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    /**
     * Filter, which AiBot to fetch.
     */
    where: AiBotWhereUniqueInput;
  };

  /**
   * AiBot findFirst
   */
  export type AiBotFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    /**
     * Filter, which AiBot to fetch.
     */
    where?: AiBotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiBots to fetch.
     */
    orderBy?: AiBotOrderByWithRelationInput | AiBotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiBots.
     */
    cursor?: AiBotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiBots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiBots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiBots.
     */
    distinct?: AiBotScalarFieldEnum | AiBotScalarFieldEnum[];
  };

  /**
   * AiBot findFirstOrThrow
   */
  export type AiBotFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    /**
     * Filter, which AiBot to fetch.
     */
    where?: AiBotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiBots to fetch.
     */
    orderBy?: AiBotOrderByWithRelationInput | AiBotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiBots.
     */
    cursor?: AiBotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiBots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiBots.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiBots.
     */
    distinct?: AiBotScalarFieldEnum | AiBotScalarFieldEnum[];
  };

  /**
   * AiBot findMany
   */
  export type AiBotFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    /**
     * Filter, which AiBots to fetch.
     */
    where?: AiBotWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiBots to fetch.
     */
    orderBy?: AiBotOrderByWithRelationInput | AiBotOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AiBots.
     */
    cursor?: AiBotWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiBots from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiBots.
     */
    skip?: number;
    distinct?: AiBotScalarFieldEnum | AiBotScalarFieldEnum[];
  };

  /**
   * AiBot create
   */
  export type AiBotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the AiBot
       */
      select?: AiBotSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the AiBot
       */
      omit?: AiBotOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: AiBotInclude<ExtArgs> | null;
      /**
       * The data needed to create a AiBot.
       */
      data: XOR<AiBotCreateInput, AiBotUncheckedCreateInput>;
    };

  /**
   * AiBot createMany
   */
  export type AiBotCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AiBots.
     */
    data: AiBotCreateManyInput | AiBotCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AiBot createManyAndReturn
   */
  export type AiBotCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * The data used to create many AiBots.
     */
    data: AiBotCreateManyInput | AiBotCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiBot update
   */
  export type AiBotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the AiBot
       */
      select?: AiBotSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the AiBot
       */
      omit?: AiBotOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: AiBotInclude<ExtArgs> | null;
      /**
       * The data needed to update a AiBot.
       */
      data: XOR<AiBotUpdateInput, AiBotUncheckedUpdateInput>;
      /**
       * Choose, which AiBot to update.
       */
      where: AiBotWhereUniqueInput;
    };

  /**
   * AiBot updateMany
   */
  export type AiBotUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AiBots.
     */
    data: XOR<AiBotUpdateManyMutationInput, AiBotUncheckedUpdateManyInput>;
    /**
     * Filter which AiBots to update
     */
    where?: AiBotWhereInput;
    /**
     * Limit how many AiBots to update.
     */
    limit?: number;
  };

  /**
   * AiBot updateManyAndReturn
   */
  export type AiBotUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * The data used to update AiBots.
     */
    data: XOR<AiBotUpdateManyMutationInput, AiBotUncheckedUpdateManyInput>;
    /**
     * Filter which AiBots to update
     */
    where?: AiBotWhereInput;
    /**
     * Limit how many AiBots to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiBot upsert
   */
  export type AiBotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the AiBot
       */
      select?: AiBotSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the AiBot
       */
      omit?: AiBotOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: AiBotInclude<ExtArgs> | null;
      /**
       * The filter to search for the AiBot to update in case it exists.
       */
      where: AiBotWhereUniqueInput;
      /**
       * In case the AiBot found by the `where` argument doesn't exist, create a new AiBot with this data.
       */
      create: XOR<AiBotCreateInput, AiBotUncheckedCreateInput>;
      /**
       * In case the AiBot was found with the provided `where` argument, update it with this data.
       */
      update: XOR<AiBotUpdateInput, AiBotUncheckedUpdateInput>;
    };

  /**
   * AiBot delete
   */
  export type AiBotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the AiBot
       */
      select?: AiBotSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the AiBot
       */
      omit?: AiBotOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: AiBotInclude<ExtArgs> | null;
      /**
       * Filter which AiBot to delete.
       */
      where: AiBotWhereUniqueInput;
    };

  /**
   * AiBot deleteMany
   */
  export type AiBotDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiBots to delete
     */
    where?: AiBotWhereInput;
    /**
     * Limit how many AiBots to delete.
     */
    limit?: number;
  };

  /**
   * AiBot.sharedWith
   */
  export type AiBot$sharedWithArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserAiBotAccess
     */
    select?: UserAiBotAccessSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the UserAiBotAccess
     */
    omit?: UserAiBotAccessOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAiBotAccessInclude<ExtArgs> | null;
    where?: UserAiBotAccessWhereInput;
    orderBy?: UserAiBotAccessOrderByWithRelationInput | UserAiBotAccessOrderByWithRelationInput[];
    cursor?: UserAiBotAccessWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserAiBotAccessScalarFieldEnum | UserAiBotAccessScalarFieldEnum[];
  };

  /**
   * AiBot.aiUsageMetrics
   */
  export type AiBot$aiUsageMetricsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    where?: AiUsageMetricWhereInput;
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    cursor?: AiUsageMetricWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * AiBot.defaultForInstances
   */
  export type AiBot$defaultForInstancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessInstance
     */
    select?: PaperlessInstanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessInstance
     */
    omit?: PaperlessInstanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessInstanceInclude<ExtArgs> | null;
    where?: PaperlessInstanceWhereInput;
    orderBy?:
      | PaperlessInstanceOrderByWithRelationInput
      | PaperlessInstanceOrderByWithRelationInput[];
    cursor?: PaperlessInstanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaperlessInstanceScalarFieldEnum | PaperlessInstanceScalarFieldEnum[];
  };

  /**
   * AiBot.processingQueueItems
   */
  export type AiBot$processingQueueItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    where?: ProcessingQueueWhereInput;
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    cursor?: ProcessingQueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProcessingQueueScalarFieldEnum | ProcessingQueueScalarFieldEnum[];
  };

  /**
   * AiBot without action
   */
  export type AiBotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    {
      /**
       * Select specific fields to fetch from the AiBot
       */
      select?: AiBotSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the AiBot
       */
      omit?: AiBotOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: AiBotInclude<ExtArgs> | null;
    };

  /**
   * Model PaperlessDocument
   */

  export type AggregatePaperlessDocument = {
    _count: PaperlessDocumentCountAggregateOutputType | null;
    _avg: PaperlessDocumentAvgAggregateOutputType | null;
    _sum: PaperlessDocumentSumAggregateOutputType | null;
    _min: PaperlessDocumentMinAggregateOutputType | null;
    _max: PaperlessDocumentMaxAggregateOutputType | null;
  };

  export type PaperlessDocumentAvgAggregateOutputType = {
    paperlessId: number | null;
    correspondentId: number | null;
    tagIds: number | null;
  };

  export type PaperlessDocumentSumAggregateOutputType = {
    paperlessId: number | null;
    correspondentId: number | null;
    tagIds: number[];
  };

  export type PaperlessDocumentMinAggregateOutputType = {
    id: string | null;
    paperlessId: number | null;
    title: string | null;
    content: string | null;
    correspondentId: number | null;
    documentDate: Date | null;
    paperlessModified: Date | null;
    importedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    paperlessInstanceId: string | null;
  };

  export type PaperlessDocumentMaxAggregateOutputType = {
    id: string | null;
    paperlessId: number | null;
    title: string | null;
    content: string | null;
    correspondentId: number | null;
    documentDate: Date | null;
    paperlessModified: Date | null;
    importedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    paperlessInstanceId: string | null;
  };

  export type PaperlessDocumentCountAggregateOutputType = {
    id: number;
    paperlessId: number;
    title: number;
    content: number;
    correspondentId: number;
    tagIds: number;
    documentDate: number;
    paperlessModified: number;
    importedAt: number;
    createdAt: number;
    updatedAt: number;
    paperlessInstanceId: number;
    _all: number;
  };

  export type PaperlessDocumentAvgAggregateInputType = {
    paperlessId?: true;
    correspondentId?: true;
    tagIds?: true;
  };

  export type PaperlessDocumentSumAggregateInputType = {
    paperlessId?: true;
    correspondentId?: true;
    tagIds?: true;
  };

  export type PaperlessDocumentMinAggregateInputType = {
    id?: true;
    paperlessId?: true;
    title?: true;
    content?: true;
    correspondentId?: true;
    documentDate?: true;
    paperlessModified?: true;
    importedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    paperlessInstanceId?: true;
  };

  export type PaperlessDocumentMaxAggregateInputType = {
    id?: true;
    paperlessId?: true;
    title?: true;
    content?: true;
    correspondentId?: true;
    documentDate?: true;
    paperlessModified?: true;
    importedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    paperlessInstanceId?: true;
  };

  export type PaperlessDocumentCountAggregateInputType = {
    id?: true;
    paperlessId?: true;
    title?: true;
    content?: true;
    correspondentId?: true;
    tagIds?: true;
    documentDate?: true;
    paperlessModified?: true;
    importedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    paperlessInstanceId?: true;
    _all?: true;
  };

  export type PaperlessDocumentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PaperlessDocument to aggregate.
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessDocuments to fetch.
     */
    orderBy?:
      | PaperlessDocumentOrderByWithRelationInput
      | PaperlessDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaperlessDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PaperlessDocuments
     **/
    _count?: true | PaperlessDocumentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaperlessDocumentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaperlessDocumentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaperlessDocumentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaperlessDocumentMaxAggregateInputType;
  };

  export type GetPaperlessDocumentAggregateType<T extends PaperlessDocumentAggregateArgs> = {
    [P in keyof T & keyof AggregatePaperlessDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaperlessDocument[P]>
      : GetScalarType<T[P], AggregatePaperlessDocument[P]>;
  };

  export type PaperlessDocumentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaperlessDocumentWhereInput;
    orderBy?:
      | PaperlessDocumentOrderByWithAggregationInput
      | PaperlessDocumentOrderByWithAggregationInput[];
    by: PaperlessDocumentScalarFieldEnum[] | PaperlessDocumentScalarFieldEnum;
    having?: PaperlessDocumentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaperlessDocumentCountAggregateInputType | true;
    _avg?: PaperlessDocumentAvgAggregateInputType;
    _sum?: PaperlessDocumentSumAggregateInputType;
    _min?: PaperlessDocumentMinAggregateInputType;
    _max?: PaperlessDocumentMaxAggregateInputType;
  };

  export type PaperlessDocumentGroupByOutputType = {
    id: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId: number | null;
    tagIds: number[];
    documentDate: Date | null;
    paperlessModified: Date | null;
    importedAt: Date;
    createdAt: Date;
    updatedAt: Date;
    paperlessInstanceId: string;
    _count: PaperlessDocumentCountAggregateOutputType | null;
    _avg: PaperlessDocumentAvgAggregateOutputType | null;
    _sum: PaperlessDocumentSumAggregateOutputType | null;
    _min: PaperlessDocumentMinAggregateOutputType | null;
    _max: PaperlessDocumentMaxAggregateOutputType | null;
  };

  type GetPaperlessDocumentGroupByPayload<T extends PaperlessDocumentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PaperlessDocumentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PaperlessDocumentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaperlessDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PaperlessDocumentGroupByOutputType[P]>;
        }
      >
    >;

  export type PaperlessDocumentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paperlessId?: boolean;
      title?: boolean;
      content?: boolean;
      correspondentId?: boolean;
      tagIds?: boolean;
      documentDate?: boolean;
      paperlessModified?: boolean;
      importedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paperlessInstanceId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
      processingResults?: boolean | PaperlessDocument$processingResultsArgs<ExtArgs>;
      processingQueueItems?: boolean | PaperlessDocument$processingQueueItemsArgs<ExtArgs>;
      _count?: boolean | PaperlessDocumentCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paperlessDocument']
  >;

  export type PaperlessDocumentSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paperlessId?: boolean;
      title?: boolean;
      content?: boolean;
      correspondentId?: boolean;
      tagIds?: boolean;
      documentDate?: boolean;
      paperlessModified?: boolean;
      importedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paperlessInstanceId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paperlessDocument']
  >;

  export type PaperlessDocumentSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paperlessId?: boolean;
      title?: boolean;
      content?: boolean;
      correspondentId?: boolean;
      tagIds?: boolean;
      documentDate?: boolean;
      paperlessModified?: boolean;
      importedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paperlessInstanceId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['paperlessDocument']
  >;

  export type PaperlessDocumentSelectScalar = {
    id?: boolean;
    paperlessId?: boolean;
    title?: boolean;
    content?: boolean;
    correspondentId?: boolean;
    tagIds?: boolean;
    documentDate?: boolean;
    paperlessModified?: boolean;
    importedAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    paperlessInstanceId?: boolean;
  };

  export type PaperlessDocumentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'paperlessId'
    | 'title'
    | 'content'
    | 'correspondentId'
    | 'tagIds'
    | 'documentDate'
    | 'paperlessModified'
    | 'importedAt'
    | 'createdAt'
    | 'updatedAt'
    | 'paperlessInstanceId',
    ExtArgs['result']['paperlessDocument']
  >;
  export type PaperlessDocumentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    processingResults?: boolean | PaperlessDocument$processingResultsArgs<ExtArgs>;
    processingQueueItems?: boolean | PaperlessDocument$processingQueueItemsArgs<ExtArgs>;
    _count?: boolean | PaperlessDocumentCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PaperlessDocumentIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };
  export type PaperlessDocumentIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };

  export type $PaperlessDocumentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PaperlessDocument';
    objects: {
      paperlessInstance: Prisma.$PaperlessInstancePayload<ExtArgs>;
      processingResults: Prisma.$DocumentProcessingResultPayload<ExtArgs>[];
      processingQueueItems: Prisma.$ProcessingQueuePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        paperlessId: number;
        title: string;
        content: string;
        correspondentId: number | null;
        tagIds: number[];
        documentDate: Date | null;
        paperlessModified: Date | null;
        importedAt: Date;
        createdAt: Date;
        updatedAt: Date;
        paperlessInstanceId: string;
      },
      ExtArgs['result']['paperlessDocument']
    >;
    composites: {};
  };

  type PaperlessDocumentGetPayload<
    S extends boolean | null | undefined | PaperlessDocumentDefaultArgs,
  > = $Result.GetResult<Prisma.$PaperlessDocumentPayload, S>;

  type PaperlessDocumentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PaperlessDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PaperlessDocumentCountAggregateInputType | true;
  };

  export interface PaperlessDocumentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PaperlessDocument'];
      meta: { name: 'PaperlessDocument' };
    };
    /**
     * Find zero or one PaperlessDocument that matches the filter.
     * @param {PaperlessDocumentFindUniqueArgs} args - Arguments to find a PaperlessDocument
     * @example
     * // Get one PaperlessDocument
     * const paperlessDocument = await prisma.paperlessDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaperlessDocumentFindUniqueArgs>(
      args: SelectSubset<T, PaperlessDocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PaperlessDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaperlessDocumentFindUniqueOrThrowArgs} args - Arguments to find a PaperlessDocument
     * @example
     * // Get one PaperlessDocument
     * const paperlessDocument = await prisma.paperlessDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaperlessDocumentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaperlessDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaperlessDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentFindFirstArgs} args - Arguments to find a PaperlessDocument
     * @example
     * // Get one PaperlessDocument
     * const paperlessDocument = await prisma.paperlessDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaperlessDocumentFindFirstArgs>(
      args?: SelectSubset<T, PaperlessDocumentFindFirstArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PaperlessDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentFindFirstOrThrowArgs} args - Arguments to find a PaperlessDocument
     * @example
     * // Get one PaperlessDocument
     * const paperlessDocument = await prisma.paperlessDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaperlessDocumentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaperlessDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PaperlessDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaperlessDocuments
     * const paperlessDocuments = await prisma.paperlessDocument.findMany()
     *
     * // Get first 10 PaperlessDocuments
     * const paperlessDocuments = await prisma.paperlessDocument.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paperlessDocumentWithIdOnly = await prisma.paperlessDocument.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaperlessDocumentFindManyArgs>(
      args?: SelectSubset<T, PaperlessDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PaperlessDocumentPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a PaperlessDocument.
     * @param {PaperlessDocumentCreateArgs} args - Arguments to create a PaperlessDocument.
     * @example
     * // Create one PaperlessDocument
     * const PaperlessDocument = await prisma.paperlessDocument.create({
     *   data: {
     *     // ... data to create a PaperlessDocument
     *   }
     * })
     *
     */
    create<T extends PaperlessDocumentCreateArgs>(
      args: SelectSubset<T, PaperlessDocumentCreateArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<Prisma.$PaperlessDocumentPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PaperlessDocuments.
     * @param {PaperlessDocumentCreateManyArgs} args - Arguments to create many PaperlessDocuments.
     * @example
     * // Create many PaperlessDocuments
     * const paperlessDocument = await prisma.paperlessDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaperlessDocumentCreateManyArgs>(
      args?: SelectSubset<T, PaperlessDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PaperlessDocuments and returns the data saved in the database.
     * @param {PaperlessDocumentCreateManyAndReturnArgs} args - Arguments to create many PaperlessDocuments.
     * @example
     * // Create many PaperlessDocuments
     * const paperlessDocument = await prisma.paperlessDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PaperlessDocuments and only return the `id`
     * const paperlessDocumentWithIdOnly = await prisma.paperlessDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PaperlessDocumentCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PaperlessDocumentCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a PaperlessDocument.
     * @param {PaperlessDocumentDeleteArgs} args - Arguments to delete one PaperlessDocument.
     * @example
     * // Delete one PaperlessDocument
     * const PaperlessDocument = await prisma.paperlessDocument.delete({
     *   where: {
     *     // ... filter to delete one PaperlessDocument
     *   }
     * })
     *
     */
    delete<T extends PaperlessDocumentDeleteArgs>(
      args: SelectSubset<T, PaperlessDocumentDeleteArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<Prisma.$PaperlessDocumentPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PaperlessDocument.
     * @param {PaperlessDocumentUpdateArgs} args - Arguments to update one PaperlessDocument.
     * @example
     * // Update one PaperlessDocument
     * const paperlessDocument = await prisma.paperlessDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaperlessDocumentUpdateArgs>(
      args: SelectSubset<T, PaperlessDocumentUpdateArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<Prisma.$PaperlessDocumentPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PaperlessDocuments.
     * @param {PaperlessDocumentDeleteManyArgs} args - Arguments to filter PaperlessDocuments to delete.
     * @example
     * // Delete a few PaperlessDocuments
     * const { count } = await prisma.paperlessDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaperlessDocumentDeleteManyArgs>(
      args?: SelectSubset<T, PaperlessDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaperlessDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaperlessDocuments
     * const paperlessDocument = await prisma.paperlessDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaperlessDocumentUpdateManyArgs>(
      args: SelectSubset<T, PaperlessDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PaperlessDocuments and returns the data updated in the database.
     * @param {PaperlessDocumentUpdateManyAndReturnArgs} args - Arguments to update many PaperlessDocuments.
     * @example
     * // Update many PaperlessDocuments
     * const paperlessDocument = await prisma.paperlessDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PaperlessDocuments and only return the `id`
     * const paperlessDocumentWithIdOnly = await prisma.paperlessDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PaperlessDocumentUpdateManyAndReturnArgs>(
      args: SelectSubset<T, PaperlessDocumentUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one PaperlessDocument.
     * @param {PaperlessDocumentUpsertArgs} args - Arguments to update or create a PaperlessDocument.
     * @example
     * // Update or create a PaperlessDocument
     * const paperlessDocument = await prisma.paperlessDocument.upsert({
     *   create: {
     *     // ... data to create a PaperlessDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaperlessDocument we want to update
     *   }
     * })
     */
    upsert<T extends PaperlessDocumentUpsertArgs>(
      args: SelectSubset<T, PaperlessDocumentUpsertArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<Prisma.$PaperlessDocumentPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of PaperlessDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentCountArgs} args - Arguments to filter PaperlessDocuments to count.
     * @example
     * // Count the number of PaperlessDocuments
     * const count = await prisma.paperlessDocument.count({
     *   where: {
     *     // ... the filter for the PaperlessDocuments we want to count
     *   }
     * })
     **/
    count<T extends PaperlessDocumentCountArgs>(
      args?: Subset<T, PaperlessDocumentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaperlessDocumentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PaperlessDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaperlessDocumentAggregateArgs>(
      args: Subset<T, PaperlessDocumentAggregateArgs>
    ): Prisma.PrismaPromise<GetPaperlessDocumentAggregateType<T>>;

    /**
     * Group by PaperlessDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperlessDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaperlessDocumentGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaperlessDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PaperlessDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaperlessDocumentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPaperlessDocumentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PaperlessDocument model
     */
    readonly fields: PaperlessDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaperlessDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaperlessDocumentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    paperlessInstance<T extends PaperlessInstanceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstanceDefaultArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      | $Result.GetResult<
          Prisma.$PaperlessInstancePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    processingResults<T extends PaperlessDocument$processingResultsArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessDocument$processingResultsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$DocumentProcessingResultPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    processingQueueItems<T extends PaperlessDocument$processingQueueItemsArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessDocument$processingQueueItemsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PaperlessDocument model
   */
  interface PaperlessDocumentFieldRefs {
    readonly id: FieldRef<'PaperlessDocument', 'String'>;
    readonly paperlessId: FieldRef<'PaperlessDocument', 'Int'>;
    readonly title: FieldRef<'PaperlessDocument', 'String'>;
    readonly content: FieldRef<'PaperlessDocument', 'String'>;
    readonly correspondentId: FieldRef<'PaperlessDocument', 'Int'>;
    readonly tagIds: FieldRef<'PaperlessDocument', 'Int[]'>;
    readonly documentDate: FieldRef<'PaperlessDocument', 'DateTime'>;
    readonly paperlessModified: FieldRef<'PaperlessDocument', 'DateTime'>;
    readonly importedAt: FieldRef<'PaperlessDocument', 'DateTime'>;
    readonly createdAt: FieldRef<'PaperlessDocument', 'DateTime'>;
    readonly updatedAt: FieldRef<'PaperlessDocument', 'DateTime'>;
    readonly paperlessInstanceId: FieldRef<'PaperlessDocument', 'String'>;
  }

  // Custom InputTypes
  /**
   * PaperlessDocument findUnique
   */
  export type PaperlessDocumentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessDocument to fetch.
     */
    where: PaperlessDocumentWhereUniqueInput;
  };

  /**
   * PaperlessDocument findUniqueOrThrow
   */
  export type PaperlessDocumentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessDocument to fetch.
     */
    where: PaperlessDocumentWhereUniqueInput;
  };

  /**
   * PaperlessDocument findFirst
   */
  export type PaperlessDocumentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessDocument to fetch.
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessDocuments to fetch.
     */
    orderBy?:
      | PaperlessDocumentOrderByWithRelationInput
      | PaperlessDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaperlessDocuments.
     */
    cursor?: PaperlessDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaperlessDocuments.
     */
    distinct?: PaperlessDocumentScalarFieldEnum | PaperlessDocumentScalarFieldEnum[];
  };

  /**
   * PaperlessDocument findFirstOrThrow
   */
  export type PaperlessDocumentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessDocument to fetch.
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessDocuments to fetch.
     */
    orderBy?:
      | PaperlessDocumentOrderByWithRelationInput
      | PaperlessDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PaperlessDocuments.
     */
    cursor?: PaperlessDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessDocuments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PaperlessDocuments.
     */
    distinct?: PaperlessDocumentScalarFieldEnum | PaperlessDocumentScalarFieldEnum[];
  };

  /**
   * PaperlessDocument findMany
   */
  export type PaperlessDocumentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * Filter, which PaperlessDocuments to fetch.
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PaperlessDocuments to fetch.
     */
    orderBy?:
      | PaperlessDocumentOrderByWithRelationInput
      | PaperlessDocumentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PaperlessDocuments.
     */
    cursor?: PaperlessDocumentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PaperlessDocuments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PaperlessDocuments.
     */
    skip?: number;
    distinct?: PaperlessDocumentScalarFieldEnum | PaperlessDocumentScalarFieldEnum[];
  };

  /**
   * PaperlessDocument create
   */
  export type PaperlessDocumentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to create a PaperlessDocument.
     */
    data: XOR<PaperlessDocumentCreateInput, PaperlessDocumentUncheckedCreateInput>;
  };

  /**
   * PaperlessDocument createMany
   */
  export type PaperlessDocumentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PaperlessDocuments.
     */
    data: PaperlessDocumentCreateManyInput | PaperlessDocumentCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PaperlessDocument createManyAndReturn
   */
  export type PaperlessDocumentCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * The data used to create many PaperlessDocuments.
     */
    data: PaperlessDocumentCreateManyInput | PaperlessDocumentCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PaperlessDocument update
   */
  export type PaperlessDocumentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * The data needed to update a PaperlessDocument.
     */
    data: XOR<PaperlessDocumentUpdateInput, PaperlessDocumentUncheckedUpdateInput>;
    /**
     * Choose, which PaperlessDocument to update.
     */
    where: PaperlessDocumentWhereUniqueInput;
  };

  /**
   * PaperlessDocument updateMany
   */
  export type PaperlessDocumentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PaperlessDocuments.
     */
    data: XOR<PaperlessDocumentUpdateManyMutationInput, PaperlessDocumentUncheckedUpdateManyInput>;
    /**
     * Filter which PaperlessDocuments to update
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * Limit how many PaperlessDocuments to update.
     */
    limit?: number;
  };

  /**
   * PaperlessDocument updateManyAndReturn
   */
  export type PaperlessDocumentUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * The data used to update PaperlessDocuments.
     */
    data: XOR<PaperlessDocumentUpdateManyMutationInput, PaperlessDocumentUncheckedUpdateManyInput>;
    /**
     * Filter which PaperlessDocuments to update
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * Limit how many PaperlessDocuments to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PaperlessDocument upsert
   */
  export type PaperlessDocumentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * The filter to search for the PaperlessDocument to update in case it exists.
     */
    where: PaperlessDocumentWhereUniqueInput;
    /**
     * In case the PaperlessDocument found by the `where` argument doesn't exist, create a new PaperlessDocument with this data.
     */
    create: XOR<PaperlessDocumentCreateInput, PaperlessDocumentUncheckedCreateInput>;
    /**
     * In case the PaperlessDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaperlessDocumentUpdateInput, PaperlessDocumentUncheckedUpdateInput>;
  };

  /**
   * PaperlessDocument delete
   */
  export type PaperlessDocumentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    /**
     * Filter which PaperlessDocument to delete.
     */
    where: PaperlessDocumentWhereUniqueInput;
  };

  /**
   * PaperlessDocument deleteMany
   */
  export type PaperlessDocumentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PaperlessDocuments to delete
     */
    where?: PaperlessDocumentWhereInput;
    /**
     * Limit how many PaperlessDocuments to delete.
     */
    limit?: number;
  };

  /**
   * PaperlessDocument.processingResults
   */
  export type PaperlessDocument$processingResultsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    where?: DocumentProcessingResultWhereInput;
    orderBy?:
      | DocumentProcessingResultOrderByWithRelationInput
      | DocumentProcessingResultOrderByWithRelationInput[];
    cursor?: DocumentProcessingResultWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: DocumentProcessingResultScalarFieldEnum | DocumentProcessingResultScalarFieldEnum[];
  };

  /**
   * PaperlessDocument.processingQueueItems
   */
  export type PaperlessDocument$processingQueueItemsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    where?: ProcessingQueueWhereInput;
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    cursor?: ProcessingQueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ProcessingQueueScalarFieldEnum | ProcessingQueueScalarFieldEnum[];
  };

  /**
   * PaperlessDocument without action
   */
  export type PaperlessDocumentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
  };

  /**
   * Model DocumentProcessingResult
   */

  export type AggregateDocumentProcessingResult = {
    _count: DocumentProcessingResultCountAggregateOutputType | null;
    _avg: DocumentProcessingResultAvgAggregateOutputType | null;
    _sum: DocumentProcessingResultSumAggregateOutputType | null;
    _min: DocumentProcessingResultMinAggregateOutputType | null;
    _max: DocumentProcessingResultMaxAggregateOutputType | null;
  };

  export type DocumentProcessingResultAvgAggregateOutputType = {
    inputTokens: number | null;
    outputTokens: number | null;
    estimatedCost: number | null;
  };

  export type DocumentProcessingResultSumAggregateOutputType = {
    inputTokens: number | null;
    outputTokens: number | null;
    estimatedCost: number | null;
  };

  export type DocumentProcessingResultMinAggregateOutputType = {
    id: string | null;
    processedAt: Date | null;
    aiProvider: string | null;
    inputTokens: number | null;
    outputTokens: number | null;
    estimatedCost: number | null;
    originalTitle: string | null;
    originalCorrespondent: string | null;
    originalDocumentType: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    documentId: string | null;
  };

  export type DocumentProcessingResultMaxAggregateOutputType = {
    id: string | null;
    processedAt: Date | null;
    aiProvider: string | null;
    inputTokens: number | null;
    outputTokens: number | null;
    estimatedCost: number | null;
    originalTitle: string | null;
    originalCorrespondent: string | null;
    originalDocumentType: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    documentId: string | null;
  };

  export type DocumentProcessingResultCountAggregateOutputType = {
    id: number;
    processedAt: number;
    aiProvider: number;
    inputTokens: number;
    outputTokens: number;
    estimatedCost: number;
    changes: number;
    toolCalls: number;
    originalTitle: number;
    originalCorrespondent: number;
    originalDocumentType: number;
    originalTags: number;
    createdAt: number;
    updatedAt: number;
    documentId: number;
    _all: number;
  };

  export type DocumentProcessingResultAvgAggregateInputType = {
    inputTokens?: true;
    outputTokens?: true;
    estimatedCost?: true;
  };

  export type DocumentProcessingResultSumAggregateInputType = {
    inputTokens?: true;
    outputTokens?: true;
    estimatedCost?: true;
  };

  export type DocumentProcessingResultMinAggregateInputType = {
    id?: true;
    processedAt?: true;
    aiProvider?: true;
    inputTokens?: true;
    outputTokens?: true;
    estimatedCost?: true;
    originalTitle?: true;
    originalCorrespondent?: true;
    originalDocumentType?: true;
    createdAt?: true;
    updatedAt?: true;
    documentId?: true;
  };

  export type DocumentProcessingResultMaxAggregateInputType = {
    id?: true;
    processedAt?: true;
    aiProvider?: true;
    inputTokens?: true;
    outputTokens?: true;
    estimatedCost?: true;
    originalTitle?: true;
    originalCorrespondent?: true;
    originalDocumentType?: true;
    createdAt?: true;
    updatedAt?: true;
    documentId?: true;
  };

  export type DocumentProcessingResultCountAggregateInputType = {
    id?: true;
    processedAt?: true;
    aiProvider?: true;
    inputTokens?: true;
    outputTokens?: true;
    estimatedCost?: true;
    changes?: true;
    toolCalls?: true;
    originalTitle?: true;
    originalCorrespondent?: true;
    originalDocumentType?: true;
    originalTags?: true;
    createdAt?: true;
    updatedAt?: true;
    documentId?: true;
    _all?: true;
  };

  export type DocumentProcessingResultAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DocumentProcessingResult to aggregate.
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DocumentProcessingResults to fetch.
     */
    orderBy?:
      | DocumentProcessingResultOrderByWithRelationInput
      | DocumentProcessingResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DocumentProcessingResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DocumentProcessingResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DocumentProcessingResults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DocumentProcessingResults
     **/
    _count?: true | DocumentProcessingResultCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DocumentProcessingResultAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DocumentProcessingResultSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DocumentProcessingResultMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DocumentProcessingResultMaxAggregateInputType;
  };

  export type GetDocumentProcessingResultAggregateType<
    T extends DocumentProcessingResultAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateDocumentProcessingResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentProcessingResult[P]>
      : GetScalarType<T[P], AggregateDocumentProcessingResult[P]>;
  };

  export type DocumentProcessingResultGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DocumentProcessingResultWhereInput;
    orderBy?:
      | DocumentProcessingResultOrderByWithAggregationInput
      | DocumentProcessingResultOrderByWithAggregationInput[];
    by: DocumentProcessingResultScalarFieldEnum[] | DocumentProcessingResultScalarFieldEnum;
    having?: DocumentProcessingResultScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DocumentProcessingResultCountAggregateInputType | true;
    _avg?: DocumentProcessingResultAvgAggregateInputType;
    _sum?: DocumentProcessingResultSumAggregateInputType;
    _min?: DocumentProcessingResultMinAggregateInputType;
    _max?: DocumentProcessingResultMaxAggregateInputType;
  };

  export type DocumentProcessingResultGroupByOutputType = {
    id: string;
    processedAt: Date;
    aiProvider: string;
    inputTokens: number;
    outputTokens: number;
    estimatedCost: number | null;
    changes: JsonValue | null;
    toolCalls: JsonValue | null;
    originalTitle: string | null;
    originalCorrespondent: string | null;
    originalDocumentType: string | null;
    originalTags: string[];
    createdAt: Date;
    updatedAt: Date;
    documentId: string;
    _count: DocumentProcessingResultCountAggregateOutputType | null;
    _avg: DocumentProcessingResultAvgAggregateOutputType | null;
    _sum: DocumentProcessingResultSumAggregateOutputType | null;
    _min: DocumentProcessingResultMinAggregateOutputType | null;
    _max: DocumentProcessingResultMaxAggregateOutputType | null;
  };

  type GetDocumentProcessingResultGroupByPayload<T extends DocumentProcessingResultGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DocumentProcessingResultGroupByOutputType, T['by']> & {
          [P in keyof T & keyof DocumentProcessingResultGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentProcessingResultGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentProcessingResultGroupByOutputType[P]>;
        }
      >
    >;

  export type DocumentProcessingResultSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      processedAt?: boolean;
      aiProvider?: boolean;
      inputTokens?: boolean;
      outputTokens?: boolean;
      estimatedCost?: boolean;
      changes?: boolean;
      toolCalls?: boolean;
      originalTitle?: boolean;
      originalCorrespondent?: boolean;
      originalDocumentType?: boolean;
      originalTags?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      documentId?: boolean;
      document?: boolean | PaperlessDocumentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['documentProcessingResult']
  >;

  export type DocumentProcessingResultSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      processedAt?: boolean;
      aiProvider?: boolean;
      inputTokens?: boolean;
      outputTokens?: boolean;
      estimatedCost?: boolean;
      changes?: boolean;
      toolCalls?: boolean;
      originalTitle?: boolean;
      originalCorrespondent?: boolean;
      originalDocumentType?: boolean;
      originalTags?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      documentId?: boolean;
      document?: boolean | PaperlessDocumentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['documentProcessingResult']
  >;

  export type DocumentProcessingResultSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      processedAt?: boolean;
      aiProvider?: boolean;
      inputTokens?: boolean;
      outputTokens?: boolean;
      estimatedCost?: boolean;
      changes?: boolean;
      toolCalls?: boolean;
      originalTitle?: boolean;
      originalCorrespondent?: boolean;
      originalDocumentType?: boolean;
      originalTags?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      documentId?: boolean;
      document?: boolean | PaperlessDocumentDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['documentProcessingResult']
  >;

  export type DocumentProcessingResultSelectScalar = {
    id?: boolean;
    processedAt?: boolean;
    aiProvider?: boolean;
    inputTokens?: boolean;
    outputTokens?: boolean;
    estimatedCost?: boolean;
    changes?: boolean;
    toolCalls?: boolean;
    originalTitle?: boolean;
    originalCorrespondent?: boolean;
    originalDocumentType?: boolean;
    originalTags?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    documentId?: boolean;
  };

  export type DocumentProcessingResultOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'processedAt'
    | 'aiProvider'
    | 'inputTokens'
    | 'outputTokens'
    | 'estimatedCost'
    | 'changes'
    | 'toolCalls'
    | 'originalTitle'
    | 'originalCorrespondent'
    | 'originalDocumentType'
    | 'originalTags'
    | 'createdAt'
    | 'updatedAt'
    | 'documentId',
    ExtArgs['result']['documentProcessingResult']
  >;
  export type DocumentProcessingResultInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    document?: boolean | PaperlessDocumentDefaultArgs<ExtArgs>;
  };
  export type DocumentProcessingResultIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    document?: boolean | PaperlessDocumentDefaultArgs<ExtArgs>;
  };
  export type DocumentProcessingResultIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    document?: boolean | PaperlessDocumentDefaultArgs<ExtArgs>;
  };

  export type $DocumentProcessingResultPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DocumentProcessingResult';
    objects: {
      document: Prisma.$PaperlessDocumentPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        processedAt: Date;
        aiProvider: string;
        inputTokens: number;
        outputTokens: number;
        estimatedCost: number | null;
        changes: Prisma.JsonValue | null;
        toolCalls: Prisma.JsonValue | null;
        originalTitle: string | null;
        originalCorrespondent: string | null;
        originalDocumentType: string | null;
        originalTags: string[];
        createdAt: Date;
        updatedAt: Date;
        documentId: string;
      },
      ExtArgs['result']['documentProcessingResult']
    >;
    composites: {};
  };

  type DocumentProcessingResultGetPayload<
    S extends boolean | null | undefined | DocumentProcessingResultDefaultArgs,
  > = $Result.GetResult<Prisma.$DocumentProcessingResultPayload, S>;

  type DocumentProcessingResultCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<DocumentProcessingResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: DocumentProcessingResultCountAggregateInputType | true;
  };

  export interface DocumentProcessingResultDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DocumentProcessingResult'];
      meta: { name: 'DocumentProcessingResult' };
    };
    /**
     * Find zero or one DocumentProcessingResult that matches the filter.
     * @param {DocumentProcessingResultFindUniqueArgs} args - Arguments to find a DocumentProcessingResult
     * @example
     * // Get one DocumentProcessingResult
     * const documentProcessingResult = await prisma.documentProcessingResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentProcessingResultFindUniqueArgs>(
      args: SelectSubset<T, DocumentProcessingResultFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one DocumentProcessingResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentProcessingResultFindUniqueOrThrowArgs} args - Arguments to find a DocumentProcessingResult
     * @example
     * // Get one DocumentProcessingResult
     * const documentProcessingResult = await prisma.documentProcessingResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentProcessingResultFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DocumentProcessingResultFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DocumentProcessingResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultFindFirstArgs} args - Arguments to find a DocumentProcessingResult
     * @example
     * // Get one DocumentProcessingResult
     * const documentProcessingResult = await prisma.documentProcessingResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentProcessingResultFindFirstArgs>(
      args?: SelectSubset<T, DocumentProcessingResultFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first DocumentProcessingResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultFindFirstOrThrowArgs} args - Arguments to find a DocumentProcessingResult
     * @example
     * // Get one DocumentProcessingResult
     * const documentProcessingResult = await prisma.documentProcessingResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentProcessingResultFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DocumentProcessingResultFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more DocumentProcessingResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentProcessingResults
     * const documentProcessingResults = await prisma.documentProcessingResult.findMany()
     *
     * // Get first 10 DocumentProcessingResults
     * const documentProcessingResults = await prisma.documentProcessingResult.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const documentProcessingResultWithIdOnly = await prisma.documentProcessingResult.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DocumentProcessingResultFindManyArgs>(
      args?: SelectSubset<T, DocumentProcessingResultFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a DocumentProcessingResult.
     * @param {DocumentProcessingResultCreateArgs} args - Arguments to create a DocumentProcessingResult.
     * @example
     * // Create one DocumentProcessingResult
     * const DocumentProcessingResult = await prisma.documentProcessingResult.create({
     *   data: {
     *     // ... data to create a DocumentProcessingResult
     *   }
     * })
     *
     */
    create<T extends DocumentProcessingResultCreateArgs>(
      args: SelectSubset<T, DocumentProcessingResultCreateArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many DocumentProcessingResults.
     * @param {DocumentProcessingResultCreateManyArgs} args - Arguments to create many DocumentProcessingResults.
     * @example
     * // Create many DocumentProcessingResults
     * const documentProcessingResult = await prisma.documentProcessingResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DocumentProcessingResultCreateManyArgs>(
      args?: SelectSubset<T, DocumentProcessingResultCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DocumentProcessingResults and returns the data saved in the database.
     * @param {DocumentProcessingResultCreateManyAndReturnArgs} args - Arguments to create many DocumentProcessingResults.
     * @example
     * // Create many DocumentProcessingResults
     * const documentProcessingResult = await prisma.documentProcessingResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DocumentProcessingResults and only return the `id`
     * const documentProcessingResultWithIdOnly = await prisma.documentProcessingResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DocumentProcessingResultCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DocumentProcessingResultCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a DocumentProcessingResult.
     * @param {DocumentProcessingResultDeleteArgs} args - Arguments to delete one DocumentProcessingResult.
     * @example
     * // Delete one DocumentProcessingResult
     * const DocumentProcessingResult = await prisma.documentProcessingResult.delete({
     *   where: {
     *     // ... filter to delete one DocumentProcessingResult
     *   }
     * })
     *
     */
    delete<T extends DocumentProcessingResultDeleteArgs>(
      args: SelectSubset<T, DocumentProcessingResultDeleteArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one DocumentProcessingResult.
     * @param {DocumentProcessingResultUpdateArgs} args - Arguments to update one DocumentProcessingResult.
     * @example
     * // Update one DocumentProcessingResult
     * const documentProcessingResult = await prisma.documentProcessingResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DocumentProcessingResultUpdateArgs>(
      args: SelectSubset<T, DocumentProcessingResultUpdateArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more DocumentProcessingResults.
     * @param {DocumentProcessingResultDeleteManyArgs} args - Arguments to filter DocumentProcessingResults to delete.
     * @example
     * // Delete a few DocumentProcessingResults
     * const { count } = await prisma.documentProcessingResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DocumentProcessingResultDeleteManyArgs>(
      args?: SelectSubset<T, DocumentProcessingResultDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DocumentProcessingResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentProcessingResults
     * const documentProcessingResult = await prisma.documentProcessingResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DocumentProcessingResultUpdateManyArgs>(
      args: SelectSubset<T, DocumentProcessingResultUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DocumentProcessingResults and returns the data updated in the database.
     * @param {DocumentProcessingResultUpdateManyAndReturnArgs} args - Arguments to update many DocumentProcessingResults.
     * @example
     * // Update many DocumentProcessingResults
     * const documentProcessingResult = await prisma.documentProcessingResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more DocumentProcessingResults and only return the `id`
     * const documentProcessingResultWithIdOnly = await prisma.documentProcessingResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends DocumentProcessingResultUpdateManyAndReturnArgs>(
      args: SelectSubset<T, DocumentProcessingResultUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one DocumentProcessingResult.
     * @param {DocumentProcessingResultUpsertArgs} args - Arguments to update or create a DocumentProcessingResult.
     * @example
     * // Update or create a DocumentProcessingResult
     * const documentProcessingResult = await prisma.documentProcessingResult.upsert({
     *   create: {
     *     // ... data to create a DocumentProcessingResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentProcessingResult we want to update
     *   }
     * })
     */
    upsert<T extends DocumentProcessingResultUpsertArgs>(
      args: SelectSubset<T, DocumentProcessingResultUpsertArgs<ExtArgs>>
    ): Prisma__DocumentProcessingResultClient<
      $Result.GetResult<
        Prisma.$DocumentProcessingResultPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of DocumentProcessingResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultCountArgs} args - Arguments to filter DocumentProcessingResults to count.
     * @example
     * // Count the number of DocumentProcessingResults
     * const count = await prisma.documentProcessingResult.count({
     *   where: {
     *     // ... the filter for the DocumentProcessingResults we want to count
     *   }
     * })
     **/
    count<T extends DocumentProcessingResultCountArgs>(
      args?: Subset<T, DocumentProcessingResultCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentProcessingResultCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DocumentProcessingResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DocumentProcessingResultAggregateArgs>(
      args: Subset<T, DocumentProcessingResultAggregateArgs>
    ): Prisma.PrismaPromise<GetDocumentProcessingResultAggregateType<T>>;

    /**
     * Group by DocumentProcessingResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentProcessingResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DocumentProcessingResultGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentProcessingResultGroupByArgs['orderBy'] }
        : { orderBy?: DocumentProcessingResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DocumentProcessingResultGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetDocumentProcessingResultGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DocumentProcessingResult model
     */
    readonly fields: DocumentProcessingResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentProcessingResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentProcessingResultClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    document<T extends PaperlessDocumentDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessDocumentDefaultArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      | $Result.GetResult<
          Prisma.$PaperlessDocumentPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DocumentProcessingResult model
   */
  interface DocumentProcessingResultFieldRefs {
    readonly id: FieldRef<'DocumentProcessingResult', 'String'>;
    readonly processedAt: FieldRef<'DocumentProcessingResult', 'DateTime'>;
    readonly aiProvider: FieldRef<'DocumentProcessingResult', 'String'>;
    readonly inputTokens: FieldRef<'DocumentProcessingResult', 'Int'>;
    readonly outputTokens: FieldRef<'DocumentProcessingResult', 'Int'>;
    readonly estimatedCost: FieldRef<'DocumentProcessingResult', 'Float'>;
    readonly changes: FieldRef<'DocumentProcessingResult', 'Json'>;
    readonly toolCalls: FieldRef<'DocumentProcessingResult', 'Json'>;
    readonly originalTitle: FieldRef<'DocumentProcessingResult', 'String'>;
    readonly originalCorrespondent: FieldRef<'DocumentProcessingResult', 'String'>;
    readonly originalDocumentType: FieldRef<'DocumentProcessingResult', 'String'>;
    readonly originalTags: FieldRef<'DocumentProcessingResult', 'String[]'>;
    readonly createdAt: FieldRef<'DocumentProcessingResult', 'DateTime'>;
    readonly updatedAt: FieldRef<'DocumentProcessingResult', 'DateTime'>;
    readonly documentId: FieldRef<'DocumentProcessingResult', 'String'>;
  }

  // Custom InputTypes
  /**
   * DocumentProcessingResult findUnique
   */
  export type DocumentProcessingResultFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * Filter, which DocumentProcessingResult to fetch.
     */
    where: DocumentProcessingResultWhereUniqueInput;
  };

  /**
   * DocumentProcessingResult findUniqueOrThrow
   */
  export type DocumentProcessingResultFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * Filter, which DocumentProcessingResult to fetch.
     */
    where: DocumentProcessingResultWhereUniqueInput;
  };

  /**
   * DocumentProcessingResult findFirst
   */
  export type DocumentProcessingResultFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * Filter, which DocumentProcessingResult to fetch.
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DocumentProcessingResults to fetch.
     */
    orderBy?:
      | DocumentProcessingResultOrderByWithRelationInput
      | DocumentProcessingResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DocumentProcessingResults.
     */
    cursor?: DocumentProcessingResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DocumentProcessingResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DocumentProcessingResults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DocumentProcessingResults.
     */
    distinct?: DocumentProcessingResultScalarFieldEnum | DocumentProcessingResultScalarFieldEnum[];
  };

  /**
   * DocumentProcessingResult findFirstOrThrow
   */
  export type DocumentProcessingResultFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * Filter, which DocumentProcessingResult to fetch.
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DocumentProcessingResults to fetch.
     */
    orderBy?:
      | DocumentProcessingResultOrderByWithRelationInput
      | DocumentProcessingResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DocumentProcessingResults.
     */
    cursor?: DocumentProcessingResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DocumentProcessingResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DocumentProcessingResults.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DocumentProcessingResults.
     */
    distinct?: DocumentProcessingResultScalarFieldEnum | DocumentProcessingResultScalarFieldEnum[];
  };

  /**
   * DocumentProcessingResult findMany
   */
  export type DocumentProcessingResultFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * Filter, which DocumentProcessingResults to fetch.
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DocumentProcessingResults to fetch.
     */
    orderBy?:
      | DocumentProcessingResultOrderByWithRelationInput
      | DocumentProcessingResultOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DocumentProcessingResults.
     */
    cursor?: DocumentProcessingResultWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DocumentProcessingResults from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DocumentProcessingResults.
     */
    skip?: number;
    distinct?: DocumentProcessingResultScalarFieldEnum | DocumentProcessingResultScalarFieldEnum[];
  };

  /**
   * DocumentProcessingResult create
   */
  export type DocumentProcessingResultCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * The data needed to create a DocumentProcessingResult.
     */
    data: XOR<DocumentProcessingResultCreateInput, DocumentProcessingResultUncheckedCreateInput>;
  };

  /**
   * DocumentProcessingResult createMany
   */
  export type DocumentProcessingResultCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DocumentProcessingResults.
     */
    data: DocumentProcessingResultCreateManyInput | DocumentProcessingResultCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DocumentProcessingResult createManyAndReturn
   */
  export type DocumentProcessingResultCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * The data used to create many DocumentProcessingResults.
     */
    data: DocumentProcessingResultCreateManyInput | DocumentProcessingResultCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DocumentProcessingResult update
   */
  export type DocumentProcessingResultUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * The data needed to update a DocumentProcessingResult.
     */
    data: XOR<DocumentProcessingResultUpdateInput, DocumentProcessingResultUncheckedUpdateInput>;
    /**
     * Choose, which DocumentProcessingResult to update.
     */
    where: DocumentProcessingResultWhereUniqueInput;
  };

  /**
   * DocumentProcessingResult updateMany
   */
  export type DocumentProcessingResultUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DocumentProcessingResults.
     */
    data: XOR<
      DocumentProcessingResultUpdateManyMutationInput,
      DocumentProcessingResultUncheckedUpdateManyInput
    >;
    /**
     * Filter which DocumentProcessingResults to update
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * Limit how many DocumentProcessingResults to update.
     */
    limit?: number;
  };

  /**
   * DocumentProcessingResult updateManyAndReturn
   */
  export type DocumentProcessingResultUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * The data used to update DocumentProcessingResults.
     */
    data: XOR<
      DocumentProcessingResultUpdateManyMutationInput,
      DocumentProcessingResultUncheckedUpdateManyInput
    >;
    /**
     * Filter which DocumentProcessingResults to update
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * Limit how many DocumentProcessingResults to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DocumentProcessingResult upsert
   */
  export type DocumentProcessingResultUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * The filter to search for the DocumentProcessingResult to update in case it exists.
     */
    where: DocumentProcessingResultWhereUniqueInput;
    /**
     * In case the DocumentProcessingResult found by the `where` argument doesn't exist, create a new DocumentProcessingResult with this data.
     */
    create: XOR<DocumentProcessingResultCreateInput, DocumentProcessingResultUncheckedCreateInput>;
    /**
     * In case the DocumentProcessingResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentProcessingResultUpdateInput, DocumentProcessingResultUncheckedUpdateInput>;
  };

  /**
   * DocumentProcessingResult delete
   */
  export type DocumentProcessingResultDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
    /**
     * Filter which DocumentProcessingResult to delete.
     */
    where: DocumentProcessingResultWhereUniqueInput;
  };

  /**
   * DocumentProcessingResult deleteMany
   */
  export type DocumentProcessingResultDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DocumentProcessingResults to delete
     */
    where?: DocumentProcessingResultWhereInput;
    /**
     * Limit how many DocumentProcessingResults to delete.
     */
    limit?: number;
  };

  /**
   * DocumentProcessingResult without action
   */
  export type DocumentProcessingResultDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DocumentProcessingResult
     */
    select?: DocumentProcessingResultSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the DocumentProcessingResult
     */
    omit?: DocumentProcessingResultOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentProcessingResultInclude<ExtArgs> | null;
  };

  /**
   * Model ProcessingQueue
   */

  export type AggregateProcessingQueue = {
    _count: ProcessingQueueCountAggregateOutputType | null;
    _avg: ProcessingQueueAvgAggregateOutputType | null;
    _sum: ProcessingQueueSumAggregateOutputType | null;
    _min: ProcessingQueueMinAggregateOutputType | null;
    _max: ProcessingQueueMaxAggregateOutputType | null;
  };

  export type ProcessingQueueAvgAggregateOutputType = {
    paperlessDocumentId: number | null;
    priority: number | null;
    attempts: number | null;
    maxAttempts: number | null;
  };

  export type ProcessingQueueSumAggregateOutputType = {
    paperlessDocumentId: number | null;
    priority: number | null;
    attempts: number | null;
    maxAttempts: number | null;
  };

  export type ProcessingQueueMinAggregateOutputType = {
    id: string | null;
    paperlessDocumentId: number | null;
    status: string | null;
    priority: number | null;
    attempts: number | null;
    maxAttempts: number | null;
    lastError: string | null;
    scheduledFor: Date | null;
    startedAt: Date | null;
    completedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    paperlessInstanceId: string | null;
    documentId: string | null;
    aiBotId: string | null;
  };

  export type ProcessingQueueMaxAggregateOutputType = {
    id: string | null;
    paperlessDocumentId: number | null;
    status: string | null;
    priority: number | null;
    attempts: number | null;
    maxAttempts: number | null;
    lastError: string | null;
    scheduledFor: Date | null;
    startedAt: Date | null;
    completedAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    paperlessInstanceId: string | null;
    documentId: string | null;
    aiBotId: string | null;
  };

  export type ProcessingQueueCountAggregateOutputType = {
    id: number;
    paperlessDocumentId: number;
    status: number;
    priority: number;
    attempts: number;
    maxAttempts: number;
    lastError: number;
    scheduledFor: number;
    startedAt: number;
    completedAt: number;
    createdAt: number;
    updatedAt: number;
    paperlessInstanceId: number;
    documentId: number;
    aiBotId: number;
    _all: number;
  };

  export type ProcessingQueueAvgAggregateInputType = {
    paperlessDocumentId?: true;
    priority?: true;
    attempts?: true;
    maxAttempts?: true;
  };

  export type ProcessingQueueSumAggregateInputType = {
    paperlessDocumentId?: true;
    priority?: true;
    attempts?: true;
    maxAttempts?: true;
  };

  export type ProcessingQueueMinAggregateInputType = {
    id?: true;
    paperlessDocumentId?: true;
    status?: true;
    priority?: true;
    attempts?: true;
    maxAttempts?: true;
    lastError?: true;
    scheduledFor?: true;
    startedAt?: true;
    completedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    paperlessInstanceId?: true;
    documentId?: true;
    aiBotId?: true;
  };

  export type ProcessingQueueMaxAggregateInputType = {
    id?: true;
    paperlessDocumentId?: true;
    status?: true;
    priority?: true;
    attempts?: true;
    maxAttempts?: true;
    lastError?: true;
    scheduledFor?: true;
    startedAt?: true;
    completedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    paperlessInstanceId?: true;
    documentId?: true;
    aiBotId?: true;
  };

  export type ProcessingQueueCountAggregateInputType = {
    id?: true;
    paperlessDocumentId?: true;
    status?: true;
    priority?: true;
    attempts?: true;
    maxAttempts?: true;
    lastError?: true;
    scheduledFor?: true;
    startedAt?: true;
    completedAt?: true;
    createdAt?: true;
    updatedAt?: true;
    paperlessInstanceId?: true;
    documentId?: true;
    aiBotId?: true;
    _all?: true;
  };

  export type ProcessingQueueAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProcessingQueue to aggregate.
     */
    where?: ProcessingQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProcessingQueues to fetch.
     */
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ProcessingQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProcessingQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProcessingQueues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ProcessingQueues
     **/
    _count?: true | ProcessingQueueCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ProcessingQueueAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ProcessingQueueSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ProcessingQueueMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ProcessingQueueMaxAggregateInputType;
  };

  export type GetProcessingQueueAggregateType<T extends ProcessingQueueAggregateArgs> = {
    [P in keyof T & keyof AggregateProcessingQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProcessingQueue[P]>
      : GetScalarType<T[P], AggregateProcessingQueue[P]>;
  };

  export type ProcessingQueueGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ProcessingQueueWhereInput;
    orderBy?:
      | ProcessingQueueOrderByWithAggregationInput
      | ProcessingQueueOrderByWithAggregationInput[];
    by: ProcessingQueueScalarFieldEnum[] | ProcessingQueueScalarFieldEnum;
    having?: ProcessingQueueScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ProcessingQueueCountAggregateInputType | true;
    _avg?: ProcessingQueueAvgAggregateInputType;
    _sum?: ProcessingQueueSumAggregateInputType;
    _min?: ProcessingQueueMinAggregateInputType;
    _max?: ProcessingQueueMaxAggregateInputType;
  };

  export type ProcessingQueueGroupByOutputType = {
    id: string;
    paperlessDocumentId: number;
    status: string;
    priority: number;
    attempts: number;
    maxAttempts: number;
    lastError: string | null;
    scheduledFor: Date;
    startedAt: Date | null;
    completedAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    paperlessInstanceId: string;
    documentId: string | null;
    aiBotId: string | null;
    _count: ProcessingQueueCountAggregateOutputType | null;
    _avg: ProcessingQueueAvgAggregateOutputType | null;
    _sum: ProcessingQueueSumAggregateOutputType | null;
    _min: ProcessingQueueMinAggregateOutputType | null;
    _max: ProcessingQueueMaxAggregateOutputType | null;
  };

  type GetProcessingQueueGroupByPayload<T extends ProcessingQueueGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ProcessingQueueGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ProcessingQueueGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcessingQueueGroupByOutputType[P]>
            : GetScalarType<T[P], ProcessingQueueGroupByOutputType[P]>;
        }
      >
    >;

  export type ProcessingQueueSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paperlessDocumentId?: boolean;
      status?: boolean;
      priority?: boolean;
      attempts?: boolean;
      maxAttempts?: boolean;
      lastError?: boolean;
      scheduledFor?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paperlessInstanceId?: boolean;
      documentId?: boolean;
      aiBotId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
      document?: boolean | ProcessingQueue$documentArgs<ExtArgs>;
      aiBot?: boolean | ProcessingQueue$aiBotArgs<ExtArgs>;
    },
    ExtArgs['result']['processingQueue']
  >;

  export type ProcessingQueueSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paperlessDocumentId?: boolean;
      status?: boolean;
      priority?: boolean;
      attempts?: boolean;
      maxAttempts?: boolean;
      lastError?: boolean;
      scheduledFor?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paperlessInstanceId?: boolean;
      documentId?: boolean;
      aiBotId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
      document?: boolean | ProcessingQueue$documentArgs<ExtArgs>;
      aiBot?: boolean | ProcessingQueue$aiBotArgs<ExtArgs>;
    },
    ExtArgs['result']['processingQueue']
  >;

  export type ProcessingQueueSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      paperlessDocumentId?: boolean;
      status?: boolean;
      priority?: boolean;
      attempts?: boolean;
      maxAttempts?: boolean;
      lastError?: boolean;
      scheduledFor?: boolean;
      startedAt?: boolean;
      completedAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      paperlessInstanceId?: boolean;
      documentId?: boolean;
      aiBotId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
      document?: boolean | ProcessingQueue$documentArgs<ExtArgs>;
      aiBot?: boolean | ProcessingQueue$aiBotArgs<ExtArgs>;
    },
    ExtArgs['result']['processingQueue']
  >;

  export type ProcessingQueueSelectScalar = {
    id?: boolean;
    paperlessDocumentId?: boolean;
    status?: boolean;
    priority?: boolean;
    attempts?: boolean;
    maxAttempts?: boolean;
    lastError?: boolean;
    scheduledFor?: boolean;
    startedAt?: boolean;
    completedAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    paperlessInstanceId?: boolean;
    documentId?: boolean;
    aiBotId?: boolean;
  };

  export type ProcessingQueueOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'paperlessDocumentId'
    | 'status'
    | 'priority'
    | 'attempts'
    | 'maxAttempts'
    | 'lastError'
    | 'scheduledFor'
    | 'startedAt'
    | 'completedAt'
    | 'createdAt'
    | 'updatedAt'
    | 'paperlessInstanceId'
    | 'documentId'
    | 'aiBotId',
    ExtArgs['result']['processingQueue']
  >;
  export type ProcessingQueueInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    document?: boolean | ProcessingQueue$documentArgs<ExtArgs>;
    aiBot?: boolean | ProcessingQueue$aiBotArgs<ExtArgs>;
  };
  export type ProcessingQueueIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    document?: boolean | ProcessingQueue$documentArgs<ExtArgs>;
    aiBot?: boolean | ProcessingQueue$aiBotArgs<ExtArgs>;
  };
  export type ProcessingQueueIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    document?: boolean | ProcessingQueue$documentArgs<ExtArgs>;
    aiBot?: boolean | ProcessingQueue$aiBotArgs<ExtArgs>;
  };

  export type $ProcessingQueuePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ProcessingQueue';
    objects: {
      paperlessInstance: Prisma.$PaperlessInstancePayload<ExtArgs>;
      document: Prisma.$PaperlessDocumentPayload<ExtArgs> | null;
      aiBot: Prisma.$AiBotPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        paperlessDocumentId: number;
        status: string;
        priority: number;
        attempts: number;
        maxAttempts: number;
        lastError: string | null;
        scheduledFor: Date;
        startedAt: Date | null;
        completedAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
        paperlessInstanceId: string;
        documentId: string | null;
        aiBotId: string | null;
      },
      ExtArgs['result']['processingQueue']
    >;
    composites: {};
  };

  type ProcessingQueueGetPayload<
    S extends boolean | null | undefined | ProcessingQueueDefaultArgs,
  > = $Result.GetResult<Prisma.$ProcessingQueuePayload, S>;

  type ProcessingQueueCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ProcessingQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ProcessingQueueCountAggregateInputType | true;
  };

  export interface ProcessingQueueDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ProcessingQueue'];
      meta: { name: 'ProcessingQueue' };
    };
    /**
     * Find zero or one ProcessingQueue that matches the filter.
     * @param {ProcessingQueueFindUniqueArgs} args - Arguments to find a ProcessingQueue
     * @example
     * // Get one ProcessingQueue
     * const processingQueue = await prisma.processingQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcessingQueueFindUniqueArgs>(
      args: SelectSubset<T, ProcessingQueueFindUniqueArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<
        Prisma.$ProcessingQueuePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ProcessingQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProcessingQueueFindUniqueOrThrowArgs} args - Arguments to find a ProcessingQueue
     * @example
     * // Get one ProcessingQueue
     * const processingQueue = await prisma.processingQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcessingQueueFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ProcessingQueueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<
        Prisma.$ProcessingQueuePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProcessingQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueFindFirstArgs} args - Arguments to find a ProcessingQueue
     * @example
     * // Get one ProcessingQueue
     * const processingQueue = await prisma.processingQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcessingQueueFindFirstArgs>(
      args?: SelectSubset<T, ProcessingQueueFindFirstArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<
        Prisma.$ProcessingQueuePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ProcessingQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueFindFirstOrThrowArgs} args - Arguments to find a ProcessingQueue
     * @example
     * // Get one ProcessingQueue
     * const processingQueue = await prisma.processingQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcessingQueueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ProcessingQueueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<
        Prisma.$ProcessingQueuePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ProcessingQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProcessingQueues
     * const processingQueues = await prisma.processingQueue.findMany()
     *
     * // Get first 10 ProcessingQueues
     * const processingQueues = await prisma.processingQueue.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const processingQueueWithIdOnly = await prisma.processingQueue.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ProcessingQueueFindManyArgs>(
      args?: SelectSubset<T, ProcessingQueueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ProcessingQueue.
     * @param {ProcessingQueueCreateArgs} args - Arguments to create a ProcessingQueue.
     * @example
     * // Create one ProcessingQueue
     * const ProcessingQueue = await prisma.processingQueue.create({
     *   data: {
     *     // ... data to create a ProcessingQueue
     *   }
     * })
     *
     */
    create<T extends ProcessingQueueCreateArgs>(
      args: SelectSubset<T, ProcessingQueueCreateArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ProcessingQueues.
     * @param {ProcessingQueueCreateManyArgs} args - Arguments to create many ProcessingQueues.
     * @example
     * // Create many ProcessingQueues
     * const processingQueue = await prisma.processingQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ProcessingQueueCreateManyArgs>(
      args?: SelectSubset<T, ProcessingQueueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ProcessingQueues and returns the data saved in the database.
     * @param {ProcessingQueueCreateManyAndReturnArgs} args - Arguments to create many ProcessingQueues.
     * @example
     * // Create many ProcessingQueues
     * const processingQueue = await prisma.processingQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ProcessingQueues and only return the `id`
     * const processingQueueWithIdOnly = await prisma.processingQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ProcessingQueueCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ProcessingQueueCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProcessingQueuePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ProcessingQueue.
     * @param {ProcessingQueueDeleteArgs} args - Arguments to delete one ProcessingQueue.
     * @example
     * // Delete one ProcessingQueue
     * const ProcessingQueue = await prisma.processingQueue.delete({
     *   where: {
     *     // ... filter to delete one ProcessingQueue
     *   }
     * })
     *
     */
    delete<T extends ProcessingQueueDeleteArgs>(
      args: SelectSubset<T, ProcessingQueueDeleteArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ProcessingQueue.
     * @param {ProcessingQueueUpdateArgs} args - Arguments to update one ProcessingQueue.
     * @example
     * // Update one ProcessingQueue
     * const processingQueue = await prisma.processingQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ProcessingQueueUpdateArgs>(
      args: SelectSubset<T, ProcessingQueueUpdateArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ProcessingQueues.
     * @param {ProcessingQueueDeleteManyArgs} args - Arguments to filter ProcessingQueues to delete.
     * @example
     * // Delete a few ProcessingQueues
     * const { count } = await prisma.processingQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ProcessingQueueDeleteManyArgs>(
      args?: SelectSubset<T, ProcessingQueueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProcessingQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProcessingQueues
     * const processingQueue = await prisma.processingQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ProcessingQueueUpdateManyArgs>(
      args: SelectSubset<T, ProcessingQueueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ProcessingQueues and returns the data updated in the database.
     * @param {ProcessingQueueUpdateManyAndReturnArgs} args - Arguments to update many ProcessingQueues.
     * @example
     * // Update many ProcessingQueues
     * const processingQueue = await prisma.processingQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ProcessingQueues and only return the `id`
     * const processingQueueWithIdOnly = await prisma.processingQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ProcessingQueueUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ProcessingQueueUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ProcessingQueuePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ProcessingQueue.
     * @param {ProcessingQueueUpsertArgs} args - Arguments to update or create a ProcessingQueue.
     * @example
     * // Update or create a ProcessingQueue
     * const processingQueue = await prisma.processingQueue.upsert({
     *   create: {
     *     // ... data to create a ProcessingQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProcessingQueue we want to update
     *   }
     * })
     */
    upsert<T extends ProcessingQueueUpsertArgs>(
      args: SelectSubset<T, ProcessingQueueUpsertArgs<ExtArgs>>
    ): Prisma__ProcessingQueueClient<
      $Result.GetResult<Prisma.$ProcessingQueuePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ProcessingQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueCountArgs} args - Arguments to filter ProcessingQueues to count.
     * @example
     * // Count the number of ProcessingQueues
     * const count = await prisma.processingQueue.count({
     *   where: {
     *     // ... the filter for the ProcessingQueues we want to count
     *   }
     * })
     **/
    count<T extends ProcessingQueueCountArgs>(
      args?: Subset<T, ProcessingQueueCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcessingQueueCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ProcessingQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ProcessingQueueAggregateArgs>(
      args: Subset<T, ProcessingQueueAggregateArgs>
    ): Prisma.PrismaPromise<GetProcessingQueueAggregateType<T>>;

    /**
     * Group by ProcessingQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcessingQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ProcessingQueueGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcessingQueueGroupByArgs['orderBy'] }
        : { orderBy?: ProcessingQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ProcessingQueueGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetProcessingQueueGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ProcessingQueue model
     */
    readonly fields: ProcessingQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProcessingQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcessingQueueClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    paperlessInstance<T extends PaperlessInstanceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstanceDefaultArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      | $Result.GetResult<
          Prisma.$PaperlessInstancePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    document<T extends ProcessingQueue$documentArgs<ExtArgs> = {}>(
      args?: Subset<T, ProcessingQueue$documentArgs<ExtArgs>>
    ): Prisma__PaperlessDocumentClient<
      $Result.GetResult<
        Prisma.$PaperlessDocumentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiBot<T extends ProcessingQueue$aiBotArgs<ExtArgs> = {}>(
      args?: Subset<T, ProcessingQueue$aiBotArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<
        Prisma.$AiBotPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ProcessingQueue model
   */
  interface ProcessingQueueFieldRefs {
    readonly id: FieldRef<'ProcessingQueue', 'String'>;
    readonly paperlessDocumentId: FieldRef<'ProcessingQueue', 'Int'>;
    readonly status: FieldRef<'ProcessingQueue', 'String'>;
    readonly priority: FieldRef<'ProcessingQueue', 'Int'>;
    readonly attempts: FieldRef<'ProcessingQueue', 'Int'>;
    readonly maxAttempts: FieldRef<'ProcessingQueue', 'Int'>;
    readonly lastError: FieldRef<'ProcessingQueue', 'String'>;
    readonly scheduledFor: FieldRef<'ProcessingQueue', 'DateTime'>;
    readonly startedAt: FieldRef<'ProcessingQueue', 'DateTime'>;
    readonly completedAt: FieldRef<'ProcessingQueue', 'DateTime'>;
    readonly createdAt: FieldRef<'ProcessingQueue', 'DateTime'>;
    readonly updatedAt: FieldRef<'ProcessingQueue', 'DateTime'>;
    readonly paperlessInstanceId: FieldRef<'ProcessingQueue', 'String'>;
    readonly documentId: FieldRef<'ProcessingQueue', 'String'>;
    readonly aiBotId: FieldRef<'ProcessingQueue', 'String'>;
  }

  // Custom InputTypes
  /**
   * ProcessingQueue findUnique
   */
  export type ProcessingQueueFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * Filter, which ProcessingQueue to fetch.
     */
    where: ProcessingQueueWhereUniqueInput;
  };

  /**
   * ProcessingQueue findUniqueOrThrow
   */
  export type ProcessingQueueFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * Filter, which ProcessingQueue to fetch.
     */
    where: ProcessingQueueWhereUniqueInput;
  };

  /**
   * ProcessingQueue findFirst
   */
  export type ProcessingQueueFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * Filter, which ProcessingQueue to fetch.
     */
    where?: ProcessingQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProcessingQueues to fetch.
     */
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProcessingQueues.
     */
    cursor?: ProcessingQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProcessingQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProcessingQueues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProcessingQueues.
     */
    distinct?: ProcessingQueueScalarFieldEnum | ProcessingQueueScalarFieldEnum[];
  };

  /**
   * ProcessingQueue findFirstOrThrow
   */
  export type ProcessingQueueFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * Filter, which ProcessingQueue to fetch.
     */
    where?: ProcessingQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProcessingQueues to fetch.
     */
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ProcessingQueues.
     */
    cursor?: ProcessingQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProcessingQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProcessingQueues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ProcessingQueues.
     */
    distinct?: ProcessingQueueScalarFieldEnum | ProcessingQueueScalarFieldEnum[];
  };

  /**
   * ProcessingQueue findMany
   */
  export type ProcessingQueueFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * Filter, which ProcessingQueues to fetch.
     */
    where?: ProcessingQueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ProcessingQueues to fetch.
     */
    orderBy?: ProcessingQueueOrderByWithRelationInput | ProcessingQueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ProcessingQueues.
     */
    cursor?: ProcessingQueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ProcessingQueues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ProcessingQueues.
     */
    skip?: number;
    distinct?: ProcessingQueueScalarFieldEnum | ProcessingQueueScalarFieldEnum[];
  };

  /**
   * ProcessingQueue create
   */
  export type ProcessingQueueCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * The data needed to create a ProcessingQueue.
     */
    data: XOR<ProcessingQueueCreateInput, ProcessingQueueUncheckedCreateInput>;
  };

  /**
   * ProcessingQueue createMany
   */
  export type ProcessingQueueCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ProcessingQueues.
     */
    data: ProcessingQueueCreateManyInput | ProcessingQueueCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ProcessingQueue createManyAndReturn
   */
  export type ProcessingQueueCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * The data used to create many ProcessingQueues.
     */
    data: ProcessingQueueCreateManyInput | ProcessingQueueCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ProcessingQueue update
   */
  export type ProcessingQueueUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * The data needed to update a ProcessingQueue.
     */
    data: XOR<ProcessingQueueUpdateInput, ProcessingQueueUncheckedUpdateInput>;
    /**
     * Choose, which ProcessingQueue to update.
     */
    where: ProcessingQueueWhereUniqueInput;
  };

  /**
   * ProcessingQueue updateMany
   */
  export type ProcessingQueueUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ProcessingQueues.
     */
    data: XOR<ProcessingQueueUpdateManyMutationInput, ProcessingQueueUncheckedUpdateManyInput>;
    /**
     * Filter which ProcessingQueues to update
     */
    where?: ProcessingQueueWhereInput;
    /**
     * Limit how many ProcessingQueues to update.
     */
    limit?: number;
  };

  /**
   * ProcessingQueue updateManyAndReturn
   */
  export type ProcessingQueueUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * The data used to update ProcessingQueues.
     */
    data: XOR<ProcessingQueueUpdateManyMutationInput, ProcessingQueueUncheckedUpdateManyInput>;
    /**
     * Filter which ProcessingQueues to update
     */
    where?: ProcessingQueueWhereInput;
    /**
     * Limit how many ProcessingQueues to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ProcessingQueue upsert
   */
  export type ProcessingQueueUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * The filter to search for the ProcessingQueue to update in case it exists.
     */
    where: ProcessingQueueWhereUniqueInput;
    /**
     * In case the ProcessingQueue found by the `where` argument doesn't exist, create a new ProcessingQueue with this data.
     */
    create: XOR<ProcessingQueueCreateInput, ProcessingQueueUncheckedCreateInput>;
    /**
     * In case the ProcessingQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcessingQueueUpdateInput, ProcessingQueueUncheckedUpdateInput>;
  };

  /**
   * ProcessingQueue delete
   */
  export type ProcessingQueueDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
    /**
     * Filter which ProcessingQueue to delete.
     */
    where: ProcessingQueueWhereUniqueInput;
  };

  /**
   * ProcessingQueue deleteMany
   */
  export type ProcessingQueueDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ProcessingQueues to delete
     */
    where?: ProcessingQueueWhereInput;
    /**
     * Limit how many ProcessingQueues to delete.
     */
    limit?: number;
  };

  /**
   * ProcessingQueue.document
   */
  export type ProcessingQueue$documentArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PaperlessDocument
     */
    select?: PaperlessDocumentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PaperlessDocument
     */
    omit?: PaperlessDocumentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaperlessDocumentInclude<ExtArgs> | null;
    where?: PaperlessDocumentWhereInput;
  };

  /**
   * ProcessingQueue.aiBot
   */
  export type ProcessingQueue$aiBotArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    where?: AiBotWhereInput;
  };

  /**
   * ProcessingQueue without action
   */
  export type ProcessingQueueDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ProcessingQueue
     */
    select?: ProcessingQueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ProcessingQueue
     */
    omit?: ProcessingQueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcessingQueueInclude<ExtArgs> | null;
  };

  /**
   * Model ImportHistory
   */

  export type AggregateImportHistory = {
    _count: ImportHistoryCountAggregateOutputType | null;
    _avg: ImportHistoryAvgAggregateOutputType | null;
    _sum: ImportHistorySumAggregateOutputType | null;
    _min: ImportHistoryMinAggregateOutputType | null;
    _max: ImportHistoryMaxAggregateOutputType | null;
  };

  export type ImportHistoryAvgAggregateOutputType = {
    documentsImported: number | null;
    documentsUpdated: number | null;
    documentsUnchanged: number | null;
    totalInPaperless: number | null;
  };

  export type ImportHistorySumAggregateOutputType = {
    documentsImported: number | null;
    documentsUpdated: number | null;
    documentsUnchanged: number | null;
    totalInPaperless: number | null;
  };

  export type ImportHistoryMinAggregateOutputType = {
    id: string | null;
    importedAt: Date | null;
    documentsImported: number | null;
    documentsUpdated: number | null;
    documentsUnchanged: number | null;
    totalInPaperless: number | null;
    paperlessInstanceId: string | null;
  };

  export type ImportHistoryMaxAggregateOutputType = {
    id: string | null;
    importedAt: Date | null;
    documentsImported: number | null;
    documentsUpdated: number | null;
    documentsUnchanged: number | null;
    totalInPaperless: number | null;
    paperlessInstanceId: string | null;
  };

  export type ImportHistoryCountAggregateOutputType = {
    id: number;
    importedAt: number;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
    paperlessInstanceId: number;
    _all: number;
  };

  export type ImportHistoryAvgAggregateInputType = {
    documentsImported?: true;
    documentsUpdated?: true;
    documentsUnchanged?: true;
    totalInPaperless?: true;
  };

  export type ImportHistorySumAggregateInputType = {
    documentsImported?: true;
    documentsUpdated?: true;
    documentsUnchanged?: true;
    totalInPaperless?: true;
  };

  export type ImportHistoryMinAggregateInputType = {
    id?: true;
    importedAt?: true;
    documentsImported?: true;
    documentsUpdated?: true;
    documentsUnchanged?: true;
    totalInPaperless?: true;
    paperlessInstanceId?: true;
  };

  export type ImportHistoryMaxAggregateInputType = {
    id?: true;
    importedAt?: true;
    documentsImported?: true;
    documentsUpdated?: true;
    documentsUnchanged?: true;
    totalInPaperless?: true;
    paperlessInstanceId?: true;
  };

  export type ImportHistoryCountAggregateInputType = {
    id?: true;
    importedAt?: true;
    documentsImported?: true;
    documentsUpdated?: true;
    documentsUnchanged?: true;
    totalInPaperless?: true;
    paperlessInstanceId?: true;
    _all?: true;
  };

  export type ImportHistoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ImportHistory to aggregate.
     */
    where?: ImportHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ImportHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ImportHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ImportHistories
     **/
    _count?: true | ImportHistoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ImportHistoryAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ImportHistorySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ImportHistoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ImportHistoryMaxAggregateInputType;
  };

  export type GetImportHistoryAggregateType<T extends ImportHistoryAggregateArgs> = {
    [P in keyof T & keyof AggregateImportHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportHistory[P]>
      : GetScalarType<T[P], AggregateImportHistory[P]>;
  };

  export type ImportHistoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ImportHistoryWhereInput;
    orderBy?: ImportHistoryOrderByWithAggregationInput | ImportHistoryOrderByWithAggregationInput[];
    by: ImportHistoryScalarFieldEnum[] | ImportHistoryScalarFieldEnum;
    having?: ImportHistoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ImportHistoryCountAggregateInputType | true;
    _avg?: ImportHistoryAvgAggregateInputType;
    _sum?: ImportHistorySumAggregateInputType;
    _min?: ImportHistoryMinAggregateInputType;
    _max?: ImportHistoryMaxAggregateInputType;
  };

  export type ImportHistoryGroupByOutputType = {
    id: string;
    importedAt: Date;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
    paperlessInstanceId: string;
    _count: ImportHistoryCountAggregateOutputType | null;
    _avg: ImportHistoryAvgAggregateOutputType | null;
    _sum: ImportHistorySumAggregateOutputType | null;
    _min: ImportHistoryMinAggregateOutputType | null;
    _max: ImportHistoryMaxAggregateOutputType | null;
  };

  type GetImportHistoryGroupByPayload<T extends ImportHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportHistoryGroupByOutputType, T['by']> & {
        [P in keyof T & keyof ImportHistoryGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], ImportHistoryGroupByOutputType[P]>
          : GetScalarType<T[P], ImportHistoryGroupByOutputType[P]>;
      }
    >
  >;

  export type ImportHistorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      importedAt?: boolean;
      documentsImported?: boolean;
      documentsUpdated?: boolean;
      documentsUnchanged?: boolean;
      totalInPaperless?: boolean;
      paperlessInstanceId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['importHistory']
  >;

  export type ImportHistorySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      importedAt?: boolean;
      documentsImported?: boolean;
      documentsUpdated?: boolean;
      documentsUnchanged?: boolean;
      totalInPaperless?: boolean;
      paperlessInstanceId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['importHistory']
  >;

  export type ImportHistorySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      importedAt?: boolean;
      documentsImported?: boolean;
      documentsUpdated?: boolean;
      documentsUnchanged?: boolean;
      totalInPaperless?: boolean;
      paperlessInstanceId?: boolean;
      paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['importHistory']
  >;

  export type ImportHistorySelectScalar = {
    id?: boolean;
    importedAt?: boolean;
    documentsImported?: boolean;
    documentsUpdated?: boolean;
    documentsUnchanged?: boolean;
    totalInPaperless?: boolean;
    paperlessInstanceId?: boolean;
  };

  export type ImportHistoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'importedAt'
    | 'documentsImported'
    | 'documentsUpdated'
    | 'documentsUnchanged'
    | 'totalInPaperless'
    | 'paperlessInstanceId',
    ExtArgs['result']['importHistory']
  >;
  export type ImportHistoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };
  export type ImportHistoryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };
  export type ImportHistoryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    paperlessInstance?: boolean | PaperlessInstanceDefaultArgs<ExtArgs>;
  };

  export type $ImportHistoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ImportHistory';
    objects: {
      paperlessInstance: Prisma.$PaperlessInstancePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        importedAt: Date;
        documentsImported: number;
        documentsUpdated: number;
        documentsUnchanged: number;
        totalInPaperless: number;
        paperlessInstanceId: string;
      },
      ExtArgs['result']['importHistory']
    >;
    composites: {};
  };

  type ImportHistoryGetPayload<S extends boolean | null | undefined | ImportHistoryDefaultArgs> =
    $Result.GetResult<Prisma.$ImportHistoryPayload, S>;

  type ImportHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportHistoryCountAggregateInputType | true;
    };

  export interface ImportHistoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ImportHistory'];
      meta: { name: 'ImportHistory' };
    };
    /**
     * Find zero or one ImportHistory that matches the filter.
     * @param {ImportHistoryFindUniqueArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportHistoryFindUniqueArgs>(
      args: SelectSubset<T, ImportHistoryFindUniqueArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<
        Prisma.$ImportHistoryPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ImportHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportHistoryFindUniqueOrThrowArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportHistoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ImportHistoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<
        Prisma.$ImportHistoryPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ImportHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryFindFirstArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportHistoryFindFirstArgs>(
      args?: SelectSubset<T, ImportHistoryFindFirstArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<
        Prisma.$ImportHistoryPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ImportHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryFindFirstOrThrowArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImportHistoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<
        Prisma.$ImportHistoryPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ImportHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportHistories
     * const importHistories = await prisma.importHistory.findMany()
     *
     * // Get first 10 ImportHistories
     * const importHistories = await prisma.importHistory.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const importHistoryWithIdOnly = await prisma.importHistory.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ImportHistoryFindManyArgs>(
      args?: SelectSubset<T, ImportHistoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a ImportHistory.
     * @param {ImportHistoryCreateArgs} args - Arguments to create a ImportHistory.
     * @example
     * // Create one ImportHistory
     * const ImportHistory = await prisma.importHistory.create({
     *   data: {
     *     // ... data to create a ImportHistory
     *   }
     * })
     *
     */
    create<T extends ImportHistoryCreateArgs>(
      args: SelectSubset<T, ImportHistoryCreateArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ImportHistories.
     * @param {ImportHistoryCreateManyArgs} args - Arguments to create many ImportHistories.
     * @example
     * // Create many ImportHistories
     * const importHistory = await prisma.importHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ImportHistoryCreateManyArgs>(
      args?: SelectSubset<T, ImportHistoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many ImportHistories and returns the data saved in the database.
     * @param {ImportHistoryCreateManyAndReturnArgs} args - Arguments to create many ImportHistories.
     * @example
     * // Create many ImportHistories
     * const importHistory = await prisma.importHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ImportHistories and only return the `id`
     * const importHistoryWithIdOnly = await prisma.importHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ImportHistoryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ImportHistoryCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ImportHistoryPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a ImportHistory.
     * @param {ImportHistoryDeleteArgs} args - Arguments to delete one ImportHistory.
     * @example
     * // Delete one ImportHistory
     * const ImportHistory = await prisma.importHistory.delete({
     *   where: {
     *     // ... filter to delete one ImportHistory
     *   }
     * })
     *
     */
    delete<T extends ImportHistoryDeleteArgs>(
      args: SelectSubset<T, ImportHistoryDeleteArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ImportHistory.
     * @param {ImportHistoryUpdateArgs} args - Arguments to update one ImportHistory.
     * @example
     * // Update one ImportHistory
     * const importHistory = await prisma.importHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ImportHistoryUpdateArgs>(
      args: SelectSubset<T, ImportHistoryUpdateArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ImportHistories.
     * @param {ImportHistoryDeleteManyArgs} args - Arguments to filter ImportHistories to delete.
     * @example
     * // Delete a few ImportHistories
     * const { count } = await prisma.importHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ImportHistoryDeleteManyArgs>(
      args?: SelectSubset<T, ImportHistoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ImportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportHistories
     * const importHistory = await prisma.importHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ImportHistoryUpdateManyArgs>(
      args: SelectSubset<T, ImportHistoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ImportHistories and returns the data updated in the database.
     * @param {ImportHistoryUpdateManyAndReturnArgs} args - Arguments to update many ImportHistories.
     * @example
     * // Update many ImportHistories
     * const importHistory = await prisma.importHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ImportHistories and only return the `id`
     * const importHistoryWithIdOnly = await prisma.importHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ImportHistoryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ImportHistoryUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ImportHistoryPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one ImportHistory.
     * @param {ImportHistoryUpsertArgs} args - Arguments to update or create a ImportHistory.
     * @example
     * // Update or create a ImportHistory
     * const importHistory = await prisma.importHistory.upsert({
     *   create: {
     *     // ... data to create a ImportHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportHistory we want to update
     *   }
     * })
     */
    upsert<T extends ImportHistoryUpsertArgs>(
      args: SelectSubset<T, ImportHistoryUpsertArgs<ExtArgs>>
    ): Prisma__ImportHistoryClient<
      $Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of ImportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryCountArgs} args - Arguments to filter ImportHistories to count.
     * @example
     * // Count the number of ImportHistories
     * const count = await prisma.importHistory.count({
     *   where: {
     *     // ... the filter for the ImportHistories we want to count
     *   }
     * })
     **/
    count<T extends ImportHistoryCountArgs>(
      args?: Subset<T, ImportHistoryCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportHistoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ImportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ImportHistoryAggregateArgs>(
      args: Subset<T, ImportHistoryAggregateArgs>
    ): Prisma.PrismaPromise<GetImportHistoryAggregateType<T>>;

    /**
     * Group by ImportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ImportHistoryGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ImportHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ImportHistoryGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetImportHistoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ImportHistory model
     */
    readonly fields: ImportHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportHistoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    paperlessInstance<T extends PaperlessInstanceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PaperlessInstanceDefaultArgs<ExtArgs>>
    ): Prisma__PaperlessInstanceClient<
      | $Result.GetResult<
          Prisma.$PaperlessInstancePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ImportHistory model
   */
  interface ImportHistoryFieldRefs {
    readonly id: FieldRef<'ImportHistory', 'String'>;
    readonly importedAt: FieldRef<'ImportHistory', 'DateTime'>;
    readonly documentsImported: FieldRef<'ImportHistory', 'Int'>;
    readonly documentsUpdated: FieldRef<'ImportHistory', 'Int'>;
    readonly documentsUnchanged: FieldRef<'ImportHistory', 'Int'>;
    readonly totalInPaperless: FieldRef<'ImportHistory', 'Int'>;
    readonly paperlessInstanceId: FieldRef<'ImportHistory', 'String'>;
  }

  // Custom InputTypes
  /**
   * ImportHistory findUnique
   */
  export type ImportHistoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ImportHistory to fetch.
     */
    where: ImportHistoryWhereUniqueInput;
  };

  /**
   * ImportHistory findUniqueOrThrow
   */
  export type ImportHistoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ImportHistory to fetch.
     */
    where: ImportHistoryWhereUniqueInput;
  };

  /**
   * ImportHistory findFirst
   */
  export type ImportHistoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ImportHistory to fetch.
     */
    where?: ImportHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ImportHistories.
     */
    cursor?: ImportHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ImportHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ImportHistories.
     */
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[];
  };

  /**
   * ImportHistory findFirstOrThrow
   */
  export type ImportHistoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ImportHistory to fetch.
     */
    where?: ImportHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ImportHistories.
     */
    cursor?: ImportHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ImportHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ImportHistories.
     */
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[];
  };

  /**
   * ImportHistory findMany
   */
  export type ImportHistoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which ImportHistories to fetch.
     */
    where?: ImportHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ImportHistories.
     */
    cursor?: ImportHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ImportHistories.
     */
    skip?: number;
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[];
  };

  /**
   * ImportHistory create
   */
  export type ImportHistoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a ImportHistory.
     */
    data: XOR<ImportHistoryCreateInput, ImportHistoryUncheckedCreateInput>;
  };

  /**
   * ImportHistory createMany
   */
  export type ImportHistoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ImportHistories.
     */
    data: ImportHistoryCreateManyInput | ImportHistoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * ImportHistory createManyAndReturn
   */
  export type ImportHistoryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * The data used to create many ImportHistories.
     */
    data: ImportHistoryCreateManyInput | ImportHistoryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ImportHistory update
   */
  export type ImportHistoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a ImportHistory.
     */
    data: XOR<ImportHistoryUpdateInput, ImportHistoryUncheckedUpdateInput>;
    /**
     * Choose, which ImportHistory to update.
     */
    where: ImportHistoryWhereUniqueInput;
  };

  /**
   * ImportHistory updateMany
   */
  export type ImportHistoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ImportHistories.
     */
    data: XOR<ImportHistoryUpdateManyMutationInput, ImportHistoryUncheckedUpdateManyInput>;
    /**
     * Filter which ImportHistories to update
     */
    where?: ImportHistoryWhereInput;
    /**
     * Limit how many ImportHistories to update.
     */
    limit?: number;
  };

  /**
   * ImportHistory updateManyAndReturn
   */
  export type ImportHistoryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * The data used to update ImportHistories.
     */
    data: XOR<ImportHistoryUpdateManyMutationInput, ImportHistoryUncheckedUpdateManyInput>;
    /**
     * Filter which ImportHistories to update
     */
    where?: ImportHistoryWhereInput;
    /**
     * Limit how many ImportHistories to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * ImportHistory upsert
   */
  export type ImportHistoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the ImportHistory to update in case it exists.
     */
    where: ImportHistoryWhereUniqueInput;
    /**
     * In case the ImportHistory found by the `where` argument doesn't exist, create a new ImportHistory with this data.
     */
    create: XOR<ImportHistoryCreateInput, ImportHistoryUncheckedCreateInput>;
    /**
     * In case the ImportHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportHistoryUpdateInput, ImportHistoryUncheckedUpdateInput>;
  };

  /**
   * ImportHistory delete
   */
  export type ImportHistoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
    /**
     * Filter which ImportHistory to delete.
     */
    where: ImportHistoryWhereUniqueInput;
  };

  /**
   * ImportHistory deleteMany
   */
  export type ImportHistoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ImportHistories to delete
     */
    where?: ImportHistoryWhereInput;
    /**
     * Limit how many ImportHistories to delete.
     */
    limit?: number;
  };

  /**
   * ImportHistory without action
   */
  export type ImportHistoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ImportHistory
     */
    omit?: ImportHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null;
  };

  /**
   * Model AiUsageMetric
   */

  export type AggregateAiUsageMetric = {
    _count: AiUsageMetricCountAggregateOutputType | null;
    _avg: AiUsageMetricAvgAggregateOutputType | null;
    _sum: AiUsageMetricSumAggregateOutputType | null;
    _min: AiUsageMetricMinAggregateOutputType | null;
    _max: AiUsageMetricMaxAggregateOutputType | null;
  };

  export type AiUsageMetricAvgAggregateOutputType = {
    promptTokens: number | null;
    completionTokens: number | null;
    totalTokens: number | null;
    estimatedCost: number | null;
    documentId: number | null;
  };

  export type AiUsageMetricSumAggregateOutputType = {
    promptTokens: number | null;
    completionTokens: number | null;
    totalTokens: number | null;
    estimatedCost: number | null;
    documentId: number | null;
  };

  export type AiUsageMetricMinAggregateOutputType = {
    id: string | null;
    provider: string | null;
    model: string | null;
    promptTokens: number | null;
    completionTokens: number | null;
    totalTokens: number | null;
    estimatedCost: number | null;
    documentId: number | null;
    createdAt: Date | null;
    userId: string | null;
    aiAccountId: string | null;
    aiModelId: string | null;
    aiBotId: string | null;
  };

  export type AiUsageMetricMaxAggregateOutputType = {
    id: string | null;
    provider: string | null;
    model: string | null;
    promptTokens: number | null;
    completionTokens: number | null;
    totalTokens: number | null;
    estimatedCost: number | null;
    documentId: number | null;
    createdAt: Date | null;
    userId: string | null;
    aiAccountId: string | null;
    aiModelId: string | null;
    aiBotId: string | null;
  };

  export type AiUsageMetricCountAggregateOutputType = {
    id: number;
    provider: number;
    model: number;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost: number;
    documentId: number;
    createdAt: number;
    userId: number;
    aiAccountId: number;
    aiModelId: number;
    aiBotId: number;
    _all: number;
  };

  export type AiUsageMetricAvgAggregateInputType = {
    promptTokens?: true;
    completionTokens?: true;
    totalTokens?: true;
    estimatedCost?: true;
    documentId?: true;
  };

  export type AiUsageMetricSumAggregateInputType = {
    promptTokens?: true;
    completionTokens?: true;
    totalTokens?: true;
    estimatedCost?: true;
    documentId?: true;
  };

  export type AiUsageMetricMinAggregateInputType = {
    id?: true;
    provider?: true;
    model?: true;
    promptTokens?: true;
    completionTokens?: true;
    totalTokens?: true;
    estimatedCost?: true;
    documentId?: true;
    createdAt?: true;
    userId?: true;
    aiAccountId?: true;
    aiModelId?: true;
    aiBotId?: true;
  };

  export type AiUsageMetricMaxAggregateInputType = {
    id?: true;
    provider?: true;
    model?: true;
    promptTokens?: true;
    completionTokens?: true;
    totalTokens?: true;
    estimatedCost?: true;
    documentId?: true;
    createdAt?: true;
    userId?: true;
    aiAccountId?: true;
    aiModelId?: true;
    aiBotId?: true;
  };

  export type AiUsageMetricCountAggregateInputType = {
    id?: true;
    provider?: true;
    model?: true;
    promptTokens?: true;
    completionTokens?: true;
    totalTokens?: true;
    estimatedCost?: true;
    documentId?: true;
    createdAt?: true;
    userId?: true;
    aiAccountId?: true;
    aiModelId?: true;
    aiBotId?: true;
    _all?: true;
  };

  export type AiUsageMetricAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiUsageMetric to aggregate.
     */
    where?: AiUsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiUsageMetrics to fetch.
     */
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AiUsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiUsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiUsageMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AiUsageMetrics
     **/
    _count?: true | AiUsageMetricCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AiUsageMetricAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AiUsageMetricSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AiUsageMetricMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AiUsageMetricMaxAggregateInputType;
  };

  export type GetAiUsageMetricAggregateType<T extends AiUsageMetricAggregateArgs> = {
    [P in keyof T & keyof AggregateAiUsageMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiUsageMetric[P]>
      : GetScalarType<T[P], AggregateAiUsageMetric[P]>;
  };

  export type AiUsageMetricGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AiUsageMetricWhereInput;
    orderBy?: AiUsageMetricOrderByWithAggregationInput | AiUsageMetricOrderByWithAggregationInput[];
    by: AiUsageMetricScalarFieldEnum[] | AiUsageMetricScalarFieldEnum;
    having?: AiUsageMetricScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AiUsageMetricCountAggregateInputType | true;
    _avg?: AiUsageMetricAvgAggregateInputType;
    _sum?: AiUsageMetricSumAggregateInputType;
    _min?: AiUsageMetricMinAggregateInputType;
    _max?: AiUsageMetricMaxAggregateInputType;
  };

  export type AiUsageMetricGroupByOutputType = {
    id: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost: number | null;
    documentId: number | null;
    createdAt: Date;
    userId: string;
    aiAccountId: string;
    aiModelId: string | null;
    aiBotId: string | null;
    _count: AiUsageMetricCountAggregateOutputType | null;
    _avg: AiUsageMetricAvgAggregateOutputType | null;
    _sum: AiUsageMetricSumAggregateOutputType | null;
    _min: AiUsageMetricMinAggregateOutputType | null;
    _max: AiUsageMetricMaxAggregateOutputType | null;
  };

  type GetAiUsageMetricGroupByPayload<T extends AiUsageMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiUsageMetricGroupByOutputType, T['by']> & {
        [P in keyof T & keyof AiUsageMetricGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AiUsageMetricGroupByOutputType[P]>
          : GetScalarType<T[P], AiUsageMetricGroupByOutputType[P]>;
      }
    >
  >;

  export type AiUsageMetricSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      provider?: boolean;
      model?: boolean;
      promptTokens?: boolean;
      completionTokens?: boolean;
      totalTokens?: boolean;
      estimatedCost?: boolean;
      documentId?: boolean;
      createdAt?: boolean;
      userId?: boolean;
      aiAccountId?: boolean;
      aiModelId?: boolean;
      aiBotId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
      aiModel?: boolean | AiUsageMetric$aiModelArgs<ExtArgs>;
      aiBot?: boolean | AiUsageMetric$aiBotArgs<ExtArgs>;
    },
    ExtArgs['result']['aiUsageMetric']
  >;

  export type AiUsageMetricSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      provider?: boolean;
      model?: boolean;
      promptTokens?: boolean;
      completionTokens?: boolean;
      totalTokens?: boolean;
      estimatedCost?: boolean;
      documentId?: boolean;
      createdAt?: boolean;
      userId?: boolean;
      aiAccountId?: boolean;
      aiModelId?: boolean;
      aiBotId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
      aiModel?: boolean | AiUsageMetric$aiModelArgs<ExtArgs>;
      aiBot?: boolean | AiUsageMetric$aiBotArgs<ExtArgs>;
    },
    ExtArgs['result']['aiUsageMetric']
  >;

  export type AiUsageMetricSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      provider?: boolean;
      model?: boolean;
      promptTokens?: boolean;
      completionTokens?: boolean;
      totalTokens?: boolean;
      estimatedCost?: boolean;
      documentId?: boolean;
      createdAt?: boolean;
      userId?: boolean;
      aiAccountId?: boolean;
      aiModelId?: boolean;
      aiBotId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
      aiModel?: boolean | AiUsageMetric$aiModelArgs<ExtArgs>;
      aiBot?: boolean | AiUsageMetric$aiBotArgs<ExtArgs>;
    },
    ExtArgs['result']['aiUsageMetric']
  >;

  export type AiUsageMetricSelectScalar = {
    id?: boolean;
    provider?: boolean;
    model?: boolean;
    promptTokens?: boolean;
    completionTokens?: boolean;
    totalTokens?: boolean;
    estimatedCost?: boolean;
    documentId?: boolean;
    createdAt?: boolean;
    userId?: boolean;
    aiAccountId?: boolean;
    aiModelId?: boolean;
    aiBotId?: boolean;
  };

  export type AiUsageMetricOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'provider'
    | 'model'
    | 'promptTokens'
    | 'completionTokens'
    | 'totalTokens'
    | 'estimatedCost'
    | 'documentId'
    | 'createdAt'
    | 'userId'
    | 'aiAccountId'
    | 'aiModelId'
    | 'aiBotId',
    ExtArgs['result']['aiUsageMetric']
  >;
  export type AiUsageMetricInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    aiModel?: boolean | AiUsageMetric$aiModelArgs<ExtArgs>;
    aiBot?: boolean | AiUsageMetric$aiBotArgs<ExtArgs>;
  };
  export type AiUsageMetricIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    aiModel?: boolean | AiUsageMetric$aiModelArgs<ExtArgs>;
    aiBot?: boolean | AiUsageMetric$aiBotArgs<ExtArgs>;
  };
  export type AiUsageMetricIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    aiAccount?: boolean | AiAccountDefaultArgs<ExtArgs>;
    aiModel?: boolean | AiUsageMetric$aiModelArgs<ExtArgs>;
    aiBot?: boolean | AiUsageMetric$aiBotArgs<ExtArgs>;
  };

  export type $AiUsageMetricPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AiUsageMetric';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      aiAccount: Prisma.$AiAccountPayload<ExtArgs>;
      aiModel: Prisma.$AiModelPayload<ExtArgs> | null;
      aiBot: Prisma.$AiBotPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        provider: string;
        model: string;
        promptTokens: number;
        completionTokens: number;
        totalTokens: number;
        estimatedCost: number | null;
        documentId: number | null;
        createdAt: Date;
        userId: string;
        aiAccountId: string;
        aiModelId: string | null;
        aiBotId: string | null;
      },
      ExtArgs['result']['aiUsageMetric']
    >;
    composites: {};
  };

  type AiUsageMetricGetPayload<S extends boolean | null | undefined | AiUsageMetricDefaultArgs> =
    $Result.GetResult<Prisma.$AiUsageMetricPayload, S>;

  type AiUsageMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AiUsageMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AiUsageMetricCountAggregateInputType | true;
    };

  export interface AiUsageMetricDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AiUsageMetric'];
      meta: { name: 'AiUsageMetric' };
    };
    /**
     * Find zero or one AiUsageMetric that matches the filter.
     * @param {AiUsageMetricFindUniqueArgs} args - Arguments to find a AiUsageMetric
     * @example
     * // Get one AiUsageMetric
     * const aiUsageMetric = await prisma.aiUsageMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiUsageMetricFindUniqueArgs>(
      args: SelectSubset<T, AiUsageMetricFindUniqueArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<
        Prisma.$AiUsageMetricPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AiUsageMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AiUsageMetricFindUniqueOrThrowArgs} args - Arguments to find a AiUsageMetric
     * @example
     * // Get one AiUsageMetric
     * const aiUsageMetric = await prisma.aiUsageMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiUsageMetricFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AiUsageMetricFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<
        Prisma.$AiUsageMetricPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiUsageMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricFindFirstArgs} args - Arguments to find a AiUsageMetric
     * @example
     * // Get one AiUsageMetric
     * const aiUsageMetric = await prisma.aiUsageMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiUsageMetricFindFirstArgs>(
      args?: SelectSubset<T, AiUsageMetricFindFirstArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<
        Prisma.$AiUsageMetricPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AiUsageMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricFindFirstOrThrowArgs} args - Arguments to find a AiUsageMetric
     * @example
     * // Get one AiUsageMetric
     * const aiUsageMetric = await prisma.aiUsageMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiUsageMetricFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AiUsageMetricFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<
        Prisma.$AiUsageMetricPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AiUsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiUsageMetrics
     * const aiUsageMetrics = await prisma.aiUsageMetric.findMany()
     *
     * // Get first 10 AiUsageMetrics
     * const aiUsageMetrics = await prisma.aiUsageMetric.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const aiUsageMetricWithIdOnly = await prisma.aiUsageMetric.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AiUsageMetricFindManyArgs>(
      args?: SelectSubset<T, AiUsageMetricFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a AiUsageMetric.
     * @param {AiUsageMetricCreateArgs} args - Arguments to create a AiUsageMetric.
     * @example
     * // Create one AiUsageMetric
     * const AiUsageMetric = await prisma.aiUsageMetric.create({
     *   data: {
     *     // ... data to create a AiUsageMetric
     *   }
     * })
     *
     */
    create<T extends AiUsageMetricCreateArgs>(
      args: SelectSubset<T, AiUsageMetricCreateArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AiUsageMetrics.
     * @param {AiUsageMetricCreateManyArgs} args - Arguments to create many AiUsageMetrics.
     * @example
     * // Create many AiUsageMetrics
     * const aiUsageMetric = await prisma.aiUsageMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AiUsageMetricCreateManyArgs>(
      args?: SelectSubset<T, AiUsageMetricCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AiUsageMetrics and returns the data saved in the database.
     * @param {AiUsageMetricCreateManyAndReturnArgs} args - Arguments to create many AiUsageMetrics.
     * @example
     * // Create many AiUsageMetrics
     * const aiUsageMetric = await prisma.aiUsageMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AiUsageMetrics and only return the `id`
     * const aiUsageMetricWithIdOnly = await prisma.aiUsageMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AiUsageMetricCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AiUsageMetricCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AiUsageMetricPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AiUsageMetric.
     * @param {AiUsageMetricDeleteArgs} args - Arguments to delete one AiUsageMetric.
     * @example
     * // Delete one AiUsageMetric
     * const AiUsageMetric = await prisma.aiUsageMetric.delete({
     *   where: {
     *     // ... filter to delete one AiUsageMetric
     *   }
     * })
     *
     */
    delete<T extends AiUsageMetricDeleteArgs>(
      args: SelectSubset<T, AiUsageMetricDeleteArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AiUsageMetric.
     * @param {AiUsageMetricUpdateArgs} args - Arguments to update one AiUsageMetric.
     * @example
     * // Update one AiUsageMetric
     * const aiUsageMetric = await prisma.aiUsageMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AiUsageMetricUpdateArgs>(
      args: SelectSubset<T, AiUsageMetricUpdateArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AiUsageMetrics.
     * @param {AiUsageMetricDeleteManyArgs} args - Arguments to filter AiUsageMetrics to delete.
     * @example
     * // Delete a few AiUsageMetrics
     * const { count } = await prisma.aiUsageMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AiUsageMetricDeleteManyArgs>(
      args?: SelectSubset<T, AiUsageMetricDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiUsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiUsageMetrics
     * const aiUsageMetric = await prisma.aiUsageMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AiUsageMetricUpdateManyArgs>(
      args: SelectSubset<T, AiUsageMetricUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AiUsageMetrics and returns the data updated in the database.
     * @param {AiUsageMetricUpdateManyAndReturnArgs} args - Arguments to update many AiUsageMetrics.
     * @example
     * // Update many AiUsageMetrics
     * const aiUsageMetric = await prisma.aiUsageMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AiUsageMetrics and only return the `id`
     * const aiUsageMetricWithIdOnly = await prisma.aiUsageMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AiUsageMetricUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AiUsageMetricUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AiUsageMetricPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AiUsageMetric.
     * @param {AiUsageMetricUpsertArgs} args - Arguments to update or create a AiUsageMetric.
     * @example
     * // Update or create a AiUsageMetric
     * const aiUsageMetric = await prisma.aiUsageMetric.upsert({
     *   create: {
     *     // ... data to create a AiUsageMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiUsageMetric we want to update
     *   }
     * })
     */
    upsert<T extends AiUsageMetricUpsertArgs>(
      args: SelectSubset<T, AiUsageMetricUpsertArgs<ExtArgs>>
    ): Prisma__AiUsageMetricClient<
      $Result.GetResult<Prisma.$AiUsageMetricPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AiUsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricCountArgs} args - Arguments to filter AiUsageMetrics to count.
     * @example
     * // Count the number of AiUsageMetrics
     * const count = await prisma.aiUsageMetric.count({
     *   where: {
     *     // ... the filter for the AiUsageMetrics we want to count
     *   }
     * })
     **/
    count<T extends AiUsageMetricCountArgs>(
      args?: Subset<T, AiUsageMetricCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiUsageMetricCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AiUsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AiUsageMetricAggregateArgs>(
      args: Subset<T, AiUsageMetricAggregateArgs>
    ): Prisma.PrismaPromise<GetAiUsageMetricAggregateType<T>>;

    /**
     * Group by AiUsageMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiUsageMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AiUsageMetricGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiUsageMetricGroupByArgs['orderBy'] }
        : { orderBy?: AiUsageMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AiUsageMetricGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAiUsageMetricGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AiUsageMetric model
     */
    readonly fields: AiUsageMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiUsageMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiUsageMetricClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiAccount<T extends AiAccountDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AiAccountDefaultArgs<ExtArgs>>
    ): Prisma__AiAccountClient<
      | $Result.GetResult<
          Prisma.$AiAccountPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiModel<T extends AiUsageMetric$aiModelArgs<ExtArgs> = {}>(
      args?: Subset<T, AiUsageMetric$aiModelArgs<ExtArgs>>
    ): Prisma__AiModelClient<
      $Result.GetResult<
        Prisma.$AiModelPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    aiBot<T extends AiUsageMetric$aiBotArgs<ExtArgs> = {}>(
      args?: Subset<T, AiUsageMetric$aiBotArgs<ExtArgs>>
    ): Prisma__AiBotClient<
      $Result.GetResult<
        Prisma.$AiBotPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AiUsageMetric model
   */
  interface AiUsageMetricFieldRefs {
    readonly id: FieldRef<'AiUsageMetric', 'String'>;
    readonly provider: FieldRef<'AiUsageMetric', 'String'>;
    readonly model: FieldRef<'AiUsageMetric', 'String'>;
    readonly promptTokens: FieldRef<'AiUsageMetric', 'Int'>;
    readonly completionTokens: FieldRef<'AiUsageMetric', 'Int'>;
    readonly totalTokens: FieldRef<'AiUsageMetric', 'Int'>;
    readonly estimatedCost: FieldRef<'AiUsageMetric', 'Float'>;
    readonly documentId: FieldRef<'AiUsageMetric', 'Int'>;
    readonly createdAt: FieldRef<'AiUsageMetric', 'DateTime'>;
    readonly userId: FieldRef<'AiUsageMetric', 'String'>;
    readonly aiAccountId: FieldRef<'AiUsageMetric', 'String'>;
    readonly aiModelId: FieldRef<'AiUsageMetric', 'String'>;
    readonly aiBotId: FieldRef<'AiUsageMetric', 'String'>;
  }

  // Custom InputTypes
  /**
   * AiUsageMetric findUnique
   */
  export type AiUsageMetricFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which AiUsageMetric to fetch.
     */
    where: AiUsageMetricWhereUniqueInput;
  };

  /**
   * AiUsageMetric findUniqueOrThrow
   */
  export type AiUsageMetricFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which AiUsageMetric to fetch.
     */
    where: AiUsageMetricWhereUniqueInput;
  };

  /**
   * AiUsageMetric findFirst
   */
  export type AiUsageMetricFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which AiUsageMetric to fetch.
     */
    where?: AiUsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiUsageMetrics to fetch.
     */
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiUsageMetrics.
     */
    cursor?: AiUsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiUsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiUsageMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiUsageMetrics.
     */
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * AiUsageMetric findFirstOrThrow
   */
  export type AiUsageMetricFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which AiUsageMetric to fetch.
     */
    where?: AiUsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiUsageMetrics to fetch.
     */
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AiUsageMetrics.
     */
    cursor?: AiUsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiUsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiUsageMetrics.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AiUsageMetrics.
     */
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * AiUsageMetric findMany
   */
  export type AiUsageMetricFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * Filter, which AiUsageMetrics to fetch.
     */
    where?: AiUsageMetricWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AiUsageMetrics to fetch.
     */
    orderBy?: AiUsageMetricOrderByWithRelationInput | AiUsageMetricOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AiUsageMetrics.
     */
    cursor?: AiUsageMetricWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AiUsageMetrics from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AiUsageMetrics.
     */
    skip?: number;
    distinct?: AiUsageMetricScalarFieldEnum | AiUsageMetricScalarFieldEnum[];
  };

  /**
   * AiUsageMetric create
   */
  export type AiUsageMetricCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * The data needed to create a AiUsageMetric.
     */
    data: XOR<AiUsageMetricCreateInput, AiUsageMetricUncheckedCreateInput>;
  };

  /**
   * AiUsageMetric createMany
   */
  export type AiUsageMetricCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AiUsageMetrics.
     */
    data: AiUsageMetricCreateManyInput | AiUsageMetricCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AiUsageMetric createManyAndReturn
   */
  export type AiUsageMetricCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * The data used to create many AiUsageMetrics.
     */
    data: AiUsageMetricCreateManyInput | AiUsageMetricCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiUsageMetric update
   */
  export type AiUsageMetricUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * The data needed to update a AiUsageMetric.
     */
    data: XOR<AiUsageMetricUpdateInput, AiUsageMetricUncheckedUpdateInput>;
    /**
     * Choose, which AiUsageMetric to update.
     */
    where: AiUsageMetricWhereUniqueInput;
  };

  /**
   * AiUsageMetric updateMany
   */
  export type AiUsageMetricUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AiUsageMetrics.
     */
    data: XOR<AiUsageMetricUpdateManyMutationInput, AiUsageMetricUncheckedUpdateManyInput>;
    /**
     * Filter which AiUsageMetrics to update
     */
    where?: AiUsageMetricWhereInput;
    /**
     * Limit how many AiUsageMetrics to update.
     */
    limit?: number;
  };

  /**
   * AiUsageMetric updateManyAndReturn
   */
  export type AiUsageMetricUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * The data used to update AiUsageMetrics.
     */
    data: XOR<AiUsageMetricUpdateManyMutationInput, AiUsageMetricUncheckedUpdateManyInput>;
    /**
     * Filter which AiUsageMetrics to update
     */
    where?: AiUsageMetricWhereInput;
    /**
     * Limit how many AiUsageMetrics to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AiUsageMetric upsert
   */
  export type AiUsageMetricUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * The filter to search for the AiUsageMetric to update in case it exists.
     */
    where: AiUsageMetricWhereUniqueInput;
    /**
     * In case the AiUsageMetric found by the `where` argument doesn't exist, create a new AiUsageMetric with this data.
     */
    create: XOR<AiUsageMetricCreateInput, AiUsageMetricUncheckedCreateInput>;
    /**
     * In case the AiUsageMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiUsageMetricUpdateInput, AiUsageMetricUncheckedUpdateInput>;
  };

  /**
   * AiUsageMetric delete
   */
  export type AiUsageMetricDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
    /**
     * Filter which AiUsageMetric to delete.
     */
    where: AiUsageMetricWhereUniqueInput;
  };

  /**
   * AiUsageMetric deleteMany
   */
  export type AiUsageMetricDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AiUsageMetrics to delete
     */
    where?: AiUsageMetricWhereInput;
    /**
     * Limit how many AiUsageMetrics to delete.
     */
    limit?: number;
  };

  /**
   * AiUsageMetric.aiModel
   */
  export type AiUsageMetric$aiModelArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiModel
     */
    select?: AiModelSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiModel
     */
    omit?: AiModelOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiModelInclude<ExtArgs> | null;
    where?: AiModelWhereInput;
  };

  /**
   * AiUsageMetric.aiBot
   */
  export type AiUsageMetric$aiBotArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiBot
     */
    select?: AiBotSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiBot
     */
    omit?: AiBotOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiBotInclude<ExtArgs> | null;
    where?: AiBotWhereInput;
  };

  /**
   * AiUsageMetric without action
   */
  export type AiUsageMetricDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AiUsageMetric
     */
    select?: AiUsageMetricSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AiUsageMetric
     */
    omit?: AiUsageMetricOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiUsageMetricInclude<ExtArgs> | null;
  };

  /**
   * Model WebAuthnCredential
   */

  export type AggregateWebAuthnCredential = {
    _count: WebAuthnCredentialCountAggregateOutputType | null;
    _avg: WebAuthnCredentialAvgAggregateOutputType | null;
    _sum: WebAuthnCredentialSumAggregateOutputType | null;
    _min: WebAuthnCredentialMinAggregateOutputType | null;
    _max: WebAuthnCredentialMaxAggregateOutputType | null;
  };

  export type WebAuthnCredentialAvgAggregateOutputType = {
    counter: number | null;
  };

  export type WebAuthnCredentialSumAggregateOutputType = {
    counter: bigint | null;
  };

  export type WebAuthnCredentialMinAggregateOutputType = {
    id: string | null;
    credentialId: Bytes | null;
    publicKey: Bytes | null;
    counter: bigint | null;
    deviceType: string | null;
    backedUp: boolean | null;
    name: string | null;
    createdAt: Date | null;
    lastUsedAt: Date | null;
    userId: string | null;
  };

  export type WebAuthnCredentialMaxAggregateOutputType = {
    id: string | null;
    credentialId: Bytes | null;
    publicKey: Bytes | null;
    counter: bigint | null;
    deviceType: string | null;
    backedUp: boolean | null;
    name: string | null;
    createdAt: Date | null;
    lastUsedAt: Date | null;
    userId: string | null;
  };

  export type WebAuthnCredentialCountAggregateOutputType = {
    id: number;
    credentialId: number;
    publicKey: number;
    counter: number;
    deviceType: number;
    backedUp: number;
    transports: number;
    name: number;
    createdAt: number;
    lastUsedAt: number;
    userId: number;
    _all: number;
  };

  export type WebAuthnCredentialAvgAggregateInputType = {
    counter?: true;
  };

  export type WebAuthnCredentialSumAggregateInputType = {
    counter?: true;
  };

  export type WebAuthnCredentialMinAggregateInputType = {
    id?: true;
    credentialId?: true;
    publicKey?: true;
    counter?: true;
    deviceType?: true;
    backedUp?: true;
    name?: true;
    createdAt?: true;
    lastUsedAt?: true;
    userId?: true;
  };

  export type WebAuthnCredentialMaxAggregateInputType = {
    id?: true;
    credentialId?: true;
    publicKey?: true;
    counter?: true;
    deviceType?: true;
    backedUp?: true;
    name?: true;
    createdAt?: true;
    lastUsedAt?: true;
    userId?: true;
  };

  export type WebAuthnCredentialCountAggregateInputType = {
    id?: true;
    credentialId?: true;
    publicKey?: true;
    counter?: true;
    deviceType?: true;
    backedUp?: true;
    transports?: true;
    name?: true;
    createdAt?: true;
    lastUsedAt?: true;
    userId?: true;
    _all?: true;
  };

  export type WebAuthnCredentialAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WebAuthnCredential to aggregate.
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?:
      | WebAuthnCredentialOrderByWithRelationInput
      | WebAuthnCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WebAuthnCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned WebAuthnCredentials
     **/
    _count?: true | WebAuthnCredentialCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: WebAuthnCredentialAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: WebAuthnCredentialSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WebAuthnCredentialMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WebAuthnCredentialMaxAggregateInputType;
  };

  export type GetWebAuthnCredentialAggregateType<T extends WebAuthnCredentialAggregateArgs> = {
    [P in keyof T & keyof AggregateWebAuthnCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebAuthnCredential[P]>
      : GetScalarType<T[P], AggregateWebAuthnCredential[P]>;
  };

  export type WebAuthnCredentialGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WebAuthnCredentialWhereInput;
    orderBy?:
      | WebAuthnCredentialOrderByWithAggregationInput
      | WebAuthnCredentialOrderByWithAggregationInput[];
    by: WebAuthnCredentialScalarFieldEnum[] | WebAuthnCredentialScalarFieldEnum;
    having?: WebAuthnCredentialScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WebAuthnCredentialCountAggregateInputType | true;
    _avg?: WebAuthnCredentialAvgAggregateInputType;
    _sum?: WebAuthnCredentialSumAggregateInputType;
    _min?: WebAuthnCredentialMinAggregateInputType;
    _max?: WebAuthnCredentialMaxAggregateInputType;
  };

  export type WebAuthnCredentialGroupByOutputType = {
    id: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter: bigint;
    deviceType: string;
    backedUp: boolean;
    transports: string[];
    name: string | null;
    createdAt: Date;
    lastUsedAt: Date | null;
    userId: string;
    _count: WebAuthnCredentialCountAggregateOutputType | null;
    _avg: WebAuthnCredentialAvgAggregateOutputType | null;
    _sum: WebAuthnCredentialSumAggregateOutputType | null;
    _min: WebAuthnCredentialMinAggregateOutputType | null;
    _max: WebAuthnCredentialMaxAggregateOutputType | null;
  };

  type GetWebAuthnCredentialGroupByPayload<T extends WebAuthnCredentialGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WebAuthnCredentialGroupByOutputType, T['by']> & {
          [P in keyof T & keyof WebAuthnCredentialGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebAuthnCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], WebAuthnCredentialGroupByOutputType[P]>;
        }
      >
    >;

  export type WebAuthnCredentialSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      credentialId?: boolean;
      publicKey?: boolean;
      counter?: boolean;
      deviceType?: boolean;
      backedUp?: boolean;
      transports?: boolean;
      name?: boolean;
      createdAt?: boolean;
      lastUsedAt?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['webAuthnCredential']
  >;

  export type WebAuthnCredentialSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      credentialId?: boolean;
      publicKey?: boolean;
      counter?: boolean;
      deviceType?: boolean;
      backedUp?: boolean;
      transports?: boolean;
      name?: boolean;
      createdAt?: boolean;
      lastUsedAt?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['webAuthnCredential']
  >;

  export type WebAuthnCredentialSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      credentialId?: boolean;
      publicKey?: boolean;
      counter?: boolean;
      deviceType?: boolean;
      backedUp?: boolean;
      transports?: boolean;
      name?: boolean;
      createdAt?: boolean;
      lastUsedAt?: boolean;
      userId?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['webAuthnCredential']
  >;

  export type WebAuthnCredentialSelectScalar = {
    id?: boolean;
    credentialId?: boolean;
    publicKey?: boolean;
    counter?: boolean;
    deviceType?: boolean;
    backedUp?: boolean;
    transports?: boolean;
    name?: boolean;
    createdAt?: boolean;
    lastUsedAt?: boolean;
    userId?: boolean;
  };

  export type WebAuthnCredentialOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'credentialId'
    | 'publicKey'
    | 'counter'
    | 'deviceType'
    | 'backedUp'
    | 'transports'
    | 'name'
    | 'createdAt'
    | 'lastUsedAt'
    | 'userId',
    ExtArgs['result']['webAuthnCredential']
  >;
  export type WebAuthnCredentialInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type WebAuthnCredentialIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type WebAuthnCredentialIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $WebAuthnCredentialPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'WebAuthnCredential';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        credentialId: Prisma.Bytes;
        publicKey: Prisma.Bytes;
        counter: bigint;
        deviceType: string;
        backedUp: boolean;
        transports: string[];
        name: string | null;
        createdAt: Date;
        lastUsedAt: Date | null;
        userId: string;
      },
      ExtArgs['result']['webAuthnCredential']
    >;
    composites: {};
  };

  type WebAuthnCredentialGetPayload<
    S extends boolean | null | undefined | WebAuthnCredentialDefaultArgs,
  > = $Result.GetResult<Prisma.$WebAuthnCredentialPayload, S>;

  type WebAuthnCredentialCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<WebAuthnCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: WebAuthnCredentialCountAggregateInputType | true;
  };

  export interface WebAuthnCredentialDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['WebAuthnCredential'];
      meta: { name: 'WebAuthnCredential' };
    };
    /**
     * Find zero or one WebAuthnCredential that matches the filter.
     * @param {WebAuthnCredentialFindUniqueArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebAuthnCredentialFindUniqueArgs>(
      args: SelectSubset<T, WebAuthnCredentialFindUniqueArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one WebAuthnCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebAuthnCredentialFindUniqueOrThrowArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebAuthnCredentialFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WebAuthnCredentialFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WebAuthnCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindFirstArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebAuthnCredentialFindFirstArgs>(
      args?: SelectSubset<T, WebAuthnCredentialFindFirstArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WebAuthnCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindFirstOrThrowArgs} args - Arguments to find a WebAuthnCredential
     * @example
     * // Get one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebAuthnCredentialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WebAuthnCredentialFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more WebAuthnCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebAuthnCredentials
     * const webAuthnCredentials = await prisma.webAuthnCredential.findMany()
     *
     * // Get first 10 WebAuthnCredentials
     * const webAuthnCredentials = await prisma.webAuthnCredential.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const webAuthnCredentialWithIdOnly = await prisma.webAuthnCredential.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WebAuthnCredentialFindManyArgs>(
      args?: SelectSubset<T, WebAuthnCredentialFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a WebAuthnCredential.
     * @param {WebAuthnCredentialCreateArgs} args - Arguments to create a WebAuthnCredential.
     * @example
     * // Create one WebAuthnCredential
     * const WebAuthnCredential = await prisma.webAuthnCredential.create({
     *   data: {
     *     // ... data to create a WebAuthnCredential
     *   }
     * })
     *
     */
    create<T extends WebAuthnCredentialCreateArgs>(
      args: SelectSubset<T, WebAuthnCredentialCreateArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many WebAuthnCredentials.
     * @param {WebAuthnCredentialCreateManyArgs} args - Arguments to create many WebAuthnCredentials.
     * @example
     * // Create many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WebAuthnCredentialCreateManyArgs>(
      args?: SelectSubset<T, WebAuthnCredentialCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many WebAuthnCredentials and returns the data saved in the database.
     * @param {WebAuthnCredentialCreateManyAndReturnArgs} args - Arguments to create many WebAuthnCredentials.
     * @example
     * // Create many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many WebAuthnCredentials and only return the `id`
     * const webAuthnCredentialWithIdOnly = await prisma.webAuthnCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WebAuthnCredentialCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WebAuthnCredentialCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a WebAuthnCredential.
     * @param {WebAuthnCredentialDeleteArgs} args - Arguments to delete one WebAuthnCredential.
     * @example
     * // Delete one WebAuthnCredential
     * const WebAuthnCredential = await prisma.webAuthnCredential.delete({
     *   where: {
     *     // ... filter to delete one WebAuthnCredential
     *   }
     * })
     *
     */
    delete<T extends WebAuthnCredentialDeleteArgs>(
      args: SelectSubset<T, WebAuthnCredentialDeleteArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one WebAuthnCredential.
     * @param {WebAuthnCredentialUpdateArgs} args - Arguments to update one WebAuthnCredential.
     * @example
     * // Update one WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WebAuthnCredentialUpdateArgs>(
      args: SelectSubset<T, WebAuthnCredentialUpdateArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more WebAuthnCredentials.
     * @param {WebAuthnCredentialDeleteManyArgs} args - Arguments to filter WebAuthnCredentials to delete.
     * @example
     * // Delete a few WebAuthnCredentials
     * const { count } = await prisma.webAuthnCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WebAuthnCredentialDeleteManyArgs>(
      args?: SelectSubset<T, WebAuthnCredentialDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WebAuthnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WebAuthnCredentialUpdateManyArgs>(
      args: SelectSubset<T, WebAuthnCredentialUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WebAuthnCredentials and returns the data updated in the database.
     * @param {WebAuthnCredentialUpdateManyAndReturnArgs} args - Arguments to update many WebAuthnCredentials.
     * @example
     * // Update many WebAuthnCredentials
     * const webAuthnCredential = await prisma.webAuthnCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more WebAuthnCredentials and only return the `id`
     * const webAuthnCredentialWithIdOnly = await prisma.webAuthnCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WebAuthnCredentialUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WebAuthnCredentialUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebAuthnCredentialPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one WebAuthnCredential.
     * @param {WebAuthnCredentialUpsertArgs} args - Arguments to update or create a WebAuthnCredential.
     * @example
     * // Update or create a WebAuthnCredential
     * const webAuthnCredential = await prisma.webAuthnCredential.upsert({
     *   create: {
     *     // ... data to create a WebAuthnCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebAuthnCredential we want to update
     *   }
     * })
     */
    upsert<T extends WebAuthnCredentialUpsertArgs>(
      args: SelectSubset<T, WebAuthnCredentialUpsertArgs<ExtArgs>>
    ): Prisma__WebAuthnCredentialClient<
      $Result.GetResult<Prisma.$WebAuthnCredentialPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of WebAuthnCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialCountArgs} args - Arguments to filter WebAuthnCredentials to count.
     * @example
     * // Count the number of WebAuthnCredentials
     * const count = await prisma.webAuthnCredential.count({
     *   where: {
     *     // ... the filter for the WebAuthnCredentials we want to count
     *   }
     * })
     **/
    count<T extends WebAuthnCredentialCountArgs>(
      args?: Subset<T, WebAuthnCredentialCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebAuthnCredentialCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a WebAuthnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WebAuthnCredentialAggregateArgs>(
      args: Subset<T, WebAuthnCredentialAggregateArgs>
    ): Prisma.PrismaPromise<GetWebAuthnCredentialAggregateType<T>>;

    /**
     * Group by WebAuthnCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WebAuthnCredentialGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebAuthnCredentialGroupByArgs['orderBy'] }
        : { orderBy?: WebAuthnCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WebAuthnCredentialGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetWebAuthnCredentialGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the WebAuthnCredential model
     */
    readonly fields: WebAuthnCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebAuthnCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebAuthnCredentialClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the WebAuthnCredential model
   */
  interface WebAuthnCredentialFieldRefs {
    readonly id: FieldRef<'WebAuthnCredential', 'String'>;
    readonly credentialId: FieldRef<'WebAuthnCredential', 'Bytes'>;
    readonly publicKey: FieldRef<'WebAuthnCredential', 'Bytes'>;
    readonly counter: FieldRef<'WebAuthnCredential', 'BigInt'>;
    readonly deviceType: FieldRef<'WebAuthnCredential', 'String'>;
    readonly backedUp: FieldRef<'WebAuthnCredential', 'Boolean'>;
    readonly transports: FieldRef<'WebAuthnCredential', 'String[]'>;
    readonly name: FieldRef<'WebAuthnCredential', 'String'>;
    readonly createdAt: FieldRef<'WebAuthnCredential', 'DateTime'>;
    readonly lastUsedAt: FieldRef<'WebAuthnCredential', 'DateTime'>;
    readonly userId: FieldRef<'WebAuthnCredential', 'String'>;
  }

  // Custom InputTypes
  /**
   * WebAuthnCredential findUnique
   */
  export type WebAuthnCredentialFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where: WebAuthnCredentialWhereUniqueInput;
  };

  /**
   * WebAuthnCredential findUniqueOrThrow
   */
  export type WebAuthnCredentialFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where: WebAuthnCredentialWhereUniqueInput;
  };

  /**
   * WebAuthnCredential findFirst
   */
  export type WebAuthnCredentialFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?:
      | WebAuthnCredentialOrderByWithRelationInput
      | WebAuthnCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WebAuthnCredentials.
     */
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[];
  };

  /**
   * WebAuthnCredential findFirstOrThrow
   */
  export type WebAuthnCredentialFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which WebAuthnCredential to fetch.
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?:
      | WebAuthnCredentialOrderByWithRelationInput
      | WebAuthnCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WebAuthnCredentials.
     */
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[];
  };

  /**
   * WebAuthnCredential findMany
   */
  export type WebAuthnCredentialFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * Filter, which WebAuthnCredentials to fetch.
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnCredentials to fetch.
     */
    orderBy?:
      | WebAuthnCredentialOrderByWithRelationInput
      | WebAuthnCredentialOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing WebAuthnCredentials.
     */
    cursor?: WebAuthnCredentialWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnCredentials from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnCredentials.
     */
    skip?: number;
    distinct?: WebAuthnCredentialScalarFieldEnum | WebAuthnCredentialScalarFieldEnum[];
  };

  /**
   * WebAuthnCredential create
   */
  export type WebAuthnCredentialCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * The data needed to create a WebAuthnCredential.
     */
    data: XOR<WebAuthnCredentialCreateInput, WebAuthnCredentialUncheckedCreateInput>;
  };

  /**
   * WebAuthnCredential createMany
   */
  export type WebAuthnCredentialCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many WebAuthnCredentials.
     */
    data: WebAuthnCredentialCreateManyInput | WebAuthnCredentialCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WebAuthnCredential createManyAndReturn
   */
  export type WebAuthnCredentialCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * The data used to create many WebAuthnCredentials.
     */
    data: WebAuthnCredentialCreateManyInput | WebAuthnCredentialCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WebAuthnCredential update
   */
  export type WebAuthnCredentialUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * The data needed to update a WebAuthnCredential.
     */
    data: XOR<WebAuthnCredentialUpdateInput, WebAuthnCredentialUncheckedUpdateInput>;
    /**
     * Choose, which WebAuthnCredential to update.
     */
    where: WebAuthnCredentialWhereUniqueInput;
  };

  /**
   * WebAuthnCredential updateMany
   */
  export type WebAuthnCredentialUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update WebAuthnCredentials.
     */
    data: XOR<
      WebAuthnCredentialUpdateManyMutationInput,
      WebAuthnCredentialUncheckedUpdateManyInput
    >;
    /**
     * Filter which WebAuthnCredentials to update
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * Limit how many WebAuthnCredentials to update.
     */
    limit?: number;
  };

  /**
   * WebAuthnCredential updateManyAndReturn
   */
  export type WebAuthnCredentialUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * The data used to update WebAuthnCredentials.
     */
    data: XOR<
      WebAuthnCredentialUpdateManyMutationInput,
      WebAuthnCredentialUncheckedUpdateManyInput
    >;
    /**
     * Filter which WebAuthnCredentials to update
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * Limit how many WebAuthnCredentials to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * WebAuthnCredential upsert
   */
  export type WebAuthnCredentialUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * The filter to search for the WebAuthnCredential to update in case it exists.
     */
    where: WebAuthnCredentialWhereUniqueInput;
    /**
     * In case the WebAuthnCredential found by the `where` argument doesn't exist, create a new WebAuthnCredential with this data.
     */
    create: XOR<WebAuthnCredentialCreateInput, WebAuthnCredentialUncheckedCreateInput>;
    /**
     * In case the WebAuthnCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebAuthnCredentialUpdateInput, WebAuthnCredentialUncheckedUpdateInput>;
  };

  /**
   * WebAuthnCredential delete
   */
  export type WebAuthnCredentialDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
    /**
     * Filter which WebAuthnCredential to delete.
     */
    where: WebAuthnCredentialWhereUniqueInput;
  };

  /**
   * WebAuthnCredential deleteMany
   */
  export type WebAuthnCredentialDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WebAuthnCredentials to delete
     */
    where?: WebAuthnCredentialWhereInput;
    /**
     * Limit how many WebAuthnCredentials to delete.
     */
    limit?: number;
  };

  /**
   * WebAuthnCredential without action
   */
  export type WebAuthnCredentialDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnCredential
     */
    select?: WebAuthnCredentialSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnCredential
     */
    omit?: WebAuthnCredentialOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebAuthnCredentialInclude<ExtArgs> | null;
  };

  /**
   * Model WebAuthnChallenge
   */

  export type AggregateWebAuthnChallenge = {
    _count: WebAuthnChallengeCountAggregateOutputType | null;
    _min: WebAuthnChallengeMinAggregateOutputType | null;
    _max: WebAuthnChallengeMaxAggregateOutputType | null;
  };

  export type WebAuthnChallengeMinAggregateOutputType = {
    id: string | null;
    challenge: string | null;
    type: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type WebAuthnChallengeMaxAggregateOutputType = {
    id: string | null;
    challenge: string | null;
    type: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type WebAuthnChallengeCountAggregateOutputType = {
    id: number;
    challenge: number;
    type: number;
    userId: number;
    expiresAt: number;
    createdAt: number;
    _all: number;
  };

  export type WebAuthnChallengeMinAggregateInputType = {
    id?: true;
    challenge?: true;
    type?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type WebAuthnChallengeMaxAggregateInputType = {
    id?: true;
    challenge?: true;
    type?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type WebAuthnChallengeCountAggregateInputType = {
    id?: true;
    challenge?: true;
    type?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type WebAuthnChallengeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WebAuthnChallenge to aggregate.
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnChallenges to fetch.
     */
    orderBy?:
      | WebAuthnChallengeOrderByWithRelationInput
      | WebAuthnChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: WebAuthnChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnChallenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnChallenges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned WebAuthnChallenges
     **/
    _count?: true | WebAuthnChallengeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: WebAuthnChallengeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: WebAuthnChallengeMaxAggregateInputType;
  };

  export type GetWebAuthnChallengeAggregateType<T extends WebAuthnChallengeAggregateArgs> = {
    [P in keyof T & keyof AggregateWebAuthnChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebAuthnChallenge[P]>
      : GetScalarType<T[P], AggregateWebAuthnChallenge[P]>;
  };

  export type WebAuthnChallengeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: WebAuthnChallengeWhereInput;
    orderBy?:
      | WebAuthnChallengeOrderByWithAggregationInput
      | WebAuthnChallengeOrderByWithAggregationInput[];
    by: WebAuthnChallengeScalarFieldEnum[] | WebAuthnChallengeScalarFieldEnum;
    having?: WebAuthnChallengeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: WebAuthnChallengeCountAggregateInputType | true;
    _min?: WebAuthnChallengeMinAggregateInputType;
    _max?: WebAuthnChallengeMaxAggregateInputType;
  };

  export type WebAuthnChallengeGroupByOutputType = {
    id: string;
    challenge: string;
    type: string;
    userId: string | null;
    expiresAt: Date;
    createdAt: Date;
    _count: WebAuthnChallengeCountAggregateOutputType | null;
    _min: WebAuthnChallengeMinAggregateOutputType | null;
    _max: WebAuthnChallengeMaxAggregateOutputType | null;
  };

  type GetWebAuthnChallengeGroupByPayload<T extends WebAuthnChallengeGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<WebAuthnChallengeGroupByOutputType, T['by']> & {
          [P in keyof T & keyof WebAuthnChallengeGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebAuthnChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], WebAuthnChallengeGroupByOutputType[P]>;
        }
      >
    >;

  export type WebAuthnChallengeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      challenge?: boolean;
      type?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['webAuthnChallenge']
  >;

  export type WebAuthnChallengeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      challenge?: boolean;
      type?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['webAuthnChallenge']
  >;

  export type WebAuthnChallengeSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      challenge?: boolean;
      type?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['webAuthnChallenge']
  >;

  export type WebAuthnChallengeSelectScalar = {
    id?: boolean;
    challenge?: boolean;
    type?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
  };

  export type WebAuthnChallengeOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'challenge' | 'type' | 'userId' | 'expiresAt' | 'createdAt',
    ExtArgs['result']['webAuthnChallenge']
  >;

  export type $WebAuthnChallengePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'WebAuthnChallenge';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        challenge: string;
        type: string;
        userId: string | null;
        expiresAt: Date;
        createdAt: Date;
      },
      ExtArgs['result']['webAuthnChallenge']
    >;
    composites: {};
  };

  type WebAuthnChallengeGetPayload<
    S extends boolean | null | undefined | WebAuthnChallengeDefaultArgs,
  > = $Result.GetResult<Prisma.$WebAuthnChallengePayload, S>;

  type WebAuthnChallengeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<WebAuthnChallengeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: WebAuthnChallengeCountAggregateInputType | true;
  };

  export interface WebAuthnChallengeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['WebAuthnChallenge'];
      meta: { name: 'WebAuthnChallenge' };
    };
    /**
     * Find zero or one WebAuthnChallenge that matches the filter.
     * @param {WebAuthnChallengeFindUniqueArgs} args - Arguments to find a WebAuthnChallenge
     * @example
     * // Get one WebAuthnChallenge
     * const webAuthnChallenge = await prisma.webAuthnChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebAuthnChallengeFindUniqueArgs>(
      args: SelectSubset<T, WebAuthnChallengeFindUniqueArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<
        Prisma.$WebAuthnChallengePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one WebAuthnChallenge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebAuthnChallengeFindUniqueOrThrowArgs} args - Arguments to find a WebAuthnChallenge
     * @example
     * // Get one WebAuthnChallenge
     * const webAuthnChallenge = await prisma.webAuthnChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebAuthnChallengeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, WebAuthnChallengeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<
        Prisma.$WebAuthnChallengePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WebAuthnChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeFindFirstArgs} args - Arguments to find a WebAuthnChallenge
     * @example
     * // Get one WebAuthnChallenge
     * const webAuthnChallenge = await prisma.webAuthnChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebAuthnChallengeFindFirstArgs>(
      args?: SelectSubset<T, WebAuthnChallengeFindFirstArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<
        Prisma.$WebAuthnChallengePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first WebAuthnChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeFindFirstOrThrowArgs} args - Arguments to find a WebAuthnChallenge
     * @example
     * // Get one WebAuthnChallenge
     * const webAuthnChallenge = await prisma.webAuthnChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebAuthnChallengeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WebAuthnChallengeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<
        Prisma.$WebAuthnChallengePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more WebAuthnChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebAuthnChallenges
     * const webAuthnChallenges = await prisma.webAuthnChallenge.findMany()
     *
     * // Get first 10 WebAuthnChallenges
     * const webAuthnChallenges = await prisma.webAuthnChallenge.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const webAuthnChallengeWithIdOnly = await prisma.webAuthnChallenge.findMany({ select: { id: true } })
     *
     */
    findMany<T extends WebAuthnChallengeFindManyArgs>(
      args?: SelectSubset<T, WebAuthnChallengeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$WebAuthnChallengePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
    >;

    /**
     * Create a WebAuthnChallenge.
     * @param {WebAuthnChallengeCreateArgs} args - Arguments to create a WebAuthnChallenge.
     * @example
     * // Create one WebAuthnChallenge
     * const WebAuthnChallenge = await prisma.webAuthnChallenge.create({
     *   data: {
     *     // ... data to create a WebAuthnChallenge
     *   }
     * })
     *
     */
    create<T extends WebAuthnChallengeCreateArgs>(
      args: SelectSubset<T, WebAuthnChallengeCreateArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<Prisma.$WebAuthnChallengePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many WebAuthnChallenges.
     * @param {WebAuthnChallengeCreateManyArgs} args - Arguments to create many WebAuthnChallenges.
     * @example
     * // Create many WebAuthnChallenges
     * const webAuthnChallenge = await prisma.webAuthnChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends WebAuthnChallengeCreateManyArgs>(
      args?: SelectSubset<T, WebAuthnChallengeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many WebAuthnChallenges and returns the data saved in the database.
     * @param {WebAuthnChallengeCreateManyAndReturnArgs} args - Arguments to create many WebAuthnChallenges.
     * @example
     * // Create many WebAuthnChallenges
     * const webAuthnChallenge = await prisma.webAuthnChallenge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many WebAuthnChallenges and only return the `id`
     * const webAuthnChallengeWithIdOnly = await prisma.webAuthnChallenge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends WebAuthnChallengeCreateManyAndReturnArgs>(
      args?: SelectSubset<T, WebAuthnChallengeCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebAuthnChallengePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a WebAuthnChallenge.
     * @param {WebAuthnChallengeDeleteArgs} args - Arguments to delete one WebAuthnChallenge.
     * @example
     * // Delete one WebAuthnChallenge
     * const WebAuthnChallenge = await prisma.webAuthnChallenge.delete({
     *   where: {
     *     // ... filter to delete one WebAuthnChallenge
     *   }
     * })
     *
     */
    delete<T extends WebAuthnChallengeDeleteArgs>(
      args: SelectSubset<T, WebAuthnChallengeDeleteArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<Prisma.$WebAuthnChallengePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one WebAuthnChallenge.
     * @param {WebAuthnChallengeUpdateArgs} args - Arguments to update one WebAuthnChallenge.
     * @example
     * // Update one WebAuthnChallenge
     * const webAuthnChallenge = await prisma.webAuthnChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends WebAuthnChallengeUpdateArgs>(
      args: SelectSubset<T, WebAuthnChallengeUpdateArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<Prisma.$WebAuthnChallengePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more WebAuthnChallenges.
     * @param {WebAuthnChallengeDeleteManyArgs} args - Arguments to filter WebAuthnChallenges to delete.
     * @example
     * // Delete a few WebAuthnChallenges
     * const { count } = await prisma.webAuthnChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends WebAuthnChallengeDeleteManyArgs>(
      args?: SelectSubset<T, WebAuthnChallengeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WebAuthnChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebAuthnChallenges
     * const webAuthnChallenge = await prisma.webAuthnChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends WebAuthnChallengeUpdateManyArgs>(
      args: SelectSubset<T, WebAuthnChallengeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more WebAuthnChallenges and returns the data updated in the database.
     * @param {WebAuthnChallengeUpdateManyAndReturnArgs} args - Arguments to update many WebAuthnChallenges.
     * @example
     * // Update many WebAuthnChallenges
     * const webAuthnChallenge = await prisma.webAuthnChallenge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more WebAuthnChallenges and only return the `id`
     * const webAuthnChallengeWithIdOnly = await prisma.webAuthnChallenge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends WebAuthnChallengeUpdateManyAndReturnArgs>(
      args: SelectSubset<T, WebAuthnChallengeUpdateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$WebAuthnChallengePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one WebAuthnChallenge.
     * @param {WebAuthnChallengeUpsertArgs} args - Arguments to update or create a WebAuthnChallenge.
     * @example
     * // Update or create a WebAuthnChallenge
     * const webAuthnChallenge = await prisma.webAuthnChallenge.upsert({
     *   create: {
     *     // ... data to create a WebAuthnChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebAuthnChallenge we want to update
     *   }
     * })
     */
    upsert<T extends WebAuthnChallengeUpsertArgs>(
      args: SelectSubset<T, WebAuthnChallengeUpsertArgs<ExtArgs>>
    ): Prisma__WebAuthnChallengeClient<
      $Result.GetResult<Prisma.$WebAuthnChallengePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of WebAuthnChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeCountArgs} args - Arguments to filter WebAuthnChallenges to count.
     * @example
     * // Count the number of WebAuthnChallenges
     * const count = await prisma.webAuthnChallenge.count({
     *   where: {
     *     // ... the filter for the WebAuthnChallenges we want to count
     *   }
     * })
     **/
    count<T extends WebAuthnChallengeCountArgs>(
      args?: Subset<T, WebAuthnChallengeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebAuthnChallengeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a WebAuthnChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends WebAuthnChallengeAggregateArgs>(
      args: Subset<T, WebAuthnChallengeAggregateArgs>
    ): Prisma.PrismaPromise<GetWebAuthnChallengeAggregateType<T>>;

    /**
     * Group by WebAuthnChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebAuthnChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends WebAuthnChallengeGroupByArgs,
      HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebAuthnChallengeGroupByArgs['orderBy'] }
        : { orderBy?: WebAuthnChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, WebAuthnChallengeGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetWebAuthnChallengeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the WebAuthnChallenge model
     */
    readonly fields: WebAuthnChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebAuthnChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebAuthnChallengeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the WebAuthnChallenge model
   */
  interface WebAuthnChallengeFieldRefs {
    readonly id: FieldRef<'WebAuthnChallenge', 'String'>;
    readonly challenge: FieldRef<'WebAuthnChallenge', 'String'>;
    readonly type: FieldRef<'WebAuthnChallenge', 'String'>;
    readonly userId: FieldRef<'WebAuthnChallenge', 'String'>;
    readonly expiresAt: FieldRef<'WebAuthnChallenge', 'DateTime'>;
    readonly createdAt: FieldRef<'WebAuthnChallenge', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * WebAuthnChallenge findUnique
   */
  export type WebAuthnChallengeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * Filter, which WebAuthnChallenge to fetch.
     */
    where: WebAuthnChallengeWhereUniqueInput;
  };

  /**
   * WebAuthnChallenge findUniqueOrThrow
   */
  export type WebAuthnChallengeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * Filter, which WebAuthnChallenge to fetch.
     */
    where: WebAuthnChallengeWhereUniqueInput;
  };

  /**
   * WebAuthnChallenge findFirst
   */
  export type WebAuthnChallengeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * Filter, which WebAuthnChallenge to fetch.
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnChallenges to fetch.
     */
    orderBy?:
      | WebAuthnChallengeOrderByWithRelationInput
      | WebAuthnChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WebAuthnChallenges.
     */
    cursor?: WebAuthnChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnChallenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnChallenges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WebAuthnChallenges.
     */
    distinct?: WebAuthnChallengeScalarFieldEnum | WebAuthnChallengeScalarFieldEnum[];
  };

  /**
   * WebAuthnChallenge findFirstOrThrow
   */
  export type WebAuthnChallengeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * Filter, which WebAuthnChallenge to fetch.
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnChallenges to fetch.
     */
    orderBy?:
      | WebAuthnChallengeOrderByWithRelationInput
      | WebAuthnChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for WebAuthnChallenges.
     */
    cursor?: WebAuthnChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnChallenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnChallenges.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of WebAuthnChallenges.
     */
    distinct?: WebAuthnChallengeScalarFieldEnum | WebAuthnChallengeScalarFieldEnum[];
  };

  /**
   * WebAuthnChallenge findMany
   */
  export type WebAuthnChallengeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * Filter, which WebAuthnChallenges to fetch.
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of WebAuthnChallenges to fetch.
     */
    orderBy?:
      | WebAuthnChallengeOrderByWithRelationInput
      | WebAuthnChallengeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing WebAuthnChallenges.
     */
    cursor?: WebAuthnChallengeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` WebAuthnChallenges from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` WebAuthnChallenges.
     */
    skip?: number;
    distinct?: WebAuthnChallengeScalarFieldEnum | WebAuthnChallengeScalarFieldEnum[];
  };

  /**
   * WebAuthnChallenge create
   */
  export type WebAuthnChallengeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * The data needed to create a WebAuthnChallenge.
     */
    data: XOR<WebAuthnChallengeCreateInput, WebAuthnChallengeUncheckedCreateInput>;
  };

  /**
   * WebAuthnChallenge createMany
   */
  export type WebAuthnChallengeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many WebAuthnChallenges.
     */
    data: WebAuthnChallengeCreateManyInput | WebAuthnChallengeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WebAuthnChallenge createManyAndReturn
   */
  export type WebAuthnChallengeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * The data used to create many WebAuthnChallenges.
     */
    data: WebAuthnChallengeCreateManyInput | WebAuthnChallengeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * WebAuthnChallenge update
   */
  export type WebAuthnChallengeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * The data needed to update a WebAuthnChallenge.
     */
    data: XOR<WebAuthnChallengeUpdateInput, WebAuthnChallengeUncheckedUpdateInput>;
    /**
     * Choose, which WebAuthnChallenge to update.
     */
    where: WebAuthnChallengeWhereUniqueInput;
  };

  /**
   * WebAuthnChallenge updateMany
   */
  export type WebAuthnChallengeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update WebAuthnChallenges.
     */
    data: XOR<WebAuthnChallengeUpdateManyMutationInput, WebAuthnChallengeUncheckedUpdateManyInput>;
    /**
     * Filter which WebAuthnChallenges to update
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * Limit how many WebAuthnChallenges to update.
     */
    limit?: number;
  };

  /**
   * WebAuthnChallenge updateManyAndReturn
   */
  export type WebAuthnChallengeUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * The data used to update WebAuthnChallenges.
     */
    data: XOR<WebAuthnChallengeUpdateManyMutationInput, WebAuthnChallengeUncheckedUpdateManyInput>;
    /**
     * Filter which WebAuthnChallenges to update
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * Limit how many WebAuthnChallenges to update.
     */
    limit?: number;
  };

  /**
   * WebAuthnChallenge upsert
   */
  export type WebAuthnChallengeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * The filter to search for the WebAuthnChallenge to update in case it exists.
     */
    where: WebAuthnChallengeWhereUniqueInput;
    /**
     * In case the WebAuthnChallenge found by the `where` argument doesn't exist, create a new WebAuthnChallenge with this data.
     */
    create: XOR<WebAuthnChallengeCreateInput, WebAuthnChallengeUncheckedCreateInput>;
    /**
     * In case the WebAuthnChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebAuthnChallengeUpdateInput, WebAuthnChallengeUncheckedUpdateInput>;
  };

  /**
   * WebAuthnChallenge delete
   */
  export type WebAuthnChallengeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
    /**
     * Filter which WebAuthnChallenge to delete.
     */
    where: WebAuthnChallengeWhereUniqueInput;
  };

  /**
   * WebAuthnChallenge deleteMany
   */
  export type WebAuthnChallengeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which WebAuthnChallenges to delete
     */
    where?: WebAuthnChallengeWhereInput;
    /**
     * Limit how many WebAuthnChallenges to delete.
     */
    limit?: number;
  };

  /**
   * WebAuthnChallenge without action
   */
  export type WebAuthnChallengeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the WebAuthnChallenge
     */
    select?: WebAuthnChallengeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the WebAuthnChallenge
     */
    omit?: WebAuthnChallengeOmit<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const SettingScalarFieldEnum: {
    settingKey: 'settingKey';
    settingValue: 'settingValue';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type SettingScalarFieldEnum =
    (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: 'id';
    username: 'username';
    passwordHash: 'passwordHash';
    role: 'role';
    mustChangePassword: 'mustChangePassword';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const UserPaperlessInstanceAccessScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    instanceId: 'instanceId';
    permission: 'permission';
    createdAt: 'createdAt';
  };

  export type UserPaperlessInstanceAccessScalarFieldEnum =
    (typeof UserPaperlessInstanceAccessScalarFieldEnum)[keyof typeof UserPaperlessInstanceAccessScalarFieldEnum];

  export const UserAiAccountAccessScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    aiAccountId: 'aiAccountId';
    permission: 'permission';
    createdAt: 'createdAt';
  };

  export type UserAiAccountAccessScalarFieldEnum =
    (typeof UserAiAccountAccessScalarFieldEnum)[keyof typeof UserAiAccountAccessScalarFieldEnum];

  export const UserAiModelAccessScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    aiModelId: 'aiModelId';
    permission: 'permission';
    createdAt: 'createdAt';
  };

  export type UserAiModelAccessScalarFieldEnum =
    (typeof UserAiModelAccessScalarFieldEnum)[keyof typeof UserAiModelAccessScalarFieldEnum];

  export const UserAiBotAccessScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    aiBotId: 'aiBotId';
    permission: 'permission';
    createdAt: 'createdAt';
  };

  export type UserAiBotAccessScalarFieldEnum =
    (typeof UserAiBotAccessScalarFieldEnum)[keyof typeof UserAiBotAccessScalarFieldEnum];

  export const PaperlessInstanceScalarFieldEnum: {
    id: 'id';
    name: 'name';
    apiUrl: 'apiUrl';
    apiToken: 'apiToken';
    importFilterTags: 'importFilterTags';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    autoProcessEnabled: 'autoProcessEnabled';
    scanCronExpression: 'scanCronExpression';
    lastScanAt: 'lastScanAt';
    nextScanAt: 'nextScanAt';
    defaultAiBotId: 'defaultAiBotId';
    autoApplyTitle: 'autoApplyTitle';
    autoApplyCorrespondent: 'autoApplyCorrespondent';
    autoApplyDocumentType: 'autoApplyDocumentType';
    autoApplyTags: 'autoApplyTags';
    autoApplyDate: 'autoApplyDate';
    ownerId: 'ownerId';
  };

  export type PaperlessInstanceScalarFieldEnum =
    (typeof PaperlessInstanceScalarFieldEnum)[keyof typeof PaperlessInstanceScalarFieldEnum];

  export const AiAccountScalarFieldEnum: {
    id: 'id';
    name: 'name';
    provider: 'provider';
    apiKey: 'apiKey';
    baseUrl: 'baseUrl';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    ownerId: 'ownerId';
  };

  export type AiAccountScalarFieldEnum =
    (typeof AiAccountScalarFieldEnum)[keyof typeof AiAccountScalarFieldEnum];

  export const AiModelScalarFieldEnum: {
    id: 'id';
    name: 'name';
    modelIdentifier: 'modelIdentifier';
    inputTokenPrice: 'inputTokenPrice';
    outputTokenPrice: 'outputTokenPrice';
    isActive: 'isActive';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    ownerId: 'ownerId';
    aiAccountId: 'aiAccountId';
  };

  export type AiModelScalarFieldEnum =
    (typeof AiModelScalarFieldEnum)[keyof typeof AiModelScalarFieldEnum];

  export const AiBotScalarFieldEnum: {
    id: 'id';
    name: 'name';
    systemPrompt: 'systemPrompt';
    responseLanguage: 'responseLanguage';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    ownerId: 'ownerId';
    aiModelId: 'aiModelId';
  };

  export type AiBotScalarFieldEnum =
    (typeof AiBotScalarFieldEnum)[keyof typeof AiBotScalarFieldEnum];

  export const PaperlessDocumentScalarFieldEnum: {
    id: 'id';
    paperlessId: 'paperlessId';
    title: 'title';
    content: 'content';
    correspondentId: 'correspondentId';
    tagIds: 'tagIds';
    documentDate: 'documentDate';
    paperlessModified: 'paperlessModified';
    importedAt: 'importedAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    paperlessInstanceId: 'paperlessInstanceId';
  };

  export type PaperlessDocumentScalarFieldEnum =
    (typeof PaperlessDocumentScalarFieldEnum)[keyof typeof PaperlessDocumentScalarFieldEnum];

  export const DocumentProcessingResultScalarFieldEnum: {
    id: 'id';
    processedAt: 'processedAt';
    aiProvider: 'aiProvider';
    inputTokens: 'inputTokens';
    outputTokens: 'outputTokens';
    estimatedCost: 'estimatedCost';
    changes: 'changes';
    toolCalls: 'toolCalls';
    originalTitle: 'originalTitle';
    originalCorrespondent: 'originalCorrespondent';
    originalDocumentType: 'originalDocumentType';
    originalTags: 'originalTags';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    documentId: 'documentId';
  };

  export type DocumentProcessingResultScalarFieldEnum =
    (typeof DocumentProcessingResultScalarFieldEnum)[keyof typeof DocumentProcessingResultScalarFieldEnum];

  export const ProcessingQueueScalarFieldEnum: {
    id: 'id';
    paperlessDocumentId: 'paperlessDocumentId';
    status: 'status';
    priority: 'priority';
    attempts: 'attempts';
    maxAttempts: 'maxAttempts';
    lastError: 'lastError';
    scheduledFor: 'scheduledFor';
    startedAt: 'startedAt';
    completedAt: 'completedAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    paperlessInstanceId: 'paperlessInstanceId';
    documentId: 'documentId';
    aiBotId: 'aiBotId';
  };

  export type ProcessingQueueScalarFieldEnum =
    (typeof ProcessingQueueScalarFieldEnum)[keyof typeof ProcessingQueueScalarFieldEnum];

  export const ImportHistoryScalarFieldEnum: {
    id: 'id';
    importedAt: 'importedAt';
    documentsImported: 'documentsImported';
    documentsUpdated: 'documentsUpdated';
    documentsUnchanged: 'documentsUnchanged';
    totalInPaperless: 'totalInPaperless';
    paperlessInstanceId: 'paperlessInstanceId';
  };

  export type ImportHistoryScalarFieldEnum =
    (typeof ImportHistoryScalarFieldEnum)[keyof typeof ImportHistoryScalarFieldEnum];

  export const AiUsageMetricScalarFieldEnum: {
    id: 'id';
    provider: 'provider';
    model: 'model';
    promptTokens: 'promptTokens';
    completionTokens: 'completionTokens';
    totalTokens: 'totalTokens';
    estimatedCost: 'estimatedCost';
    documentId: 'documentId';
    createdAt: 'createdAt';
    userId: 'userId';
    aiAccountId: 'aiAccountId';
    aiModelId: 'aiModelId';
    aiBotId: 'aiBotId';
  };

  export type AiUsageMetricScalarFieldEnum =
    (typeof AiUsageMetricScalarFieldEnum)[keyof typeof AiUsageMetricScalarFieldEnum];

  export const WebAuthnCredentialScalarFieldEnum: {
    id: 'id';
    credentialId: 'credentialId';
    publicKey: 'publicKey';
    counter: 'counter';
    deviceType: 'deviceType';
    backedUp: 'backedUp';
    transports: 'transports';
    name: 'name';
    createdAt: 'createdAt';
    lastUsedAt: 'lastUsedAt';
    userId: 'userId';
  };

  export type WebAuthnCredentialScalarFieldEnum =
    (typeof WebAuthnCredentialScalarFieldEnum)[keyof typeof WebAuthnCredentialScalarFieldEnum];

  export const WebAuthnChallengeScalarFieldEnum: {
    id: 'id';
    challenge: 'challenge';
    type: 'type';
    userId: 'userId';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
  };

  export type WebAuthnChallengeScalarFieldEnum =
    (typeof WebAuthnChallengeScalarFieldEnum)[keyof typeof WebAuthnChallengeScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Permission'
  >;

  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Permission[]'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>;

  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>;

  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>;

  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>;

  /**
   * Deep Input Types
   */

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[];
    OR?: SettingWhereInput[];
    NOT?: SettingWhereInput | SettingWhereInput[];
    settingKey?: StringFilter<'Setting'> | string;
    settingValue?: StringFilter<'Setting'> | string;
    createdAt?: DateTimeFilter<'Setting'> | Date | string;
    updatedAt?: DateTimeFilter<'Setting'> | Date | string;
  };

  export type SettingOrderByWithRelationInput = {
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingWhereUniqueInput = Prisma.AtLeast<
    {
      settingKey?: string;
      AND?: SettingWhereInput | SettingWhereInput[];
      OR?: SettingWhereInput[];
      NOT?: SettingWhereInput | SettingWhereInput[];
      settingValue?: StringFilter<'Setting'> | string;
      createdAt?: DateTimeFilter<'Setting'> | Date | string;
      updatedAt?: DateTimeFilter<'Setting'> | Date | string;
    },
    'settingKey'
  >;

  export type SettingOrderByWithAggregationInput = {
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SettingCountOrderByAggregateInput;
    _max?: SettingMaxOrderByAggregateInput;
    _min?: SettingMinOrderByAggregateInput;
  };

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[];
    OR?: SettingScalarWhereWithAggregatesInput[];
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[];
    settingKey?: StringWithAggregatesFilter<'Setting'> | string;
    settingValue?: StringWithAggregatesFilter<'Setting'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Setting'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Setting'> | Date | string;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    username?: StringFilter<'User'> | string;
    passwordHash?: StringFilter<'User'> | string;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    mustChangePassword?: BoolFilter<'User'> | boolean;
    isActive?: BoolFilter<'User'> | boolean;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceListRelationFilter;
    ownedAiAccounts?: AiAccountListRelationFilter;
    ownedAiModels?: AiModelListRelationFilter;
    ownedAiBots?: AiBotListRelationFilter;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessListRelationFilter;
    sharedAiAccounts?: UserAiAccountAccessListRelationFilter;
    sharedAiModels?: UserAiModelAccessListRelationFilter;
    sharedAiBots?: UserAiBotAccessListRelationFilter;
    aiUsageMetrics?: AiUsageMetricListRelationFilter;
    webAuthnCredentials?: WebAuthnCredentialListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    username?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    mustChangePassword?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownedPaperlessInstances?: PaperlessInstanceOrderByRelationAggregateInput;
    ownedAiAccounts?: AiAccountOrderByRelationAggregateInput;
    ownedAiModels?: AiModelOrderByRelationAggregateInput;
    ownedAiBots?: AiBotOrderByRelationAggregateInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessOrderByRelationAggregateInput;
    sharedAiAccounts?: UserAiAccountAccessOrderByRelationAggregateInput;
    sharedAiModels?: UserAiModelAccessOrderByRelationAggregateInput;
    sharedAiBots?: UserAiBotAccessOrderByRelationAggregateInput;
    aiUsageMetrics?: AiUsageMetricOrderByRelationAggregateInput;
    webAuthnCredentials?: WebAuthnCredentialOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      username?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      passwordHash?: StringFilter<'User'> | string;
      role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
      mustChangePassword?: BoolFilter<'User'> | boolean;
      isActive?: BoolFilter<'User'> | boolean;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      ownedPaperlessInstances?: PaperlessInstanceListRelationFilter;
      ownedAiAccounts?: AiAccountListRelationFilter;
      ownedAiModels?: AiModelListRelationFilter;
      ownedAiBots?: AiBotListRelationFilter;
      sharedPaperlessInstances?: UserPaperlessInstanceAccessListRelationFilter;
      sharedAiAccounts?: UserAiAccountAccessListRelationFilter;
      sharedAiModels?: UserAiModelAccessListRelationFilter;
      sharedAiBots?: UserAiBotAccessListRelationFilter;
      aiUsageMetrics?: AiUsageMetricListRelationFilter;
      webAuthnCredentials?: WebAuthnCredentialListRelationFilter;
    },
    'id' | 'username'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    username?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    mustChangePassword?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    username?: StringWithAggregatesFilter<'User'> | string;
    passwordHash?: StringWithAggregatesFilter<'User'> | string;
    role?: EnumUserRoleWithAggregatesFilter<'User'> | $Enums.UserRole;
    mustChangePassword?: BoolWithAggregatesFilter<'User'> | boolean;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
  };

  export type UserPaperlessInstanceAccessWhereInput = {
    AND?: UserPaperlessInstanceAccessWhereInput | UserPaperlessInstanceAccessWhereInput[];
    OR?: UserPaperlessInstanceAccessWhereInput[];
    NOT?: UserPaperlessInstanceAccessWhereInput | UserPaperlessInstanceAccessWhereInput[];
    id?: StringFilter<'UserPaperlessInstanceAccess'> | string;
    userId?: StringNullableFilter<'UserPaperlessInstanceAccess'> | string | null;
    instanceId?: StringFilter<'UserPaperlessInstanceAccess'> | string;
    permission?: EnumPermissionFilter<'UserPaperlessInstanceAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserPaperlessInstanceAccess'> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    instance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
  };

  export type UserPaperlessInstanceAccessOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    instanceId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    instance?: PaperlessInstanceOrderByWithRelationInput;
  };

  export type UserPaperlessInstanceAccessWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_instanceId?: UserPaperlessInstanceAccessUserIdInstanceIdCompoundUniqueInput;
      AND?: UserPaperlessInstanceAccessWhereInput | UserPaperlessInstanceAccessWhereInput[];
      OR?: UserPaperlessInstanceAccessWhereInput[];
      NOT?: UserPaperlessInstanceAccessWhereInput | UserPaperlessInstanceAccessWhereInput[];
      userId?: StringNullableFilter<'UserPaperlessInstanceAccess'> | string | null;
      instanceId?: StringFilter<'UserPaperlessInstanceAccess'> | string;
      permission?: EnumPermissionFilter<'UserPaperlessInstanceAccess'> | $Enums.Permission;
      createdAt?: DateTimeFilter<'UserPaperlessInstanceAccess'> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      instance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
    },
    'id' | 'userId_instanceId'
  >;

  export type UserPaperlessInstanceAccessOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    instanceId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserPaperlessInstanceAccessCountOrderByAggregateInput;
    _max?: UserPaperlessInstanceAccessMaxOrderByAggregateInput;
    _min?: UserPaperlessInstanceAccessMinOrderByAggregateInput;
  };

  export type UserPaperlessInstanceAccessScalarWhereWithAggregatesInput = {
    AND?:
      | UserPaperlessInstanceAccessScalarWhereWithAggregatesInput
      | UserPaperlessInstanceAccessScalarWhereWithAggregatesInput[];
    OR?: UserPaperlessInstanceAccessScalarWhereWithAggregatesInput[];
    NOT?:
      | UserPaperlessInstanceAccessScalarWhereWithAggregatesInput
      | UserPaperlessInstanceAccessScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UserPaperlessInstanceAccess'> | string;
    userId?: StringNullableWithAggregatesFilter<'UserPaperlessInstanceAccess'> | string | null;
    instanceId?: StringWithAggregatesFilter<'UserPaperlessInstanceAccess'> | string;
    permission?:
      | EnumPermissionWithAggregatesFilter<'UserPaperlessInstanceAccess'>
      | $Enums.Permission;
    createdAt?: DateTimeWithAggregatesFilter<'UserPaperlessInstanceAccess'> | Date | string;
  };

  export type UserAiAccountAccessWhereInput = {
    AND?: UserAiAccountAccessWhereInput | UserAiAccountAccessWhereInput[];
    OR?: UserAiAccountAccessWhereInput[];
    NOT?: UserAiAccountAccessWhereInput | UserAiAccountAccessWhereInput[];
    id?: StringFilter<'UserAiAccountAccess'> | string;
    userId?: StringNullableFilter<'UserAiAccountAccess'> | string | null;
    aiAccountId?: StringFilter<'UserAiAccountAccess'> | string;
    permission?: EnumPermissionFilter<'UserAiAccountAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserAiAccountAccess'> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    aiAccount?: XOR<AiAccountScalarRelationFilter, AiAccountWhereInput>;
  };

  export type UserAiAccountAccessOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    aiAccountId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    aiAccount?: AiAccountOrderByWithRelationInput;
  };

  export type UserAiAccountAccessWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_aiAccountId?: UserAiAccountAccessUserIdAiAccountIdCompoundUniqueInput;
      AND?: UserAiAccountAccessWhereInput | UserAiAccountAccessWhereInput[];
      OR?: UserAiAccountAccessWhereInput[];
      NOT?: UserAiAccountAccessWhereInput | UserAiAccountAccessWhereInput[];
      userId?: StringNullableFilter<'UserAiAccountAccess'> | string | null;
      aiAccountId?: StringFilter<'UserAiAccountAccess'> | string;
      permission?: EnumPermissionFilter<'UserAiAccountAccess'> | $Enums.Permission;
      createdAt?: DateTimeFilter<'UserAiAccountAccess'> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      aiAccount?: XOR<AiAccountScalarRelationFilter, AiAccountWhereInput>;
    },
    'id' | 'userId_aiAccountId'
  >;

  export type UserAiAccountAccessOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    aiAccountId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserAiAccountAccessCountOrderByAggregateInput;
    _max?: UserAiAccountAccessMaxOrderByAggregateInput;
    _min?: UserAiAccountAccessMinOrderByAggregateInput;
  };

  export type UserAiAccountAccessScalarWhereWithAggregatesInput = {
    AND?:
      | UserAiAccountAccessScalarWhereWithAggregatesInput
      | UserAiAccountAccessScalarWhereWithAggregatesInput[];
    OR?: UserAiAccountAccessScalarWhereWithAggregatesInput[];
    NOT?:
      | UserAiAccountAccessScalarWhereWithAggregatesInput
      | UserAiAccountAccessScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UserAiAccountAccess'> | string;
    userId?: StringNullableWithAggregatesFilter<'UserAiAccountAccess'> | string | null;
    aiAccountId?: StringWithAggregatesFilter<'UserAiAccountAccess'> | string;
    permission?: EnumPermissionWithAggregatesFilter<'UserAiAccountAccess'> | $Enums.Permission;
    createdAt?: DateTimeWithAggregatesFilter<'UserAiAccountAccess'> | Date | string;
  };

  export type UserAiModelAccessWhereInput = {
    AND?: UserAiModelAccessWhereInput | UserAiModelAccessWhereInput[];
    OR?: UserAiModelAccessWhereInput[];
    NOT?: UserAiModelAccessWhereInput | UserAiModelAccessWhereInput[];
    id?: StringFilter<'UserAiModelAccess'> | string;
    userId?: StringNullableFilter<'UserAiModelAccess'> | string | null;
    aiModelId?: StringFilter<'UserAiModelAccess'> | string;
    permission?: EnumPermissionFilter<'UserAiModelAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserAiModelAccess'> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    aiModel?: XOR<AiModelScalarRelationFilter, AiModelWhereInput>;
  };

  export type UserAiModelAccessOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    aiModelId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    aiModel?: AiModelOrderByWithRelationInput;
  };

  export type UserAiModelAccessWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_aiModelId?: UserAiModelAccessUserIdAiModelIdCompoundUniqueInput;
      AND?: UserAiModelAccessWhereInput | UserAiModelAccessWhereInput[];
      OR?: UserAiModelAccessWhereInput[];
      NOT?: UserAiModelAccessWhereInput | UserAiModelAccessWhereInput[];
      userId?: StringNullableFilter<'UserAiModelAccess'> | string | null;
      aiModelId?: StringFilter<'UserAiModelAccess'> | string;
      permission?: EnumPermissionFilter<'UserAiModelAccess'> | $Enums.Permission;
      createdAt?: DateTimeFilter<'UserAiModelAccess'> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      aiModel?: XOR<AiModelScalarRelationFilter, AiModelWhereInput>;
    },
    'id' | 'userId_aiModelId'
  >;

  export type UserAiModelAccessOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    aiModelId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserAiModelAccessCountOrderByAggregateInput;
    _max?: UserAiModelAccessMaxOrderByAggregateInput;
    _min?: UserAiModelAccessMinOrderByAggregateInput;
  };

  export type UserAiModelAccessScalarWhereWithAggregatesInput = {
    AND?:
      | UserAiModelAccessScalarWhereWithAggregatesInput
      | UserAiModelAccessScalarWhereWithAggregatesInput[];
    OR?: UserAiModelAccessScalarWhereWithAggregatesInput[];
    NOT?:
      | UserAiModelAccessScalarWhereWithAggregatesInput
      | UserAiModelAccessScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UserAiModelAccess'> | string;
    userId?: StringNullableWithAggregatesFilter<'UserAiModelAccess'> | string | null;
    aiModelId?: StringWithAggregatesFilter<'UserAiModelAccess'> | string;
    permission?: EnumPermissionWithAggregatesFilter<'UserAiModelAccess'> | $Enums.Permission;
    createdAt?: DateTimeWithAggregatesFilter<'UserAiModelAccess'> | Date | string;
  };

  export type UserAiBotAccessWhereInput = {
    AND?: UserAiBotAccessWhereInput | UserAiBotAccessWhereInput[];
    OR?: UserAiBotAccessWhereInput[];
    NOT?: UserAiBotAccessWhereInput | UserAiBotAccessWhereInput[];
    id?: StringFilter<'UserAiBotAccess'> | string;
    userId?: StringNullableFilter<'UserAiBotAccess'> | string | null;
    aiBotId?: StringFilter<'UserAiBotAccess'> | string;
    permission?: EnumPermissionFilter<'UserAiBotAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserAiBotAccess'> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    aiBot?: XOR<AiBotScalarRelationFilter, AiBotWhereInput>;
  };

  export type UserAiBotAccessOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    aiBotId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    aiBot?: AiBotOrderByWithRelationInput;
  };

  export type UserAiBotAccessWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_aiBotId?: UserAiBotAccessUserIdAiBotIdCompoundUniqueInput;
      AND?: UserAiBotAccessWhereInput | UserAiBotAccessWhereInput[];
      OR?: UserAiBotAccessWhereInput[];
      NOT?: UserAiBotAccessWhereInput | UserAiBotAccessWhereInput[];
      userId?: StringNullableFilter<'UserAiBotAccess'> | string | null;
      aiBotId?: StringFilter<'UserAiBotAccess'> | string;
      permission?: EnumPermissionFilter<'UserAiBotAccess'> | $Enums.Permission;
      createdAt?: DateTimeFilter<'UserAiBotAccess'> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      aiBot?: XOR<AiBotScalarRelationFilter, AiBotWhereInput>;
    },
    'id' | 'userId_aiBotId'
  >;

  export type UserAiBotAccessOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    aiBotId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
    _count?: UserAiBotAccessCountOrderByAggregateInput;
    _max?: UserAiBotAccessMaxOrderByAggregateInput;
    _min?: UserAiBotAccessMinOrderByAggregateInput;
  };

  export type UserAiBotAccessScalarWhereWithAggregatesInput = {
    AND?:
      | UserAiBotAccessScalarWhereWithAggregatesInput
      | UserAiBotAccessScalarWhereWithAggregatesInput[];
    OR?: UserAiBotAccessScalarWhereWithAggregatesInput[];
    NOT?:
      | UserAiBotAccessScalarWhereWithAggregatesInput
      | UserAiBotAccessScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UserAiBotAccess'> | string;
    userId?: StringNullableWithAggregatesFilter<'UserAiBotAccess'> | string | null;
    aiBotId?: StringWithAggregatesFilter<'UserAiBotAccess'> | string;
    permission?: EnumPermissionWithAggregatesFilter<'UserAiBotAccess'> | $Enums.Permission;
    createdAt?: DateTimeWithAggregatesFilter<'UserAiBotAccess'> | Date | string;
  };

  export type PaperlessInstanceWhereInput = {
    AND?: PaperlessInstanceWhereInput | PaperlessInstanceWhereInput[];
    OR?: PaperlessInstanceWhereInput[];
    NOT?: PaperlessInstanceWhereInput | PaperlessInstanceWhereInput[];
    id?: StringFilter<'PaperlessInstance'> | string;
    name?: StringFilter<'PaperlessInstance'> | string;
    apiUrl?: StringFilter<'PaperlessInstance'> | string;
    apiToken?: StringFilter<'PaperlessInstance'> | string;
    importFilterTags?: IntNullableListFilter<'PaperlessInstance'>;
    createdAt?: DateTimeFilter<'PaperlessInstance'> | Date | string;
    updatedAt?: DateTimeFilter<'PaperlessInstance'> | Date | string;
    autoProcessEnabled?: BoolFilter<'PaperlessInstance'> | boolean;
    scanCronExpression?: StringFilter<'PaperlessInstance'> | string;
    lastScanAt?: DateTimeNullableFilter<'PaperlessInstance'> | Date | string | null;
    nextScanAt?: DateTimeNullableFilter<'PaperlessInstance'> | Date | string | null;
    defaultAiBotId?: StringNullableFilter<'PaperlessInstance'> | string | null;
    autoApplyTitle?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyCorrespondent?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyDocumentType?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyTags?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyDate?: BoolFilter<'PaperlessInstance'> | boolean;
    ownerId?: StringFilter<'PaperlessInstance'> | string;
    defaultAiBot?: XOR<AiBotNullableScalarRelationFilter, AiBotWhereInput> | null;
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
    sharedWith?: UserPaperlessInstanceAccessListRelationFilter;
    documents?: PaperlessDocumentListRelationFilter;
    processingQueue?: ProcessingQueueListRelationFilter;
    importHistory?: ImportHistoryListRelationFilter;
  };

  export type PaperlessInstanceOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    apiUrl?: SortOrder;
    apiToken?: SortOrder;
    importFilterTags?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    autoProcessEnabled?: SortOrder;
    scanCronExpression?: SortOrder;
    lastScanAt?: SortOrderInput | SortOrder;
    nextScanAt?: SortOrderInput | SortOrder;
    defaultAiBotId?: SortOrderInput | SortOrder;
    autoApplyTitle?: SortOrder;
    autoApplyCorrespondent?: SortOrder;
    autoApplyDocumentType?: SortOrder;
    autoApplyTags?: SortOrder;
    autoApplyDate?: SortOrder;
    ownerId?: SortOrder;
    defaultAiBot?: AiBotOrderByWithRelationInput;
    owner?: UserOrderByWithRelationInput;
    sharedWith?: UserPaperlessInstanceAccessOrderByRelationAggregateInput;
    documents?: PaperlessDocumentOrderByRelationAggregateInput;
    processingQueue?: ProcessingQueueOrderByRelationAggregateInput;
    importHistory?: ImportHistoryOrderByRelationAggregateInput;
  };

  export type PaperlessInstanceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: PaperlessInstanceWhereInput | PaperlessInstanceWhereInput[];
      OR?: PaperlessInstanceWhereInput[];
      NOT?: PaperlessInstanceWhereInput | PaperlessInstanceWhereInput[];
      name?: StringFilter<'PaperlessInstance'> | string;
      apiUrl?: StringFilter<'PaperlessInstance'> | string;
      apiToken?: StringFilter<'PaperlessInstance'> | string;
      importFilterTags?: IntNullableListFilter<'PaperlessInstance'>;
      createdAt?: DateTimeFilter<'PaperlessInstance'> | Date | string;
      updatedAt?: DateTimeFilter<'PaperlessInstance'> | Date | string;
      autoProcessEnabled?: BoolFilter<'PaperlessInstance'> | boolean;
      scanCronExpression?: StringFilter<'PaperlessInstance'> | string;
      lastScanAt?: DateTimeNullableFilter<'PaperlessInstance'> | Date | string | null;
      nextScanAt?: DateTimeNullableFilter<'PaperlessInstance'> | Date | string | null;
      defaultAiBotId?: StringNullableFilter<'PaperlessInstance'> | string | null;
      autoApplyTitle?: BoolFilter<'PaperlessInstance'> | boolean;
      autoApplyCorrespondent?: BoolFilter<'PaperlessInstance'> | boolean;
      autoApplyDocumentType?: BoolFilter<'PaperlessInstance'> | boolean;
      autoApplyTags?: BoolFilter<'PaperlessInstance'> | boolean;
      autoApplyDate?: BoolFilter<'PaperlessInstance'> | boolean;
      ownerId?: StringFilter<'PaperlessInstance'> | string;
      defaultAiBot?: XOR<AiBotNullableScalarRelationFilter, AiBotWhereInput> | null;
      owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
      sharedWith?: UserPaperlessInstanceAccessListRelationFilter;
      documents?: PaperlessDocumentListRelationFilter;
      processingQueue?: ProcessingQueueListRelationFilter;
      importHistory?: ImportHistoryListRelationFilter;
    },
    'id'
  >;

  export type PaperlessInstanceOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    apiUrl?: SortOrder;
    apiToken?: SortOrder;
    importFilterTags?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    autoProcessEnabled?: SortOrder;
    scanCronExpression?: SortOrder;
    lastScanAt?: SortOrderInput | SortOrder;
    nextScanAt?: SortOrderInput | SortOrder;
    defaultAiBotId?: SortOrderInput | SortOrder;
    autoApplyTitle?: SortOrder;
    autoApplyCorrespondent?: SortOrder;
    autoApplyDocumentType?: SortOrder;
    autoApplyTags?: SortOrder;
    autoApplyDate?: SortOrder;
    ownerId?: SortOrder;
    _count?: PaperlessInstanceCountOrderByAggregateInput;
    _avg?: PaperlessInstanceAvgOrderByAggregateInput;
    _max?: PaperlessInstanceMaxOrderByAggregateInput;
    _min?: PaperlessInstanceMinOrderByAggregateInput;
    _sum?: PaperlessInstanceSumOrderByAggregateInput;
  };

  export type PaperlessInstanceScalarWhereWithAggregatesInput = {
    AND?:
      | PaperlessInstanceScalarWhereWithAggregatesInput
      | PaperlessInstanceScalarWhereWithAggregatesInput[];
    OR?: PaperlessInstanceScalarWhereWithAggregatesInput[];
    NOT?:
      | PaperlessInstanceScalarWhereWithAggregatesInput
      | PaperlessInstanceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PaperlessInstance'> | string;
    name?: StringWithAggregatesFilter<'PaperlessInstance'> | string;
    apiUrl?: StringWithAggregatesFilter<'PaperlessInstance'> | string;
    apiToken?: StringWithAggregatesFilter<'PaperlessInstance'> | string;
    importFilterTags?: IntNullableListFilter<'PaperlessInstance'>;
    createdAt?: DateTimeWithAggregatesFilter<'PaperlessInstance'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'PaperlessInstance'> | Date | string;
    autoProcessEnabled?: BoolWithAggregatesFilter<'PaperlessInstance'> | boolean;
    scanCronExpression?: StringWithAggregatesFilter<'PaperlessInstance'> | string;
    lastScanAt?: DateTimeNullableWithAggregatesFilter<'PaperlessInstance'> | Date | string | null;
    nextScanAt?: DateTimeNullableWithAggregatesFilter<'PaperlessInstance'> | Date | string | null;
    defaultAiBotId?: StringNullableWithAggregatesFilter<'PaperlessInstance'> | string | null;
    autoApplyTitle?: BoolWithAggregatesFilter<'PaperlessInstance'> | boolean;
    autoApplyCorrespondent?: BoolWithAggregatesFilter<'PaperlessInstance'> | boolean;
    autoApplyDocumentType?: BoolWithAggregatesFilter<'PaperlessInstance'> | boolean;
    autoApplyTags?: BoolWithAggregatesFilter<'PaperlessInstance'> | boolean;
    autoApplyDate?: BoolWithAggregatesFilter<'PaperlessInstance'> | boolean;
    ownerId?: StringWithAggregatesFilter<'PaperlessInstance'> | string;
  };

  export type AiAccountWhereInput = {
    AND?: AiAccountWhereInput | AiAccountWhereInput[];
    OR?: AiAccountWhereInput[];
    NOT?: AiAccountWhereInput | AiAccountWhereInput[];
    id?: StringFilter<'AiAccount'> | string;
    name?: StringFilter<'AiAccount'> | string;
    provider?: StringFilter<'AiAccount'> | string;
    apiKey?: StringFilter<'AiAccount'> | string;
    baseUrl?: StringNullableFilter<'AiAccount'> | string | null;
    isActive?: BoolFilter<'AiAccount'> | boolean;
    createdAt?: DateTimeFilter<'AiAccount'> | Date | string;
    updatedAt?: DateTimeFilter<'AiAccount'> | Date | string;
    ownerId?: StringFilter<'AiAccount'> | string;
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
    sharedWith?: UserAiAccountAccessListRelationFilter;
    models?: AiModelListRelationFilter;
    aiUsageMetrics?: AiUsageMetricListRelationFilter;
  };

  export type AiAccountOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    provider?: SortOrder;
    apiKey?: SortOrder;
    baseUrl?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    owner?: UserOrderByWithRelationInput;
    sharedWith?: UserAiAccountAccessOrderByRelationAggregateInput;
    models?: AiModelOrderByRelationAggregateInput;
    aiUsageMetrics?: AiUsageMetricOrderByRelationAggregateInput;
  };

  export type AiAccountWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AiAccountWhereInput | AiAccountWhereInput[];
      OR?: AiAccountWhereInput[];
      NOT?: AiAccountWhereInput | AiAccountWhereInput[];
      name?: StringFilter<'AiAccount'> | string;
      provider?: StringFilter<'AiAccount'> | string;
      apiKey?: StringFilter<'AiAccount'> | string;
      baseUrl?: StringNullableFilter<'AiAccount'> | string | null;
      isActive?: BoolFilter<'AiAccount'> | boolean;
      createdAt?: DateTimeFilter<'AiAccount'> | Date | string;
      updatedAt?: DateTimeFilter<'AiAccount'> | Date | string;
      ownerId?: StringFilter<'AiAccount'> | string;
      owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
      sharedWith?: UserAiAccountAccessListRelationFilter;
      models?: AiModelListRelationFilter;
      aiUsageMetrics?: AiUsageMetricListRelationFilter;
    },
    'id'
  >;

  export type AiAccountOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    provider?: SortOrder;
    apiKey?: SortOrder;
    baseUrl?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    _count?: AiAccountCountOrderByAggregateInput;
    _max?: AiAccountMaxOrderByAggregateInput;
    _min?: AiAccountMinOrderByAggregateInput;
  };

  export type AiAccountScalarWhereWithAggregatesInput = {
    AND?: AiAccountScalarWhereWithAggregatesInput | AiAccountScalarWhereWithAggregatesInput[];
    OR?: AiAccountScalarWhereWithAggregatesInput[];
    NOT?: AiAccountScalarWhereWithAggregatesInput | AiAccountScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AiAccount'> | string;
    name?: StringWithAggregatesFilter<'AiAccount'> | string;
    provider?: StringWithAggregatesFilter<'AiAccount'> | string;
    apiKey?: StringWithAggregatesFilter<'AiAccount'> | string;
    baseUrl?: StringNullableWithAggregatesFilter<'AiAccount'> | string | null;
    isActive?: BoolWithAggregatesFilter<'AiAccount'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'AiAccount'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'AiAccount'> | Date | string;
    ownerId?: StringWithAggregatesFilter<'AiAccount'> | string;
  };

  export type AiModelWhereInput = {
    AND?: AiModelWhereInput | AiModelWhereInput[];
    OR?: AiModelWhereInput[];
    NOT?: AiModelWhereInput | AiModelWhereInput[];
    id?: StringFilter<'AiModel'> | string;
    name?: StringFilter<'AiModel'> | string;
    modelIdentifier?: StringFilter<'AiModel'> | string;
    inputTokenPrice?: FloatNullableFilter<'AiModel'> | number | null;
    outputTokenPrice?: FloatNullableFilter<'AiModel'> | number | null;
    isActive?: BoolFilter<'AiModel'> | boolean;
    createdAt?: DateTimeFilter<'AiModel'> | Date | string;
    updatedAt?: DateTimeFilter<'AiModel'> | Date | string;
    ownerId?: StringFilter<'AiModel'> | string;
    aiAccountId?: StringFilter<'AiModel'> | string;
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
    aiAccount?: XOR<AiAccountScalarRelationFilter, AiAccountWhereInput>;
    sharedWith?: UserAiModelAccessListRelationFilter;
    bots?: AiBotListRelationFilter;
    aiUsageMetrics?: AiUsageMetricListRelationFilter;
  };

  export type AiModelOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    modelIdentifier?: SortOrder;
    inputTokenPrice?: SortOrderInput | SortOrder;
    outputTokenPrice?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiAccountId?: SortOrder;
    owner?: UserOrderByWithRelationInput;
    aiAccount?: AiAccountOrderByWithRelationInput;
    sharedWith?: UserAiModelAccessOrderByRelationAggregateInput;
    bots?: AiBotOrderByRelationAggregateInput;
    aiUsageMetrics?: AiUsageMetricOrderByRelationAggregateInput;
  };

  export type AiModelWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AiModelWhereInput | AiModelWhereInput[];
      OR?: AiModelWhereInput[];
      NOT?: AiModelWhereInput | AiModelWhereInput[];
      name?: StringFilter<'AiModel'> | string;
      modelIdentifier?: StringFilter<'AiModel'> | string;
      inputTokenPrice?: FloatNullableFilter<'AiModel'> | number | null;
      outputTokenPrice?: FloatNullableFilter<'AiModel'> | number | null;
      isActive?: BoolFilter<'AiModel'> | boolean;
      createdAt?: DateTimeFilter<'AiModel'> | Date | string;
      updatedAt?: DateTimeFilter<'AiModel'> | Date | string;
      ownerId?: StringFilter<'AiModel'> | string;
      aiAccountId?: StringFilter<'AiModel'> | string;
      owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
      aiAccount?: XOR<AiAccountScalarRelationFilter, AiAccountWhereInput>;
      sharedWith?: UserAiModelAccessListRelationFilter;
      bots?: AiBotListRelationFilter;
      aiUsageMetrics?: AiUsageMetricListRelationFilter;
    },
    'id'
  >;

  export type AiModelOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    modelIdentifier?: SortOrder;
    inputTokenPrice?: SortOrderInput | SortOrder;
    outputTokenPrice?: SortOrderInput | SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiAccountId?: SortOrder;
    _count?: AiModelCountOrderByAggregateInput;
    _avg?: AiModelAvgOrderByAggregateInput;
    _max?: AiModelMaxOrderByAggregateInput;
    _min?: AiModelMinOrderByAggregateInput;
    _sum?: AiModelSumOrderByAggregateInput;
  };

  export type AiModelScalarWhereWithAggregatesInput = {
    AND?: AiModelScalarWhereWithAggregatesInput | AiModelScalarWhereWithAggregatesInput[];
    OR?: AiModelScalarWhereWithAggregatesInput[];
    NOT?: AiModelScalarWhereWithAggregatesInput | AiModelScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AiModel'> | string;
    name?: StringWithAggregatesFilter<'AiModel'> | string;
    modelIdentifier?: StringWithAggregatesFilter<'AiModel'> | string;
    inputTokenPrice?: FloatNullableWithAggregatesFilter<'AiModel'> | number | null;
    outputTokenPrice?: FloatNullableWithAggregatesFilter<'AiModel'> | number | null;
    isActive?: BoolWithAggregatesFilter<'AiModel'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'AiModel'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'AiModel'> | Date | string;
    ownerId?: StringWithAggregatesFilter<'AiModel'> | string;
    aiAccountId?: StringWithAggregatesFilter<'AiModel'> | string;
  };

  export type AiBotWhereInput = {
    AND?: AiBotWhereInput | AiBotWhereInput[];
    OR?: AiBotWhereInput[];
    NOT?: AiBotWhereInput | AiBotWhereInput[];
    id?: StringFilter<'AiBot'> | string;
    name?: StringFilter<'AiBot'> | string;
    systemPrompt?: StringFilter<'AiBot'> | string;
    responseLanguage?: StringFilter<'AiBot'> | string;
    createdAt?: DateTimeFilter<'AiBot'> | Date | string;
    updatedAt?: DateTimeFilter<'AiBot'> | Date | string;
    ownerId?: StringFilter<'AiBot'> | string;
    aiModelId?: StringFilter<'AiBot'> | string;
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
    aiModel?: XOR<AiModelScalarRelationFilter, AiModelWhereInput>;
    sharedWith?: UserAiBotAccessListRelationFilter;
    aiUsageMetrics?: AiUsageMetricListRelationFilter;
    defaultForInstances?: PaperlessInstanceListRelationFilter;
    processingQueueItems?: ProcessingQueueListRelationFilter;
  };

  export type AiBotOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    systemPrompt?: SortOrder;
    responseLanguage?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiModelId?: SortOrder;
    owner?: UserOrderByWithRelationInput;
    aiModel?: AiModelOrderByWithRelationInput;
    sharedWith?: UserAiBotAccessOrderByRelationAggregateInput;
    aiUsageMetrics?: AiUsageMetricOrderByRelationAggregateInput;
    defaultForInstances?: PaperlessInstanceOrderByRelationAggregateInput;
    processingQueueItems?: ProcessingQueueOrderByRelationAggregateInput;
  };

  export type AiBotWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AiBotWhereInput | AiBotWhereInput[];
      OR?: AiBotWhereInput[];
      NOT?: AiBotWhereInput | AiBotWhereInput[];
      name?: StringFilter<'AiBot'> | string;
      systemPrompt?: StringFilter<'AiBot'> | string;
      responseLanguage?: StringFilter<'AiBot'> | string;
      createdAt?: DateTimeFilter<'AiBot'> | Date | string;
      updatedAt?: DateTimeFilter<'AiBot'> | Date | string;
      ownerId?: StringFilter<'AiBot'> | string;
      aiModelId?: StringFilter<'AiBot'> | string;
      owner?: XOR<UserScalarRelationFilter, UserWhereInput>;
      aiModel?: XOR<AiModelScalarRelationFilter, AiModelWhereInput>;
      sharedWith?: UserAiBotAccessListRelationFilter;
      aiUsageMetrics?: AiUsageMetricListRelationFilter;
      defaultForInstances?: PaperlessInstanceListRelationFilter;
      processingQueueItems?: ProcessingQueueListRelationFilter;
    },
    'id'
  >;

  export type AiBotOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    systemPrompt?: SortOrder;
    responseLanguage?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiModelId?: SortOrder;
    _count?: AiBotCountOrderByAggregateInput;
    _max?: AiBotMaxOrderByAggregateInput;
    _min?: AiBotMinOrderByAggregateInput;
  };

  export type AiBotScalarWhereWithAggregatesInput = {
    AND?: AiBotScalarWhereWithAggregatesInput | AiBotScalarWhereWithAggregatesInput[];
    OR?: AiBotScalarWhereWithAggregatesInput[];
    NOT?: AiBotScalarWhereWithAggregatesInput | AiBotScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AiBot'> | string;
    name?: StringWithAggregatesFilter<'AiBot'> | string;
    systemPrompt?: StringWithAggregatesFilter<'AiBot'> | string;
    responseLanguage?: StringWithAggregatesFilter<'AiBot'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'AiBot'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'AiBot'> | Date | string;
    ownerId?: StringWithAggregatesFilter<'AiBot'> | string;
    aiModelId?: StringWithAggregatesFilter<'AiBot'> | string;
  };

  export type PaperlessDocumentWhereInput = {
    AND?: PaperlessDocumentWhereInput | PaperlessDocumentWhereInput[];
    OR?: PaperlessDocumentWhereInput[];
    NOT?: PaperlessDocumentWhereInput | PaperlessDocumentWhereInput[];
    id?: StringFilter<'PaperlessDocument'> | string;
    paperlessId?: IntFilter<'PaperlessDocument'> | number;
    title?: StringFilter<'PaperlessDocument'> | string;
    content?: StringFilter<'PaperlessDocument'> | string;
    correspondentId?: IntNullableFilter<'PaperlessDocument'> | number | null;
    tagIds?: IntNullableListFilter<'PaperlessDocument'>;
    documentDate?: DateTimeNullableFilter<'PaperlessDocument'> | Date | string | null;
    paperlessModified?: DateTimeNullableFilter<'PaperlessDocument'> | Date | string | null;
    importedAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
    createdAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
    updatedAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
    paperlessInstanceId?: StringFilter<'PaperlessDocument'> | string;
    paperlessInstance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
    processingResults?: DocumentProcessingResultListRelationFilter;
    processingQueueItems?: ProcessingQueueListRelationFilter;
  };

  export type PaperlessDocumentOrderByWithRelationInput = {
    id?: SortOrder;
    paperlessId?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    correspondentId?: SortOrderInput | SortOrder;
    tagIds?: SortOrder;
    documentDate?: SortOrderInput | SortOrder;
    paperlessModified?: SortOrderInput | SortOrder;
    importedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    paperlessInstance?: PaperlessInstanceOrderByWithRelationInput;
    processingResults?: DocumentProcessingResultOrderByRelationAggregateInput;
    processingQueueItems?: ProcessingQueueOrderByRelationAggregateInput;
  };

  export type PaperlessDocumentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      paperlessInstanceId_paperlessId?: PaperlessDocumentPaperlessInstanceIdPaperlessIdCompoundUniqueInput;
      AND?: PaperlessDocumentWhereInput | PaperlessDocumentWhereInput[];
      OR?: PaperlessDocumentWhereInput[];
      NOT?: PaperlessDocumentWhereInput | PaperlessDocumentWhereInput[];
      paperlessId?: IntFilter<'PaperlessDocument'> | number;
      title?: StringFilter<'PaperlessDocument'> | string;
      content?: StringFilter<'PaperlessDocument'> | string;
      correspondentId?: IntNullableFilter<'PaperlessDocument'> | number | null;
      tagIds?: IntNullableListFilter<'PaperlessDocument'>;
      documentDate?: DateTimeNullableFilter<'PaperlessDocument'> | Date | string | null;
      paperlessModified?: DateTimeNullableFilter<'PaperlessDocument'> | Date | string | null;
      importedAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
      createdAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
      updatedAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
      paperlessInstanceId?: StringFilter<'PaperlessDocument'> | string;
      paperlessInstance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
      processingResults?: DocumentProcessingResultListRelationFilter;
      processingQueueItems?: ProcessingQueueListRelationFilter;
    },
    'id' | 'paperlessInstanceId_paperlessId'
  >;

  export type PaperlessDocumentOrderByWithAggregationInput = {
    id?: SortOrder;
    paperlessId?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    correspondentId?: SortOrderInput | SortOrder;
    tagIds?: SortOrder;
    documentDate?: SortOrderInput | SortOrder;
    paperlessModified?: SortOrderInput | SortOrder;
    importedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    _count?: PaperlessDocumentCountOrderByAggregateInput;
    _avg?: PaperlessDocumentAvgOrderByAggregateInput;
    _max?: PaperlessDocumentMaxOrderByAggregateInput;
    _min?: PaperlessDocumentMinOrderByAggregateInput;
    _sum?: PaperlessDocumentSumOrderByAggregateInput;
  };

  export type PaperlessDocumentScalarWhereWithAggregatesInput = {
    AND?:
      | PaperlessDocumentScalarWhereWithAggregatesInput
      | PaperlessDocumentScalarWhereWithAggregatesInput[];
    OR?: PaperlessDocumentScalarWhereWithAggregatesInput[];
    NOT?:
      | PaperlessDocumentScalarWhereWithAggregatesInput
      | PaperlessDocumentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PaperlessDocument'> | string;
    paperlessId?: IntWithAggregatesFilter<'PaperlessDocument'> | number;
    title?: StringWithAggregatesFilter<'PaperlessDocument'> | string;
    content?: StringWithAggregatesFilter<'PaperlessDocument'> | string;
    correspondentId?: IntNullableWithAggregatesFilter<'PaperlessDocument'> | number | null;
    tagIds?: IntNullableListFilter<'PaperlessDocument'>;
    documentDate?: DateTimeNullableWithAggregatesFilter<'PaperlessDocument'> | Date | string | null;
    paperlessModified?:
      | DateTimeNullableWithAggregatesFilter<'PaperlessDocument'>
      | Date
      | string
      | null;
    importedAt?: DateTimeWithAggregatesFilter<'PaperlessDocument'> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<'PaperlessDocument'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'PaperlessDocument'> | Date | string;
    paperlessInstanceId?: StringWithAggregatesFilter<'PaperlessDocument'> | string;
  };

  export type DocumentProcessingResultWhereInput = {
    AND?: DocumentProcessingResultWhereInput | DocumentProcessingResultWhereInput[];
    OR?: DocumentProcessingResultWhereInput[];
    NOT?: DocumentProcessingResultWhereInput | DocumentProcessingResultWhereInput[];
    id?: StringFilter<'DocumentProcessingResult'> | string;
    processedAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
    aiProvider?: StringFilter<'DocumentProcessingResult'> | string;
    inputTokens?: IntFilter<'DocumentProcessingResult'> | number;
    outputTokens?: IntFilter<'DocumentProcessingResult'> | number;
    estimatedCost?: FloatNullableFilter<'DocumentProcessingResult'> | number | null;
    changes?: JsonNullableFilter<'DocumentProcessingResult'>;
    toolCalls?: JsonNullableFilter<'DocumentProcessingResult'>;
    originalTitle?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
    originalCorrespondent?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
    originalDocumentType?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
    originalTags?: StringNullableListFilter<'DocumentProcessingResult'>;
    createdAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
    updatedAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
    documentId?: StringFilter<'DocumentProcessingResult'> | string;
    document?: XOR<PaperlessDocumentScalarRelationFilter, PaperlessDocumentWhereInput>;
  };

  export type DocumentProcessingResultOrderByWithRelationInput = {
    id?: SortOrder;
    processedAt?: SortOrder;
    aiProvider?: SortOrder;
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrderInput | SortOrder;
    changes?: SortOrderInput | SortOrder;
    toolCalls?: SortOrderInput | SortOrder;
    originalTitle?: SortOrderInput | SortOrder;
    originalCorrespondent?: SortOrderInput | SortOrder;
    originalDocumentType?: SortOrderInput | SortOrder;
    originalTags?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    documentId?: SortOrder;
    document?: PaperlessDocumentOrderByWithRelationInput;
  };

  export type DocumentProcessingResultWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: DocumentProcessingResultWhereInput | DocumentProcessingResultWhereInput[];
      OR?: DocumentProcessingResultWhereInput[];
      NOT?: DocumentProcessingResultWhereInput | DocumentProcessingResultWhereInput[];
      processedAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
      aiProvider?: StringFilter<'DocumentProcessingResult'> | string;
      inputTokens?: IntFilter<'DocumentProcessingResult'> | number;
      outputTokens?: IntFilter<'DocumentProcessingResult'> | number;
      estimatedCost?: FloatNullableFilter<'DocumentProcessingResult'> | number | null;
      changes?: JsonNullableFilter<'DocumentProcessingResult'>;
      toolCalls?: JsonNullableFilter<'DocumentProcessingResult'>;
      originalTitle?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
      originalCorrespondent?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
      originalDocumentType?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
      originalTags?: StringNullableListFilter<'DocumentProcessingResult'>;
      createdAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
      updatedAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
      documentId?: StringFilter<'DocumentProcessingResult'> | string;
      document?: XOR<PaperlessDocumentScalarRelationFilter, PaperlessDocumentWhereInput>;
    },
    'id'
  >;

  export type DocumentProcessingResultOrderByWithAggregationInput = {
    id?: SortOrder;
    processedAt?: SortOrder;
    aiProvider?: SortOrder;
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrderInput | SortOrder;
    changes?: SortOrderInput | SortOrder;
    toolCalls?: SortOrderInput | SortOrder;
    originalTitle?: SortOrderInput | SortOrder;
    originalCorrespondent?: SortOrderInput | SortOrder;
    originalDocumentType?: SortOrderInput | SortOrder;
    originalTags?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    documentId?: SortOrder;
    _count?: DocumentProcessingResultCountOrderByAggregateInput;
    _avg?: DocumentProcessingResultAvgOrderByAggregateInput;
    _max?: DocumentProcessingResultMaxOrderByAggregateInput;
    _min?: DocumentProcessingResultMinOrderByAggregateInput;
    _sum?: DocumentProcessingResultSumOrderByAggregateInput;
  };

  export type DocumentProcessingResultScalarWhereWithAggregatesInput = {
    AND?:
      | DocumentProcessingResultScalarWhereWithAggregatesInput
      | DocumentProcessingResultScalarWhereWithAggregatesInput[];
    OR?: DocumentProcessingResultScalarWhereWithAggregatesInput[];
    NOT?:
      | DocumentProcessingResultScalarWhereWithAggregatesInput
      | DocumentProcessingResultScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'DocumentProcessingResult'> | string;
    processedAt?: DateTimeWithAggregatesFilter<'DocumentProcessingResult'> | Date | string;
    aiProvider?: StringWithAggregatesFilter<'DocumentProcessingResult'> | string;
    inputTokens?: IntWithAggregatesFilter<'DocumentProcessingResult'> | number;
    outputTokens?: IntWithAggregatesFilter<'DocumentProcessingResult'> | number;
    estimatedCost?: FloatNullableWithAggregatesFilter<'DocumentProcessingResult'> | number | null;
    changes?: JsonNullableWithAggregatesFilter<'DocumentProcessingResult'>;
    toolCalls?: JsonNullableWithAggregatesFilter<'DocumentProcessingResult'>;
    originalTitle?: StringNullableWithAggregatesFilter<'DocumentProcessingResult'> | string | null;
    originalCorrespondent?:
      | StringNullableWithAggregatesFilter<'DocumentProcessingResult'>
      | string
      | null;
    originalDocumentType?:
      | StringNullableWithAggregatesFilter<'DocumentProcessingResult'>
      | string
      | null;
    originalTags?: StringNullableListFilter<'DocumentProcessingResult'>;
    createdAt?: DateTimeWithAggregatesFilter<'DocumentProcessingResult'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'DocumentProcessingResult'> | Date | string;
    documentId?: StringWithAggregatesFilter<'DocumentProcessingResult'> | string;
  };

  export type ProcessingQueueWhereInput = {
    AND?: ProcessingQueueWhereInput | ProcessingQueueWhereInput[];
    OR?: ProcessingQueueWhereInput[];
    NOT?: ProcessingQueueWhereInput | ProcessingQueueWhereInput[];
    id?: StringFilter<'ProcessingQueue'> | string;
    paperlessDocumentId?: IntFilter<'ProcessingQueue'> | number;
    status?: StringFilter<'ProcessingQueue'> | string;
    priority?: IntFilter<'ProcessingQueue'> | number;
    attempts?: IntFilter<'ProcessingQueue'> | number;
    maxAttempts?: IntFilter<'ProcessingQueue'> | number;
    lastError?: StringNullableFilter<'ProcessingQueue'> | string | null;
    scheduledFor?: DateTimeFilter<'ProcessingQueue'> | Date | string;
    startedAt?: DateTimeNullableFilter<'ProcessingQueue'> | Date | string | null;
    completedAt?: DateTimeNullableFilter<'ProcessingQueue'> | Date | string | null;
    createdAt?: DateTimeFilter<'ProcessingQueue'> | Date | string;
    updatedAt?: DateTimeFilter<'ProcessingQueue'> | Date | string;
    paperlessInstanceId?: StringFilter<'ProcessingQueue'> | string;
    documentId?: StringNullableFilter<'ProcessingQueue'> | string | null;
    aiBotId?: StringNullableFilter<'ProcessingQueue'> | string | null;
    paperlessInstance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
    document?: XOR<
      PaperlessDocumentNullableScalarRelationFilter,
      PaperlessDocumentWhereInput
    > | null;
    aiBot?: XOR<AiBotNullableScalarRelationFilter, AiBotWhereInput> | null;
  };

  export type ProcessingQueueOrderByWithRelationInput = {
    id?: SortOrder;
    paperlessDocumentId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastError?: SortOrderInput | SortOrder;
    scheduledFor?: SortOrder;
    startedAt?: SortOrderInput | SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    documentId?: SortOrderInput | SortOrder;
    aiBotId?: SortOrderInput | SortOrder;
    paperlessInstance?: PaperlessInstanceOrderByWithRelationInput;
    document?: PaperlessDocumentOrderByWithRelationInput;
    aiBot?: AiBotOrderByWithRelationInput;
  };

  export type ProcessingQueueWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      paperlessInstanceId_paperlessDocumentId?: ProcessingQueuePaperlessInstanceIdPaperlessDocumentIdCompoundUniqueInput;
      AND?: ProcessingQueueWhereInput | ProcessingQueueWhereInput[];
      OR?: ProcessingQueueWhereInput[];
      NOT?: ProcessingQueueWhereInput | ProcessingQueueWhereInput[];
      paperlessDocumentId?: IntFilter<'ProcessingQueue'> | number;
      status?: StringFilter<'ProcessingQueue'> | string;
      priority?: IntFilter<'ProcessingQueue'> | number;
      attempts?: IntFilter<'ProcessingQueue'> | number;
      maxAttempts?: IntFilter<'ProcessingQueue'> | number;
      lastError?: StringNullableFilter<'ProcessingQueue'> | string | null;
      scheduledFor?: DateTimeFilter<'ProcessingQueue'> | Date | string;
      startedAt?: DateTimeNullableFilter<'ProcessingQueue'> | Date | string | null;
      completedAt?: DateTimeNullableFilter<'ProcessingQueue'> | Date | string | null;
      createdAt?: DateTimeFilter<'ProcessingQueue'> | Date | string;
      updatedAt?: DateTimeFilter<'ProcessingQueue'> | Date | string;
      paperlessInstanceId?: StringFilter<'ProcessingQueue'> | string;
      documentId?: StringNullableFilter<'ProcessingQueue'> | string | null;
      aiBotId?: StringNullableFilter<'ProcessingQueue'> | string | null;
      paperlessInstance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
      document?: XOR<
        PaperlessDocumentNullableScalarRelationFilter,
        PaperlessDocumentWhereInput
      > | null;
      aiBot?: XOR<AiBotNullableScalarRelationFilter, AiBotWhereInput> | null;
    },
    'id' | 'paperlessInstanceId_paperlessDocumentId'
  >;

  export type ProcessingQueueOrderByWithAggregationInput = {
    id?: SortOrder;
    paperlessDocumentId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastError?: SortOrderInput | SortOrder;
    scheduledFor?: SortOrder;
    startedAt?: SortOrderInput | SortOrder;
    completedAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    documentId?: SortOrderInput | SortOrder;
    aiBotId?: SortOrderInput | SortOrder;
    _count?: ProcessingQueueCountOrderByAggregateInput;
    _avg?: ProcessingQueueAvgOrderByAggregateInput;
    _max?: ProcessingQueueMaxOrderByAggregateInput;
    _min?: ProcessingQueueMinOrderByAggregateInput;
    _sum?: ProcessingQueueSumOrderByAggregateInput;
  };

  export type ProcessingQueueScalarWhereWithAggregatesInput = {
    AND?:
      | ProcessingQueueScalarWhereWithAggregatesInput
      | ProcessingQueueScalarWhereWithAggregatesInput[];
    OR?: ProcessingQueueScalarWhereWithAggregatesInput[];
    NOT?:
      | ProcessingQueueScalarWhereWithAggregatesInput
      | ProcessingQueueScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ProcessingQueue'> | string;
    paperlessDocumentId?: IntWithAggregatesFilter<'ProcessingQueue'> | number;
    status?: StringWithAggregatesFilter<'ProcessingQueue'> | string;
    priority?: IntWithAggregatesFilter<'ProcessingQueue'> | number;
    attempts?: IntWithAggregatesFilter<'ProcessingQueue'> | number;
    maxAttempts?: IntWithAggregatesFilter<'ProcessingQueue'> | number;
    lastError?: StringNullableWithAggregatesFilter<'ProcessingQueue'> | string | null;
    scheduledFor?: DateTimeWithAggregatesFilter<'ProcessingQueue'> | Date | string;
    startedAt?: DateTimeNullableWithAggregatesFilter<'ProcessingQueue'> | Date | string | null;
    completedAt?: DateTimeNullableWithAggregatesFilter<'ProcessingQueue'> | Date | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'ProcessingQueue'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'ProcessingQueue'> | Date | string;
    paperlessInstanceId?: StringWithAggregatesFilter<'ProcessingQueue'> | string;
    documentId?: StringNullableWithAggregatesFilter<'ProcessingQueue'> | string | null;
    aiBotId?: StringNullableWithAggregatesFilter<'ProcessingQueue'> | string | null;
  };

  export type ImportHistoryWhereInput = {
    AND?: ImportHistoryWhereInput | ImportHistoryWhereInput[];
    OR?: ImportHistoryWhereInput[];
    NOT?: ImportHistoryWhereInput | ImportHistoryWhereInput[];
    id?: StringFilter<'ImportHistory'> | string;
    importedAt?: DateTimeFilter<'ImportHistory'> | Date | string;
    documentsImported?: IntFilter<'ImportHistory'> | number;
    documentsUpdated?: IntFilter<'ImportHistory'> | number;
    documentsUnchanged?: IntFilter<'ImportHistory'> | number;
    totalInPaperless?: IntFilter<'ImportHistory'> | number;
    paperlessInstanceId?: StringFilter<'ImportHistory'> | string;
    paperlessInstance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
  };

  export type ImportHistoryOrderByWithRelationInput = {
    id?: SortOrder;
    importedAt?: SortOrder;
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
    paperlessInstanceId?: SortOrder;
    paperlessInstance?: PaperlessInstanceOrderByWithRelationInput;
  };

  export type ImportHistoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ImportHistoryWhereInput | ImportHistoryWhereInput[];
      OR?: ImportHistoryWhereInput[];
      NOT?: ImportHistoryWhereInput | ImportHistoryWhereInput[];
      importedAt?: DateTimeFilter<'ImportHistory'> | Date | string;
      documentsImported?: IntFilter<'ImportHistory'> | number;
      documentsUpdated?: IntFilter<'ImportHistory'> | number;
      documentsUnchanged?: IntFilter<'ImportHistory'> | number;
      totalInPaperless?: IntFilter<'ImportHistory'> | number;
      paperlessInstanceId?: StringFilter<'ImportHistory'> | string;
      paperlessInstance?: XOR<PaperlessInstanceScalarRelationFilter, PaperlessInstanceWhereInput>;
    },
    'id'
  >;

  export type ImportHistoryOrderByWithAggregationInput = {
    id?: SortOrder;
    importedAt?: SortOrder;
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
    paperlessInstanceId?: SortOrder;
    _count?: ImportHistoryCountOrderByAggregateInput;
    _avg?: ImportHistoryAvgOrderByAggregateInput;
    _max?: ImportHistoryMaxOrderByAggregateInput;
    _min?: ImportHistoryMinOrderByAggregateInput;
    _sum?: ImportHistorySumOrderByAggregateInput;
  };

  export type ImportHistoryScalarWhereWithAggregatesInput = {
    AND?:
      | ImportHistoryScalarWhereWithAggregatesInput
      | ImportHistoryScalarWhereWithAggregatesInput[];
    OR?: ImportHistoryScalarWhereWithAggregatesInput[];
    NOT?:
      | ImportHistoryScalarWhereWithAggregatesInput
      | ImportHistoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ImportHistory'> | string;
    importedAt?: DateTimeWithAggregatesFilter<'ImportHistory'> | Date | string;
    documentsImported?: IntWithAggregatesFilter<'ImportHistory'> | number;
    documentsUpdated?: IntWithAggregatesFilter<'ImportHistory'> | number;
    documentsUnchanged?: IntWithAggregatesFilter<'ImportHistory'> | number;
    totalInPaperless?: IntWithAggregatesFilter<'ImportHistory'> | number;
    paperlessInstanceId?: StringWithAggregatesFilter<'ImportHistory'> | string;
  };

  export type AiUsageMetricWhereInput = {
    AND?: AiUsageMetricWhereInput | AiUsageMetricWhereInput[];
    OR?: AiUsageMetricWhereInput[];
    NOT?: AiUsageMetricWhereInput | AiUsageMetricWhereInput[];
    id?: StringFilter<'AiUsageMetric'> | string;
    provider?: StringFilter<'AiUsageMetric'> | string;
    model?: StringFilter<'AiUsageMetric'> | string;
    promptTokens?: IntFilter<'AiUsageMetric'> | number;
    completionTokens?: IntFilter<'AiUsageMetric'> | number;
    totalTokens?: IntFilter<'AiUsageMetric'> | number;
    estimatedCost?: FloatNullableFilter<'AiUsageMetric'> | number | null;
    documentId?: IntNullableFilter<'AiUsageMetric'> | number | null;
    createdAt?: DateTimeFilter<'AiUsageMetric'> | Date | string;
    userId?: StringFilter<'AiUsageMetric'> | string;
    aiAccountId?: StringFilter<'AiUsageMetric'> | string;
    aiModelId?: StringNullableFilter<'AiUsageMetric'> | string | null;
    aiBotId?: StringNullableFilter<'AiUsageMetric'> | string | null;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    aiAccount?: XOR<AiAccountScalarRelationFilter, AiAccountWhereInput>;
    aiModel?: XOR<AiModelNullableScalarRelationFilter, AiModelWhereInput> | null;
    aiBot?: XOR<AiBotNullableScalarRelationFilter, AiBotWhereInput> | null;
  };

  export type AiUsageMetricOrderByWithRelationInput = {
    id?: SortOrder;
    provider?: SortOrder;
    model?: SortOrder;
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrderInput | SortOrder;
    documentId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    aiModelId?: SortOrderInput | SortOrder;
    aiBotId?: SortOrderInput | SortOrder;
    user?: UserOrderByWithRelationInput;
    aiAccount?: AiAccountOrderByWithRelationInput;
    aiModel?: AiModelOrderByWithRelationInput;
    aiBot?: AiBotOrderByWithRelationInput;
  };

  export type AiUsageMetricWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AiUsageMetricWhereInput | AiUsageMetricWhereInput[];
      OR?: AiUsageMetricWhereInput[];
      NOT?: AiUsageMetricWhereInput | AiUsageMetricWhereInput[];
      provider?: StringFilter<'AiUsageMetric'> | string;
      model?: StringFilter<'AiUsageMetric'> | string;
      promptTokens?: IntFilter<'AiUsageMetric'> | number;
      completionTokens?: IntFilter<'AiUsageMetric'> | number;
      totalTokens?: IntFilter<'AiUsageMetric'> | number;
      estimatedCost?: FloatNullableFilter<'AiUsageMetric'> | number | null;
      documentId?: IntNullableFilter<'AiUsageMetric'> | number | null;
      createdAt?: DateTimeFilter<'AiUsageMetric'> | Date | string;
      userId?: StringFilter<'AiUsageMetric'> | string;
      aiAccountId?: StringFilter<'AiUsageMetric'> | string;
      aiModelId?: StringNullableFilter<'AiUsageMetric'> | string | null;
      aiBotId?: StringNullableFilter<'AiUsageMetric'> | string | null;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      aiAccount?: XOR<AiAccountScalarRelationFilter, AiAccountWhereInput>;
      aiModel?: XOR<AiModelNullableScalarRelationFilter, AiModelWhereInput> | null;
      aiBot?: XOR<AiBotNullableScalarRelationFilter, AiBotWhereInput> | null;
    },
    'id'
  >;

  export type AiUsageMetricOrderByWithAggregationInput = {
    id?: SortOrder;
    provider?: SortOrder;
    model?: SortOrder;
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrderInput | SortOrder;
    documentId?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    aiModelId?: SortOrderInput | SortOrder;
    aiBotId?: SortOrderInput | SortOrder;
    _count?: AiUsageMetricCountOrderByAggregateInput;
    _avg?: AiUsageMetricAvgOrderByAggregateInput;
    _max?: AiUsageMetricMaxOrderByAggregateInput;
    _min?: AiUsageMetricMinOrderByAggregateInput;
    _sum?: AiUsageMetricSumOrderByAggregateInput;
  };

  export type AiUsageMetricScalarWhereWithAggregatesInput = {
    AND?:
      | AiUsageMetricScalarWhereWithAggregatesInput
      | AiUsageMetricScalarWhereWithAggregatesInput[];
    OR?: AiUsageMetricScalarWhereWithAggregatesInput[];
    NOT?:
      | AiUsageMetricScalarWhereWithAggregatesInput
      | AiUsageMetricScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AiUsageMetric'> | string;
    provider?: StringWithAggregatesFilter<'AiUsageMetric'> | string;
    model?: StringWithAggregatesFilter<'AiUsageMetric'> | string;
    promptTokens?: IntWithAggregatesFilter<'AiUsageMetric'> | number;
    completionTokens?: IntWithAggregatesFilter<'AiUsageMetric'> | number;
    totalTokens?: IntWithAggregatesFilter<'AiUsageMetric'> | number;
    estimatedCost?: FloatNullableWithAggregatesFilter<'AiUsageMetric'> | number | null;
    documentId?: IntNullableWithAggregatesFilter<'AiUsageMetric'> | number | null;
    createdAt?: DateTimeWithAggregatesFilter<'AiUsageMetric'> | Date | string;
    userId?: StringWithAggregatesFilter<'AiUsageMetric'> | string;
    aiAccountId?: StringWithAggregatesFilter<'AiUsageMetric'> | string;
    aiModelId?: StringNullableWithAggregatesFilter<'AiUsageMetric'> | string | null;
    aiBotId?: StringNullableWithAggregatesFilter<'AiUsageMetric'> | string | null;
  };

  export type WebAuthnCredentialWhereInput = {
    AND?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[];
    OR?: WebAuthnCredentialWhereInput[];
    NOT?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[];
    id?: StringFilter<'WebAuthnCredential'> | string;
    credentialId?: BytesFilter<'WebAuthnCredential'> | Bytes;
    publicKey?: BytesFilter<'WebAuthnCredential'> | Bytes;
    counter?: BigIntFilter<'WebAuthnCredential'> | bigint | number;
    deviceType?: StringFilter<'WebAuthnCredential'> | string;
    backedUp?: BoolFilter<'WebAuthnCredential'> | boolean;
    transports?: StringNullableListFilter<'WebAuthnCredential'>;
    name?: StringNullableFilter<'WebAuthnCredential'> | string | null;
    createdAt?: DateTimeFilter<'WebAuthnCredential'> | Date | string;
    lastUsedAt?: DateTimeNullableFilter<'WebAuthnCredential'> | Date | string | null;
    userId?: StringFilter<'WebAuthnCredential'> | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type WebAuthnCredentialOrderByWithRelationInput = {
    id?: SortOrder;
    credentialId?: SortOrder;
    publicKey?: SortOrder;
    counter?: SortOrder;
    deviceType?: SortOrder;
    backedUp?: SortOrder;
    transports?: SortOrder;
    name?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type WebAuthnCredentialWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      credentialId?: Bytes;
      AND?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[];
      OR?: WebAuthnCredentialWhereInput[];
      NOT?: WebAuthnCredentialWhereInput | WebAuthnCredentialWhereInput[];
      publicKey?: BytesFilter<'WebAuthnCredential'> | Bytes;
      counter?: BigIntFilter<'WebAuthnCredential'> | bigint | number;
      deviceType?: StringFilter<'WebAuthnCredential'> | string;
      backedUp?: BoolFilter<'WebAuthnCredential'> | boolean;
      transports?: StringNullableListFilter<'WebAuthnCredential'>;
      name?: StringNullableFilter<'WebAuthnCredential'> | string | null;
      createdAt?: DateTimeFilter<'WebAuthnCredential'> | Date | string;
      lastUsedAt?: DateTimeNullableFilter<'WebAuthnCredential'> | Date | string | null;
      userId?: StringFilter<'WebAuthnCredential'> | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'credentialId'
  >;

  export type WebAuthnCredentialOrderByWithAggregationInput = {
    id?: SortOrder;
    credentialId?: SortOrder;
    publicKey?: SortOrder;
    counter?: SortOrder;
    deviceType?: SortOrder;
    backedUp?: SortOrder;
    transports?: SortOrder;
    name?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    lastUsedAt?: SortOrderInput | SortOrder;
    userId?: SortOrder;
    _count?: WebAuthnCredentialCountOrderByAggregateInput;
    _avg?: WebAuthnCredentialAvgOrderByAggregateInput;
    _max?: WebAuthnCredentialMaxOrderByAggregateInput;
    _min?: WebAuthnCredentialMinOrderByAggregateInput;
    _sum?: WebAuthnCredentialSumOrderByAggregateInput;
  };

  export type WebAuthnCredentialScalarWhereWithAggregatesInput = {
    AND?:
      | WebAuthnCredentialScalarWhereWithAggregatesInput
      | WebAuthnCredentialScalarWhereWithAggregatesInput[];
    OR?: WebAuthnCredentialScalarWhereWithAggregatesInput[];
    NOT?:
      | WebAuthnCredentialScalarWhereWithAggregatesInput
      | WebAuthnCredentialScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'WebAuthnCredential'> | string;
    credentialId?: BytesWithAggregatesFilter<'WebAuthnCredential'> | Bytes;
    publicKey?: BytesWithAggregatesFilter<'WebAuthnCredential'> | Bytes;
    counter?: BigIntWithAggregatesFilter<'WebAuthnCredential'> | bigint | number;
    deviceType?: StringWithAggregatesFilter<'WebAuthnCredential'> | string;
    backedUp?: BoolWithAggregatesFilter<'WebAuthnCredential'> | boolean;
    transports?: StringNullableListFilter<'WebAuthnCredential'>;
    name?: StringNullableWithAggregatesFilter<'WebAuthnCredential'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'WebAuthnCredential'> | Date | string;
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<'WebAuthnCredential'> | Date | string | null;
    userId?: StringWithAggregatesFilter<'WebAuthnCredential'> | string;
  };

  export type WebAuthnChallengeWhereInput = {
    AND?: WebAuthnChallengeWhereInput | WebAuthnChallengeWhereInput[];
    OR?: WebAuthnChallengeWhereInput[];
    NOT?: WebAuthnChallengeWhereInput | WebAuthnChallengeWhereInput[];
    id?: StringFilter<'WebAuthnChallenge'> | string;
    challenge?: StringFilter<'WebAuthnChallenge'> | string;
    type?: StringFilter<'WebAuthnChallenge'> | string;
    userId?: StringNullableFilter<'WebAuthnChallenge'> | string | null;
    expiresAt?: DateTimeFilter<'WebAuthnChallenge'> | Date | string;
    createdAt?: DateTimeFilter<'WebAuthnChallenge'> | Date | string;
  };

  export type WebAuthnChallengeOrderByWithRelationInput = {
    id?: SortOrder;
    challenge?: SortOrder;
    type?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type WebAuthnChallengeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      challenge?: string;
      AND?: WebAuthnChallengeWhereInput | WebAuthnChallengeWhereInput[];
      OR?: WebAuthnChallengeWhereInput[];
      NOT?: WebAuthnChallengeWhereInput | WebAuthnChallengeWhereInput[];
      type?: StringFilter<'WebAuthnChallenge'> | string;
      userId?: StringNullableFilter<'WebAuthnChallenge'> | string | null;
      expiresAt?: DateTimeFilter<'WebAuthnChallenge'> | Date | string;
      createdAt?: DateTimeFilter<'WebAuthnChallenge'> | Date | string;
    },
    'id' | 'challenge'
  >;

  export type WebAuthnChallengeOrderByWithAggregationInput = {
    id?: SortOrder;
    challenge?: SortOrder;
    type?: SortOrder;
    userId?: SortOrderInput | SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    _count?: WebAuthnChallengeCountOrderByAggregateInput;
    _max?: WebAuthnChallengeMaxOrderByAggregateInput;
    _min?: WebAuthnChallengeMinOrderByAggregateInput;
  };

  export type WebAuthnChallengeScalarWhereWithAggregatesInput = {
    AND?:
      | WebAuthnChallengeScalarWhereWithAggregatesInput
      | WebAuthnChallengeScalarWhereWithAggregatesInput[];
    OR?: WebAuthnChallengeScalarWhereWithAggregatesInput[];
    NOT?:
      | WebAuthnChallengeScalarWhereWithAggregatesInput
      | WebAuthnChallengeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'WebAuthnChallenge'> | string;
    challenge?: StringWithAggregatesFilter<'WebAuthnChallenge'> | string;
    type?: StringWithAggregatesFilter<'WebAuthnChallenge'> | string;
    userId?: StringNullableWithAggregatesFilter<'WebAuthnChallenge'> | string | null;
    expiresAt?: DateTimeWithAggregatesFilter<'WebAuthnChallenge'> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<'WebAuthnChallenge'> | Date | string;
  };

  export type SettingCreateInput = {
    settingKey: string;
    settingValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SettingUncheckedCreateInput = {
    settingKey: string;
    settingValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SettingUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SettingUncheckedUpdateInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SettingCreateManyInput = {
    settingKey: string;
    settingValue: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SettingUpdateManyMutationInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SettingUncheckedUpdateManyInput = {
    settingKey?: StringFieldUpdateOperationsInput | string;
    settingValue?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserPaperlessInstanceAccessCreateInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedPaperlessInstancesInput;
    instance: PaperlessInstanceCreateNestedOneWithoutSharedWithInput;
  };

  export type UserPaperlessInstanceAccessUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    instanceId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserPaperlessInstanceAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedPaperlessInstancesNestedInput;
    instance?: PaperlessInstanceUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    instanceId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserPaperlessInstanceAccessCreateManyInput = {
    id?: string;
    userId?: string | null;
    instanceId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserPaperlessInstanceAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    instanceId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiAccountAccessCreateInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedAiAccountsInput;
    aiAccount: AiAccountCreateNestedOneWithoutSharedWithInput;
  };

  export type UserAiAccountAccessUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    aiAccountId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiAccountAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedAiAccountsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserAiAccountAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiAccountAccessCreateManyInput = {
    id?: string;
    userId?: string | null;
    aiAccountId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiAccountAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiAccountAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiModelAccessCreateInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedAiModelsInput;
    aiModel: AiModelCreateNestedOneWithoutSharedWithInput;
  };

  export type UserAiModelAccessUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    aiModelId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiModelAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedAiModelsNestedInput;
    aiModel?: AiModelUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserAiModelAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiModelAccessCreateManyInput = {
    id?: string;
    userId?: string | null;
    aiModelId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiModelAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiModelAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiBotAccessCreateInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedAiBotsInput;
    aiBot: AiBotCreateNestedOneWithoutSharedWithInput;
  };

  export type UserAiBotAccessUncheckedCreateInput = {
    id?: string;
    userId?: string | null;
    aiBotId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiBotAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedAiBotsNestedInput;
    aiBot?: AiBotUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserAiBotAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiBotAccessCreateManyInput = {
    id?: string;
    userId?: string | null;
    aiBotId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiBotAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiBotAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaperlessInstanceCreateInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    defaultAiBot?: AiBotCreateNestedOneWithoutDefaultForInstancesInput;
    owner: UserCreateNestedOneWithoutOwnedPaperlessInstancesInput;
    sharedWith?: UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    defaultAiBot?: AiBotUpdateOneWithoutDefaultForInstancesNestedInput;
    owner?: UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput;
    sharedWith?: UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceCreateManyInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
  };

  export type PaperlessInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type PaperlessInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiAccountCreateInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiAccountsInput;
    sharedWith?: UserAiAccountAccessCreateNestedManyWithoutAiAccountInput;
    models?: AiModelCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountUncheckedCreateInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    sharedWith?: UserAiAccountAccessUncheckedCreateNestedManyWithoutAiAccountInput;
    models?: AiModelUncheckedCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiAccountsNestedInput;
    sharedWith?: UserAiAccountAccessUpdateManyWithoutAiAccountNestedInput;
    models?: AiModelUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountNestedInput;
    models?: AiModelUncheckedUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountCreateManyInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
  };

  export type AiAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiModelCreateInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiModelsInput;
    aiAccount: AiAccountCreateNestedOneWithoutModelsInput;
    sharedWith?: UserAiModelAccessCreateNestedManyWithoutAiModelInput;
    bots?: AiBotCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUncheckedCreateInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiAccountId: string;
    sharedWith?: UserAiModelAccessUncheckedCreateNestedManyWithoutAiModelInput;
    bots?: AiBotUncheckedCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiModelsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutModelsNestedInput;
    sharedWith?: UserAiModelAccessUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiModelAccessUncheckedUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUncheckedUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelCreateManyInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiAccountId: string;
  };

  export type AiModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiBotCreateInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiBotsInput;
    aiModel: AiModelCreateNestedOneWithoutBotsInput;
    sharedWith?: UserAiBotAccessCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUncheckedCreateInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiModelId: string;
    sharedWith?: UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput;
    aiModel?: AiModelUpdateOneRequiredWithoutBotsNestedInput;
    sharedWith?: UserAiBotAccessUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotCreateManyInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiModelId: string;
  };

  export type AiBotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiBotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
  };

  export type PaperlessDocumentCreateInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutDocumentsInput;
    processingResults?: DocumentProcessingResultCreateNestedManyWithoutDocumentInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentUncheckedCreateInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    processingResults?: DocumentProcessingResultUncheckedCreateNestedManyWithoutDocumentInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutDocumentsNestedInput;
    processingResults?: DocumentProcessingResultUpdateManyWithoutDocumentNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    processingResults?: DocumentProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessDocumentCreateManyInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
  };

  export type PaperlessDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaperlessDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
  };

  export type DocumentProcessingResultCreateInput = {
    id?: string;
    processedAt?: Date | string;
    aiProvider: string;
    inputTokens?: number;
    outputTokens?: number;
    estimatedCost?: number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: string | null;
    originalCorrespondent?: string | null;
    originalDocumentType?: string | null;
    originalTags?: DocumentProcessingResultCreateoriginalTagsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    document: PaperlessDocumentCreateNestedOneWithoutProcessingResultsInput;
  };

  export type DocumentProcessingResultUncheckedCreateInput = {
    id?: string;
    processedAt?: Date | string;
    aiProvider: string;
    inputTokens?: number;
    outputTokens?: number;
    estimatedCost?: number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: string | null;
    originalCorrespondent?: string | null;
    originalDocumentType?: string | null;
    originalTags?: DocumentProcessingResultCreateoriginalTagsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    documentId: string;
  };

  export type DocumentProcessingResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    document?: PaperlessDocumentUpdateOneRequiredWithoutProcessingResultsNestedInput;
  };

  export type DocumentProcessingResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentId?: StringFieldUpdateOperationsInput | string;
  };

  export type DocumentProcessingResultCreateManyInput = {
    id?: string;
    processedAt?: Date | string;
    aiProvider: string;
    inputTokens?: number;
    outputTokens?: number;
    estimatedCost?: number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: string | null;
    originalCorrespondent?: string | null;
    originalDocumentType?: string | null;
    originalTags?: DocumentProcessingResultCreateoriginalTagsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    documentId: string;
  };

  export type DocumentProcessingResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentProcessingResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentId?: StringFieldUpdateOperationsInput | string;
  };

  export type ProcessingQueueCreateInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutProcessingQueueInput;
    document?: PaperlessDocumentCreateNestedOneWithoutProcessingQueueItemsInput;
    aiBot?: AiBotCreateNestedOneWithoutProcessingQueueItemsInput;
  };

  export type ProcessingQueueUncheckedCreateInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    documentId?: string | null;
    aiBotId?: string | null;
  };

  export type ProcessingQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutProcessingQueueNestedInput;
    document?: PaperlessDocumentUpdateOneWithoutProcessingQueueItemsNestedInput;
    aiBot?: AiBotUpdateOneWithoutProcessingQueueItemsNestedInput;
  };

  export type ProcessingQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    documentId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ProcessingQueueCreateManyInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    documentId?: string | null;
    aiBotId?: string | null;
  };

  export type ProcessingQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProcessingQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    documentId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ImportHistoryCreateInput = {
    id?: string;
    importedAt?: Date | string;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutImportHistoryInput;
  };

  export type ImportHistoryUncheckedCreateInput = {
    id?: string;
    importedAt?: Date | string;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
    paperlessInstanceId: string;
  };

  export type ImportHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutImportHistoryNestedInput;
  };

  export type ImportHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
  };

  export type ImportHistoryCreateManyInput = {
    id?: string;
    importedAt?: Date | string;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
    paperlessInstanceId: string;
  };

  export type ImportHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
  };

  export type ImportHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiUsageMetricCreateInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutAiUsageMetricsInput;
    aiAccount: AiAccountCreateNestedOneWithoutAiUsageMetricsInput;
    aiModel?: AiModelCreateNestedOneWithoutAiUsageMetricsInput;
    aiBot?: AiBotCreateNestedOneWithoutAiUsageMetricsInput;
  };

  export type AiUsageMetricUncheckedCreateInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiAccountId: string;
    aiModelId?: string | null;
    aiBotId?: string | null;
  };

  export type AiUsageMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiModel?: AiModelUpdateOneWithoutAiUsageMetricsNestedInput;
    aiBot?: AiBotUpdateOneWithoutAiUsageMetricsNestedInput;
  };

  export type AiUsageMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AiUsageMetricCreateManyInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiAccountId: string;
    aiModelId?: string | null;
    aiBotId?: string | null;
  };

  export type AiUsageMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiUsageMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WebAuthnCredentialCreateInput = {
    id?: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter?: bigint | number;
    deviceType?: string;
    backedUp?: boolean;
    transports?: WebAuthnCredentialCreatetransportsInput | string[];
    name?: string | null;
    createdAt?: Date | string;
    lastUsedAt?: Date | string | null;
    user: UserCreateNestedOneWithoutWebAuthnCredentialsInput;
  };

  export type WebAuthnCredentialUncheckedCreateInput = {
    id?: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter?: bigint | number;
    deviceType?: string;
    backedUp?: boolean;
    transports?: WebAuthnCredentialCreatetransportsInput | string[];
    name?: string | null;
    createdAt?: Date | string;
    lastUsedAt?: Date | string | null;
    userId: string;
  };

  export type WebAuthnCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    user?: UserUpdateOneRequiredWithoutWebAuthnCredentialsNestedInput;
  };

  export type WebAuthnCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type WebAuthnCredentialCreateManyInput = {
    id?: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter?: bigint | number;
    deviceType?: string;
    backedUp?: boolean;
    transports?: WebAuthnCredentialCreatetransportsInput | string[];
    name?: string | null;
    createdAt?: Date | string;
    lastUsedAt?: Date | string | null;
    userId: string;
  };

  export type WebAuthnCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type WebAuthnCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    userId?: StringFieldUpdateOperationsInput | string;
  };

  export type WebAuthnChallengeCreateInput = {
    id?: string;
    challenge: string;
    type: string;
    userId?: string | null;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type WebAuthnChallengeUncheckedCreateInput = {
    id?: string;
    challenge: string;
    type: string;
    userId?: string | null;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type WebAuthnChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challenge?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WebAuthnChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challenge?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WebAuthnChallengeCreateManyInput = {
    id?: string;
    challenge: string;
    type: string;
    userId?: string | null;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type WebAuthnChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challenge?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type WebAuthnChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    challenge?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type SettingCountOrderByAggregateInput = {
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingMaxOrderByAggregateInput = {
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SettingMinOrderByAggregateInput = {
    settingKey?: SortOrder;
    settingValue?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type PaperlessInstanceListRelationFilter = {
    every?: PaperlessInstanceWhereInput;
    some?: PaperlessInstanceWhereInput;
    none?: PaperlessInstanceWhereInput;
  };

  export type AiAccountListRelationFilter = {
    every?: AiAccountWhereInput;
    some?: AiAccountWhereInput;
    none?: AiAccountWhereInput;
  };

  export type AiModelListRelationFilter = {
    every?: AiModelWhereInput;
    some?: AiModelWhereInput;
    none?: AiModelWhereInput;
  };

  export type AiBotListRelationFilter = {
    every?: AiBotWhereInput;
    some?: AiBotWhereInput;
    none?: AiBotWhereInput;
  };

  export type UserPaperlessInstanceAccessListRelationFilter = {
    every?: UserPaperlessInstanceAccessWhereInput;
    some?: UserPaperlessInstanceAccessWhereInput;
    none?: UserPaperlessInstanceAccessWhereInput;
  };

  export type UserAiAccountAccessListRelationFilter = {
    every?: UserAiAccountAccessWhereInput;
    some?: UserAiAccountAccessWhereInput;
    none?: UserAiAccountAccessWhereInput;
  };

  export type UserAiModelAccessListRelationFilter = {
    every?: UserAiModelAccessWhereInput;
    some?: UserAiModelAccessWhereInput;
    none?: UserAiModelAccessWhereInput;
  };

  export type UserAiBotAccessListRelationFilter = {
    every?: UserAiBotAccessWhereInput;
    some?: UserAiBotAccessWhereInput;
    none?: UserAiBotAccessWhereInput;
  };

  export type AiUsageMetricListRelationFilter = {
    every?: AiUsageMetricWhereInput;
    some?: AiUsageMetricWhereInput;
    none?: AiUsageMetricWhereInput;
  };

  export type WebAuthnCredentialListRelationFilter = {
    every?: WebAuthnCredentialWhereInput;
    some?: WebAuthnCredentialWhereInput;
    none?: WebAuthnCredentialWhereInput;
  };

  export type PaperlessInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AiAccountOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AiModelOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AiBotOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserPaperlessInstanceAccessOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserAiAccountAccessOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserAiModelAccessOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserAiBotAccessOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AiUsageMetricOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type WebAuthnCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    username?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    mustChangePassword?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    username?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    mustChangePassword?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    username?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    mustChangePassword?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type EnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>;
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type PaperlessInstanceScalarRelationFilter = {
    is?: PaperlessInstanceWhereInput;
    isNot?: PaperlessInstanceWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UserPaperlessInstanceAccessUserIdInstanceIdCompoundUniqueInput = {
    userId: string;
    instanceId: string;
  };

  export type UserPaperlessInstanceAccessCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    instanceId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserPaperlessInstanceAccessMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    instanceId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserPaperlessInstanceAccessMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    instanceId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type EnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>;
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPermissionFilter<$PrismaModel>;
    _max?: NestedEnumPermissionFilter<$PrismaModel>;
  };

  export type AiAccountScalarRelationFilter = {
    is?: AiAccountWhereInput;
    isNot?: AiAccountWhereInput;
  };

  export type UserAiAccountAccessUserIdAiAccountIdCompoundUniqueInput = {
    userId: string;
    aiAccountId: string;
  };

  export type UserAiAccountAccessCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserAiAccountAccessMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserAiAccountAccessMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AiModelScalarRelationFilter = {
    is?: AiModelWhereInput;
    isNot?: AiModelWhereInput;
  };

  export type UserAiModelAccessUserIdAiModelIdCompoundUniqueInput = {
    userId: string;
    aiModelId: string;
  };

  export type UserAiModelAccessCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiModelId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserAiModelAccessMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiModelId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserAiModelAccessMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiModelId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AiBotScalarRelationFilter = {
    is?: AiBotWhereInput;
    isNot?: AiBotWhereInput;
  };

  export type UserAiBotAccessUserIdAiBotIdCompoundUniqueInput = {
    userId: string;
    aiBotId: string;
  };

  export type UserAiBotAccessCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiBotId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserAiBotAccessMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiBotId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserAiBotAccessMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    aiBotId?: SortOrder;
    permission?: SortOrder;
    createdAt?: SortOrder;
  };

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    has?: number | IntFieldRefInput<$PrismaModel> | null;
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>;
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type AiBotNullableScalarRelationFilter = {
    is?: AiBotWhereInput | null;
    isNot?: AiBotWhereInput | null;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type PaperlessDocumentListRelationFilter = {
    every?: PaperlessDocumentWhereInput;
    some?: PaperlessDocumentWhereInput;
    none?: PaperlessDocumentWhereInput;
  };

  export type ProcessingQueueListRelationFilter = {
    every?: ProcessingQueueWhereInput;
    some?: ProcessingQueueWhereInput;
    none?: ProcessingQueueWhereInput;
  };

  export type ImportHistoryListRelationFilter = {
    every?: ImportHistoryWhereInput;
    some?: ImportHistoryWhereInput;
    none?: ImportHistoryWhereInput;
  };

  export type PaperlessDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ProcessingQueueOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ImportHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PaperlessInstanceCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    apiUrl?: SortOrder;
    apiToken?: SortOrder;
    importFilterTags?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    autoProcessEnabled?: SortOrder;
    scanCronExpression?: SortOrder;
    lastScanAt?: SortOrder;
    nextScanAt?: SortOrder;
    defaultAiBotId?: SortOrder;
    autoApplyTitle?: SortOrder;
    autoApplyCorrespondent?: SortOrder;
    autoApplyDocumentType?: SortOrder;
    autoApplyTags?: SortOrder;
    autoApplyDate?: SortOrder;
    ownerId?: SortOrder;
  };

  export type PaperlessInstanceAvgOrderByAggregateInput = {
    importFilterTags?: SortOrder;
  };

  export type PaperlessInstanceMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    apiUrl?: SortOrder;
    apiToken?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    autoProcessEnabled?: SortOrder;
    scanCronExpression?: SortOrder;
    lastScanAt?: SortOrder;
    nextScanAt?: SortOrder;
    defaultAiBotId?: SortOrder;
    autoApplyTitle?: SortOrder;
    autoApplyCorrespondent?: SortOrder;
    autoApplyDocumentType?: SortOrder;
    autoApplyTags?: SortOrder;
    autoApplyDate?: SortOrder;
    ownerId?: SortOrder;
  };

  export type PaperlessInstanceMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    apiUrl?: SortOrder;
    apiToken?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    autoProcessEnabled?: SortOrder;
    scanCronExpression?: SortOrder;
    lastScanAt?: SortOrder;
    nextScanAt?: SortOrder;
    defaultAiBotId?: SortOrder;
    autoApplyTitle?: SortOrder;
    autoApplyCorrespondent?: SortOrder;
    autoApplyDocumentType?: SortOrder;
    autoApplyTags?: SortOrder;
    autoApplyDate?: SortOrder;
    ownerId?: SortOrder;
  };

  export type PaperlessInstanceSumOrderByAggregateInput = {
    importFilterTags?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type AiAccountCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    provider?: SortOrder;
    apiKey?: SortOrder;
    baseUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
  };

  export type AiAccountMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    provider?: SortOrder;
    apiKey?: SortOrder;
    baseUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
  };

  export type AiAccountMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    provider?: SortOrder;
    apiKey?: SortOrder;
    baseUrl?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type AiModelCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    modelIdentifier?: SortOrder;
    inputTokenPrice?: SortOrder;
    outputTokenPrice?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiAccountId?: SortOrder;
  };

  export type AiModelAvgOrderByAggregateInput = {
    inputTokenPrice?: SortOrder;
    outputTokenPrice?: SortOrder;
  };

  export type AiModelMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    modelIdentifier?: SortOrder;
    inputTokenPrice?: SortOrder;
    outputTokenPrice?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiAccountId?: SortOrder;
  };

  export type AiModelMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    modelIdentifier?: SortOrder;
    inputTokenPrice?: SortOrder;
    outputTokenPrice?: SortOrder;
    isActive?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiAccountId?: SortOrder;
  };

  export type AiModelSumOrderByAggregateInput = {
    inputTokenPrice?: SortOrder;
    outputTokenPrice?: SortOrder;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type AiBotCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    systemPrompt?: SortOrder;
    responseLanguage?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiModelId?: SortOrder;
  };

  export type AiBotMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    systemPrompt?: SortOrder;
    responseLanguage?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiModelId?: SortOrder;
  };

  export type AiBotMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    systemPrompt?: SortOrder;
    responseLanguage?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    ownerId?: SortOrder;
    aiModelId?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type DocumentProcessingResultListRelationFilter = {
    every?: DocumentProcessingResultWhereInput;
    some?: DocumentProcessingResultWhereInput;
    none?: DocumentProcessingResultWhereInput;
  };

  export type DocumentProcessingResultOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PaperlessDocumentPaperlessInstanceIdPaperlessIdCompoundUniqueInput = {
    paperlessInstanceId: string;
    paperlessId: number;
  };

  export type PaperlessDocumentCountOrderByAggregateInput = {
    id?: SortOrder;
    paperlessId?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    correspondentId?: SortOrder;
    tagIds?: SortOrder;
    documentDate?: SortOrder;
    paperlessModified?: SortOrder;
    importedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
  };

  export type PaperlessDocumentAvgOrderByAggregateInput = {
    paperlessId?: SortOrder;
    correspondentId?: SortOrder;
    tagIds?: SortOrder;
  };

  export type PaperlessDocumentMaxOrderByAggregateInput = {
    id?: SortOrder;
    paperlessId?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    correspondentId?: SortOrder;
    documentDate?: SortOrder;
    paperlessModified?: SortOrder;
    importedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
  };

  export type PaperlessDocumentMinOrderByAggregateInput = {
    id?: SortOrder;
    paperlessId?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    correspondentId?: SortOrder;
    documentDate?: SortOrder;
    paperlessModified?: SortOrder;
    importedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
  };

  export type PaperlessDocumentSumOrderByAggregateInput = {
    paperlessId?: SortOrder;
    correspondentId?: SortOrder;
    tagIds?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type PaperlessDocumentScalarRelationFilter = {
    is?: PaperlessDocumentWhereInput;
    isNot?: PaperlessDocumentWhereInput;
  };

  export type DocumentProcessingResultCountOrderByAggregateInput = {
    id?: SortOrder;
    processedAt?: SortOrder;
    aiProvider?: SortOrder;
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrder;
    changes?: SortOrder;
    toolCalls?: SortOrder;
    originalTitle?: SortOrder;
    originalCorrespondent?: SortOrder;
    originalDocumentType?: SortOrder;
    originalTags?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    documentId?: SortOrder;
  };

  export type DocumentProcessingResultAvgOrderByAggregateInput = {
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrder;
  };

  export type DocumentProcessingResultMaxOrderByAggregateInput = {
    id?: SortOrder;
    processedAt?: SortOrder;
    aiProvider?: SortOrder;
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrder;
    originalTitle?: SortOrder;
    originalCorrespondent?: SortOrder;
    originalDocumentType?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    documentId?: SortOrder;
  };

  export type DocumentProcessingResultMinOrderByAggregateInput = {
    id?: SortOrder;
    processedAt?: SortOrder;
    aiProvider?: SortOrder;
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrder;
    originalTitle?: SortOrder;
    originalCorrespondent?: SortOrder;
    originalDocumentType?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    documentId?: SortOrder;
  };

  export type DocumentProcessingResultSumOrderByAggregateInput = {
    inputTokens?: SortOrder;
    outputTokens?: SortOrder;
    estimatedCost?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type PaperlessDocumentNullableScalarRelationFilter = {
    is?: PaperlessDocumentWhereInput | null;
    isNot?: PaperlessDocumentWhereInput | null;
  };

  export type ProcessingQueuePaperlessInstanceIdPaperlessDocumentIdCompoundUniqueInput = {
    paperlessInstanceId: string;
    paperlessDocumentId: number;
  };

  export type ProcessingQueueCountOrderByAggregateInput = {
    id?: SortOrder;
    paperlessDocumentId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastError?: SortOrder;
    scheduledFor?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    documentId?: SortOrder;
    aiBotId?: SortOrder;
  };

  export type ProcessingQueueAvgOrderByAggregateInput = {
    paperlessDocumentId?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
  };

  export type ProcessingQueueMaxOrderByAggregateInput = {
    id?: SortOrder;
    paperlessDocumentId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastError?: SortOrder;
    scheduledFor?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    documentId?: SortOrder;
    aiBotId?: SortOrder;
  };

  export type ProcessingQueueMinOrderByAggregateInput = {
    id?: SortOrder;
    paperlessDocumentId?: SortOrder;
    status?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
    lastError?: SortOrder;
    scheduledFor?: SortOrder;
    startedAt?: SortOrder;
    completedAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    paperlessInstanceId?: SortOrder;
    documentId?: SortOrder;
    aiBotId?: SortOrder;
  };

  export type ProcessingQueueSumOrderByAggregateInput = {
    paperlessDocumentId?: SortOrder;
    priority?: SortOrder;
    attempts?: SortOrder;
    maxAttempts?: SortOrder;
  };

  export type ImportHistoryCountOrderByAggregateInput = {
    id?: SortOrder;
    importedAt?: SortOrder;
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
    paperlessInstanceId?: SortOrder;
  };

  export type ImportHistoryAvgOrderByAggregateInput = {
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
  };

  export type ImportHistoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    importedAt?: SortOrder;
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
    paperlessInstanceId?: SortOrder;
  };

  export type ImportHistoryMinOrderByAggregateInput = {
    id?: SortOrder;
    importedAt?: SortOrder;
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
    paperlessInstanceId?: SortOrder;
  };

  export type ImportHistorySumOrderByAggregateInput = {
    documentsImported?: SortOrder;
    documentsUpdated?: SortOrder;
    documentsUnchanged?: SortOrder;
    totalInPaperless?: SortOrder;
  };

  export type AiModelNullableScalarRelationFilter = {
    is?: AiModelWhereInput | null;
    isNot?: AiModelWhereInput | null;
  };

  export type AiUsageMetricCountOrderByAggregateInput = {
    id?: SortOrder;
    provider?: SortOrder;
    model?: SortOrder;
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrder;
    documentId?: SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    aiModelId?: SortOrder;
    aiBotId?: SortOrder;
  };

  export type AiUsageMetricAvgOrderByAggregateInput = {
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrder;
    documentId?: SortOrder;
  };

  export type AiUsageMetricMaxOrderByAggregateInput = {
    id?: SortOrder;
    provider?: SortOrder;
    model?: SortOrder;
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrder;
    documentId?: SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    aiModelId?: SortOrder;
    aiBotId?: SortOrder;
  };

  export type AiUsageMetricMinOrderByAggregateInput = {
    id?: SortOrder;
    provider?: SortOrder;
    model?: SortOrder;
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrder;
    documentId?: SortOrder;
    createdAt?: SortOrder;
    userId?: SortOrder;
    aiAccountId?: SortOrder;
    aiModelId?: SortOrder;
    aiBotId?: SortOrder;
  };

  export type AiUsageMetricSumOrderByAggregateInput = {
    promptTokens?: SortOrder;
    completionTokens?: SortOrder;
    totalTokens?: SortOrder;
    estimatedCost?: SortOrder;
    documentId?: SortOrder;
  };

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>;
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    not?: NestedBytesFilter<$PrismaModel> | Bytes;
  };

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number;
  };

  export type WebAuthnCredentialCountOrderByAggregateInput = {
    id?: SortOrder;
    credentialId?: SortOrder;
    publicKey?: SortOrder;
    counter?: SortOrder;
    deviceType?: SortOrder;
    backedUp?: SortOrder;
    transports?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    lastUsedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type WebAuthnCredentialAvgOrderByAggregateInput = {
    counter?: SortOrder;
  };

  export type WebAuthnCredentialMaxOrderByAggregateInput = {
    id?: SortOrder;
    credentialId?: SortOrder;
    publicKey?: SortOrder;
    counter?: SortOrder;
    deviceType?: SortOrder;
    backedUp?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    lastUsedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type WebAuthnCredentialMinOrderByAggregateInput = {
    id?: SortOrder;
    credentialId?: SortOrder;
    publicKey?: SortOrder;
    counter?: SortOrder;
    deviceType?: SortOrder;
    backedUp?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    lastUsedAt?: SortOrder;
    userId?: SortOrder;
  };

  export type WebAuthnCredentialSumOrderByAggregateInput = {
    counter?: SortOrder;
  };

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>;
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBytesFilter<$PrismaModel>;
    _max?: NestedBytesFilter<$PrismaModel>;
  };

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedBigIntFilter<$PrismaModel>;
    _min?: NestedBigIntFilter<$PrismaModel>;
    _max?: NestedBigIntFilter<$PrismaModel>;
  };

  export type WebAuthnChallengeCountOrderByAggregateInput = {
    id?: SortOrder;
    challenge?: SortOrder;
    type?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type WebAuthnChallengeMaxOrderByAggregateInput = {
    id?: SortOrder;
    challenge?: SortOrder;
    type?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type WebAuthnChallengeMinOrderByAggregateInput = {
    id?: SortOrder;
    challenge?: SortOrder;
    type?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type PaperlessInstanceCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutOwnerInput,
          PaperlessInstanceUncheckedCreateWithoutOwnerInput
        >
      | PaperlessInstanceCreateWithoutOwnerInput[]
      | PaperlessInstanceUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput[];
    createMany?: PaperlessInstanceCreateManyOwnerInputEnvelope;
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
  };

  export type AiAccountCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<AiAccountCreateWithoutOwnerInput, AiAccountUncheckedCreateWithoutOwnerInput>
      | AiAccountCreateWithoutOwnerInput[]
      | AiAccountUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiAccountCreateOrConnectWithoutOwnerInput
      | AiAccountCreateOrConnectWithoutOwnerInput[];
    createMany?: AiAccountCreateManyOwnerInputEnvelope;
    connect?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
  };

  export type AiModelCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<AiModelCreateWithoutOwnerInput, AiModelUncheckedCreateWithoutOwnerInput>
      | AiModelCreateWithoutOwnerInput[]
      | AiModelUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutOwnerInput
      | AiModelCreateOrConnectWithoutOwnerInput[];
    createMany?: AiModelCreateManyOwnerInputEnvelope;
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
  };

  export type AiBotCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<AiBotCreateWithoutOwnerInput, AiBotUncheckedCreateWithoutOwnerInput>
      | AiBotCreateWithoutOwnerInput[]
      | AiBotUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutOwnerInput
      | AiBotCreateOrConnectWithoutOwnerInput[];
    createMany?: AiBotCreateManyOwnerInputEnvelope;
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
  };

  export type UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutUserInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput
        >
      | UserPaperlessInstanceAccessCreateWithoutUserInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyUserInputEnvelope;
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
  };

  export type UserAiAccountAccessCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutUserInput,
          UserAiAccountAccessUncheckedCreateWithoutUserInput
        >
      | UserAiAccountAccessCreateWithoutUserInput[]
      | UserAiAccountAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutUserInput
      | UserAiAccountAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserAiAccountAccessCreateManyUserInputEnvelope;
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
  };

  export type UserAiModelAccessCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutUserInput,
          UserAiModelAccessUncheckedCreateWithoutUserInput
        >
      | UserAiModelAccessCreateWithoutUserInput[]
      | UserAiModelAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutUserInput
      | UserAiModelAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserAiModelAccessCreateManyUserInputEnvelope;
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
  };

  export type UserAiBotAccessCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutUserInput, UserAiBotAccessUncheckedCreateWithoutUserInput>
      | UserAiBotAccessCreateWithoutUserInput[]
      | UserAiBotAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutUserInput
      | UserAiBotAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserAiBotAccessCreateManyUserInputEnvelope;
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
  };

  export type AiUsageMetricCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutUserInput, AiUsageMetricUncheckedCreateWithoutUserInput>
      | AiUsageMetricCreateWithoutUserInput[]
      | AiUsageMetricUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutUserInput
      | AiUsageMetricCreateOrConnectWithoutUserInput[];
    createMany?: AiUsageMetricCreateManyUserInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type WebAuthnCredentialCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          WebAuthnCredentialCreateWithoutUserInput,
          WebAuthnCredentialUncheckedCreateWithoutUserInput
        >
      | WebAuthnCredentialCreateWithoutUserInput[]
      | WebAuthnCredentialUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WebAuthnCredentialCreateOrConnectWithoutUserInput
      | WebAuthnCredentialCreateOrConnectWithoutUserInput[];
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope;
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
  };

  export type PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutOwnerInput,
          PaperlessInstanceUncheckedCreateWithoutOwnerInput
        >
      | PaperlessInstanceCreateWithoutOwnerInput[]
      | PaperlessInstanceUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput[];
    createMany?: PaperlessInstanceCreateManyOwnerInputEnvelope;
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
  };

  export type AiAccountUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<AiAccountCreateWithoutOwnerInput, AiAccountUncheckedCreateWithoutOwnerInput>
      | AiAccountCreateWithoutOwnerInput[]
      | AiAccountUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiAccountCreateOrConnectWithoutOwnerInput
      | AiAccountCreateOrConnectWithoutOwnerInput[];
    createMany?: AiAccountCreateManyOwnerInputEnvelope;
    connect?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
  };

  export type AiModelUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<AiModelCreateWithoutOwnerInput, AiModelUncheckedCreateWithoutOwnerInput>
      | AiModelCreateWithoutOwnerInput[]
      | AiModelUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutOwnerInput
      | AiModelCreateOrConnectWithoutOwnerInput[];
    createMany?: AiModelCreateManyOwnerInputEnvelope;
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
  };

  export type AiBotUncheckedCreateNestedManyWithoutOwnerInput = {
    create?:
      | XOR<AiBotCreateWithoutOwnerInput, AiBotUncheckedCreateWithoutOwnerInput>
      | AiBotCreateWithoutOwnerInput[]
      | AiBotUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutOwnerInput
      | AiBotCreateOrConnectWithoutOwnerInput[];
    createMany?: AiBotCreateManyOwnerInputEnvelope;
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
  };

  export type UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutUserInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput
        >
      | UserPaperlessInstanceAccessCreateWithoutUserInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyUserInputEnvelope;
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
  };

  export type UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutUserInput,
          UserAiAccountAccessUncheckedCreateWithoutUserInput
        >
      | UserAiAccountAccessCreateWithoutUserInput[]
      | UserAiAccountAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutUserInput
      | UserAiAccountAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserAiAccountAccessCreateManyUserInputEnvelope;
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
  };

  export type UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutUserInput,
          UserAiModelAccessUncheckedCreateWithoutUserInput
        >
      | UserAiModelAccessCreateWithoutUserInput[]
      | UserAiModelAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutUserInput
      | UserAiModelAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserAiModelAccessCreateManyUserInputEnvelope;
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
  };

  export type UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutUserInput, UserAiBotAccessUncheckedCreateWithoutUserInput>
      | UserAiBotAccessCreateWithoutUserInput[]
      | UserAiBotAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutUserInput
      | UserAiBotAccessCreateOrConnectWithoutUserInput[];
    createMany?: UserAiBotAccessCreateManyUserInputEnvelope;
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
  };

  export type AiUsageMetricUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutUserInput, AiUsageMetricUncheckedCreateWithoutUserInput>
      | AiUsageMetricCreateWithoutUserInput[]
      | AiUsageMetricUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutUserInput
      | AiUsageMetricCreateOrConnectWithoutUserInput[];
    createMany?: AiUsageMetricCreateManyUserInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          WebAuthnCredentialCreateWithoutUserInput,
          WebAuthnCredentialUncheckedCreateWithoutUserInput
        >
      | WebAuthnCredentialCreateWithoutUserInput[]
      | WebAuthnCredentialUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WebAuthnCredentialCreateOrConnectWithoutUserInput
      | WebAuthnCredentialCreateOrConnectWithoutUserInput[];
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope;
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type PaperlessInstanceUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutOwnerInput,
          PaperlessInstanceUncheckedCreateWithoutOwnerInput
        >
      | PaperlessInstanceCreateWithoutOwnerInput[]
      | PaperlessInstanceUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | PaperlessInstanceUpsertWithWhereUniqueWithoutOwnerInput
      | PaperlessInstanceUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: PaperlessInstanceCreateManyOwnerInputEnvelope;
    set?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    disconnect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    delete?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    update?:
      | PaperlessInstanceUpdateWithWhereUniqueWithoutOwnerInput
      | PaperlessInstanceUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | PaperlessInstanceUpdateManyWithWhereWithoutOwnerInput
      | PaperlessInstanceUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: PaperlessInstanceScalarWhereInput | PaperlessInstanceScalarWhereInput[];
  };

  export type AiAccountUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<AiAccountCreateWithoutOwnerInput, AiAccountUncheckedCreateWithoutOwnerInput>
      | AiAccountCreateWithoutOwnerInput[]
      | AiAccountUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiAccountCreateOrConnectWithoutOwnerInput
      | AiAccountCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | AiAccountUpsertWithWhereUniqueWithoutOwnerInput
      | AiAccountUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: AiAccountCreateManyOwnerInputEnvelope;
    set?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    disconnect?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    delete?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    connect?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    update?:
      | AiAccountUpdateWithWhereUniqueWithoutOwnerInput
      | AiAccountUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | AiAccountUpdateManyWithWhereWithoutOwnerInput
      | AiAccountUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: AiAccountScalarWhereInput | AiAccountScalarWhereInput[];
  };

  export type AiModelUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<AiModelCreateWithoutOwnerInput, AiModelUncheckedCreateWithoutOwnerInput>
      | AiModelCreateWithoutOwnerInput[]
      | AiModelUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutOwnerInput
      | AiModelCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | AiModelUpsertWithWhereUniqueWithoutOwnerInput
      | AiModelUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: AiModelCreateManyOwnerInputEnvelope;
    set?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    disconnect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    delete?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    update?:
      | AiModelUpdateWithWhereUniqueWithoutOwnerInput
      | AiModelUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | AiModelUpdateManyWithWhereWithoutOwnerInput
      | AiModelUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: AiModelScalarWhereInput | AiModelScalarWhereInput[];
  };

  export type AiBotUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<AiBotCreateWithoutOwnerInput, AiBotUncheckedCreateWithoutOwnerInput>
      | AiBotCreateWithoutOwnerInput[]
      | AiBotUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutOwnerInput
      | AiBotCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | AiBotUpsertWithWhereUniqueWithoutOwnerInput
      | AiBotUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: AiBotCreateManyOwnerInputEnvelope;
    set?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    disconnect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    delete?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    update?:
      | AiBotUpdateWithWhereUniqueWithoutOwnerInput
      | AiBotUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | AiBotUpdateManyWithWhereWithoutOwnerInput
      | AiBotUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: AiBotScalarWhereInput | AiBotScalarWhereInput[];
  };

  export type UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutUserInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput
        >
      | UserPaperlessInstanceAccessCreateWithoutUserInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutUserInput
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyUserInputEnvelope;
    set?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    disconnect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    delete?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    update?:
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutUserInput
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutUserInput
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | UserPaperlessInstanceAccessScalarWhereInput
      | UserPaperlessInstanceAccessScalarWhereInput[];
  };

  export type UserAiAccountAccessUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutUserInput,
          UserAiAccountAccessUncheckedCreateWithoutUserInput
        >
      | UserAiAccountAccessCreateWithoutUserInput[]
      | UserAiAccountAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutUserInput
      | UserAiAccountAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutUserInput
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserAiAccountAccessCreateManyUserInputEnvelope;
    set?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    disconnect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    delete?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    update?:
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutUserInput
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserAiAccountAccessUpdateManyWithWhereWithoutUserInput
      | UserAiAccountAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserAiAccountAccessScalarWhereInput | UserAiAccountAccessScalarWhereInput[];
  };

  export type UserAiModelAccessUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutUserInput,
          UserAiModelAccessUncheckedCreateWithoutUserInput
        >
      | UserAiModelAccessCreateWithoutUserInput[]
      | UserAiModelAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutUserInput
      | UserAiModelAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserAiModelAccessUpsertWithWhereUniqueWithoutUserInput
      | UserAiModelAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserAiModelAccessCreateManyUserInputEnvelope;
    set?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    disconnect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    delete?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    update?:
      | UserAiModelAccessUpdateWithWhereUniqueWithoutUserInput
      | UserAiModelAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserAiModelAccessUpdateManyWithWhereWithoutUserInput
      | UserAiModelAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserAiModelAccessScalarWhereInput | UserAiModelAccessScalarWhereInput[];
  };

  export type UserAiBotAccessUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutUserInput, UserAiBotAccessUncheckedCreateWithoutUserInput>
      | UserAiBotAccessCreateWithoutUserInput[]
      | UserAiBotAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutUserInput
      | UserAiBotAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserAiBotAccessUpsertWithWhereUniqueWithoutUserInput
      | UserAiBotAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserAiBotAccessCreateManyUserInputEnvelope;
    set?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    disconnect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    delete?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    update?:
      | UserAiBotAccessUpdateWithWhereUniqueWithoutUserInput
      | UserAiBotAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserAiBotAccessUpdateManyWithWhereWithoutUserInput
      | UserAiBotAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserAiBotAccessScalarWhereInput | UserAiBotAccessScalarWhereInput[];
  };

  export type AiUsageMetricUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutUserInput, AiUsageMetricUncheckedCreateWithoutUserInput>
      | AiUsageMetricCreateWithoutUserInput[]
      | AiUsageMetricUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutUserInput
      | AiUsageMetricCreateOrConnectWithoutUserInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutUserInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AiUsageMetricCreateManyUserInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutUserInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutUserInput
      | AiUsageMetricUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type WebAuthnCredentialUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          WebAuthnCredentialCreateWithoutUserInput,
          WebAuthnCredentialUncheckedCreateWithoutUserInput
        >
      | WebAuthnCredentialCreateWithoutUserInput[]
      | WebAuthnCredentialUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WebAuthnCredentialCreateOrConnectWithoutUserInput
      | WebAuthnCredentialCreateOrConnectWithoutUserInput[];
    upsert?:
      | WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput
      | WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope;
    set?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    disconnect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    delete?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    update?:
      | WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput
      | WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | WebAuthnCredentialUpdateManyWithWhereWithoutUserInput
      | WebAuthnCredentialUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[];
  };

  export type PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutOwnerInput,
          PaperlessInstanceUncheckedCreateWithoutOwnerInput
        >
      | PaperlessInstanceCreateWithoutOwnerInput[]
      | PaperlessInstanceUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput
      | PaperlessInstanceCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | PaperlessInstanceUpsertWithWhereUniqueWithoutOwnerInput
      | PaperlessInstanceUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: PaperlessInstanceCreateManyOwnerInputEnvelope;
    set?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    disconnect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    delete?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    update?:
      | PaperlessInstanceUpdateWithWhereUniqueWithoutOwnerInput
      | PaperlessInstanceUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | PaperlessInstanceUpdateManyWithWhereWithoutOwnerInput
      | PaperlessInstanceUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: PaperlessInstanceScalarWhereInput | PaperlessInstanceScalarWhereInput[];
  };

  export type AiAccountUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<AiAccountCreateWithoutOwnerInput, AiAccountUncheckedCreateWithoutOwnerInput>
      | AiAccountCreateWithoutOwnerInput[]
      | AiAccountUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiAccountCreateOrConnectWithoutOwnerInput
      | AiAccountCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | AiAccountUpsertWithWhereUniqueWithoutOwnerInput
      | AiAccountUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: AiAccountCreateManyOwnerInputEnvelope;
    set?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    disconnect?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    delete?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    connect?: AiAccountWhereUniqueInput | AiAccountWhereUniqueInput[];
    update?:
      | AiAccountUpdateWithWhereUniqueWithoutOwnerInput
      | AiAccountUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | AiAccountUpdateManyWithWhereWithoutOwnerInput
      | AiAccountUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: AiAccountScalarWhereInput | AiAccountScalarWhereInput[];
  };

  export type AiModelUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<AiModelCreateWithoutOwnerInput, AiModelUncheckedCreateWithoutOwnerInput>
      | AiModelCreateWithoutOwnerInput[]
      | AiModelUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutOwnerInput
      | AiModelCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | AiModelUpsertWithWhereUniqueWithoutOwnerInput
      | AiModelUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: AiModelCreateManyOwnerInputEnvelope;
    set?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    disconnect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    delete?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    update?:
      | AiModelUpdateWithWhereUniqueWithoutOwnerInput
      | AiModelUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | AiModelUpdateManyWithWhereWithoutOwnerInput
      | AiModelUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: AiModelScalarWhereInput | AiModelScalarWhereInput[];
  };

  export type AiBotUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?:
      | XOR<AiBotCreateWithoutOwnerInput, AiBotUncheckedCreateWithoutOwnerInput>
      | AiBotCreateWithoutOwnerInput[]
      | AiBotUncheckedCreateWithoutOwnerInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutOwnerInput
      | AiBotCreateOrConnectWithoutOwnerInput[];
    upsert?:
      | AiBotUpsertWithWhereUniqueWithoutOwnerInput
      | AiBotUpsertWithWhereUniqueWithoutOwnerInput[];
    createMany?: AiBotCreateManyOwnerInputEnvelope;
    set?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    disconnect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    delete?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    update?:
      | AiBotUpdateWithWhereUniqueWithoutOwnerInput
      | AiBotUpdateWithWhereUniqueWithoutOwnerInput[];
    updateMany?:
      | AiBotUpdateManyWithWhereWithoutOwnerInput
      | AiBotUpdateManyWithWhereWithoutOwnerInput[];
    deleteMany?: AiBotScalarWhereInput | AiBotScalarWhereInput[];
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutUserInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput
        >
      | UserPaperlessInstanceAccessCreateWithoutUserInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutUserInput
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyUserInputEnvelope;
    set?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    disconnect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    delete?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    update?:
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutUserInput
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutUserInput
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | UserPaperlessInstanceAccessScalarWhereInput
      | UserPaperlessInstanceAccessScalarWhereInput[];
  };

  export type UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutUserInput,
          UserAiAccountAccessUncheckedCreateWithoutUserInput
        >
      | UserAiAccountAccessCreateWithoutUserInput[]
      | UserAiAccountAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutUserInput
      | UserAiAccountAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutUserInput
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserAiAccountAccessCreateManyUserInputEnvelope;
    set?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    disconnect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    delete?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    update?:
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutUserInput
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserAiAccountAccessUpdateManyWithWhereWithoutUserInput
      | UserAiAccountAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserAiAccountAccessScalarWhereInput | UserAiAccountAccessScalarWhereInput[];
  };

  export type UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutUserInput,
          UserAiModelAccessUncheckedCreateWithoutUserInput
        >
      | UserAiModelAccessCreateWithoutUserInput[]
      | UserAiModelAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutUserInput
      | UserAiModelAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserAiModelAccessUpsertWithWhereUniqueWithoutUserInput
      | UserAiModelAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserAiModelAccessCreateManyUserInputEnvelope;
    set?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    disconnect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    delete?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    update?:
      | UserAiModelAccessUpdateWithWhereUniqueWithoutUserInput
      | UserAiModelAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserAiModelAccessUpdateManyWithWhereWithoutUserInput
      | UserAiModelAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserAiModelAccessScalarWhereInput | UserAiModelAccessScalarWhereInput[];
  };

  export type UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutUserInput, UserAiBotAccessUncheckedCreateWithoutUserInput>
      | UserAiBotAccessCreateWithoutUserInput[]
      | UserAiBotAccessUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutUserInput
      | UserAiBotAccessCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserAiBotAccessUpsertWithWhereUniqueWithoutUserInput
      | UserAiBotAccessUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserAiBotAccessCreateManyUserInputEnvelope;
    set?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    disconnect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    delete?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    update?:
      | UserAiBotAccessUpdateWithWhereUniqueWithoutUserInput
      | UserAiBotAccessUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserAiBotAccessUpdateManyWithWhereWithoutUserInput
      | UserAiBotAccessUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserAiBotAccessScalarWhereInput | UserAiBotAccessScalarWhereInput[];
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutUserInput, AiUsageMetricUncheckedCreateWithoutUserInput>
      | AiUsageMetricCreateWithoutUserInput[]
      | AiUsageMetricUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutUserInput
      | AiUsageMetricCreateOrConnectWithoutUserInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutUserInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AiUsageMetricCreateManyUserInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutUserInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutUserInput
      | AiUsageMetricUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          WebAuthnCredentialCreateWithoutUserInput,
          WebAuthnCredentialUncheckedCreateWithoutUserInput
        >
      | WebAuthnCredentialCreateWithoutUserInput[]
      | WebAuthnCredentialUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | WebAuthnCredentialCreateOrConnectWithoutUserInput
      | WebAuthnCredentialCreateOrConnectWithoutUserInput[];
    upsert?:
      | WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput
      | WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: WebAuthnCredentialCreateManyUserInputEnvelope;
    set?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    disconnect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    delete?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    connect?: WebAuthnCredentialWhereUniqueInput | WebAuthnCredentialWhereUniqueInput[];
    update?:
      | WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput
      | WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | WebAuthnCredentialUpdateManyWithWhereWithoutUserInput
      | WebAuthnCredentialUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutSharedPaperlessInstancesInput = {
    create?: XOR<
      UserCreateWithoutSharedPaperlessInstancesInput,
      UserUncheckedCreateWithoutSharedPaperlessInstancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSharedPaperlessInstancesInput;
    connect?: UserWhereUniqueInput;
  };

  export type PaperlessInstanceCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutSharedWithInput,
      PaperlessInstanceUncheckedCreateWithoutSharedWithInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutSharedWithInput;
    connect?: PaperlessInstanceWhereUniqueInput;
  };

  export type EnumPermissionFieldUpdateOperationsInput = {
    set?: $Enums.Permission;
  };

  export type UserUpdateOneWithoutSharedPaperlessInstancesNestedInput = {
    create?: XOR<
      UserCreateWithoutSharedPaperlessInstancesInput,
      UserUncheckedCreateWithoutSharedPaperlessInstancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSharedPaperlessInstancesInput;
    upsert?: UserUpsertWithoutSharedPaperlessInstancesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSharedPaperlessInstancesInput,
        UserUpdateWithoutSharedPaperlessInstancesInput
      >,
      UserUncheckedUpdateWithoutSharedPaperlessInstancesInput
    >;
  };

  export type PaperlessInstanceUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutSharedWithInput,
      PaperlessInstanceUncheckedCreateWithoutSharedWithInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutSharedWithInput;
    upsert?: PaperlessInstanceUpsertWithoutSharedWithInput;
    connect?: PaperlessInstanceWhereUniqueInput;
    update?: XOR<
      XOR<
        PaperlessInstanceUpdateToOneWithWhereWithoutSharedWithInput,
        PaperlessInstanceUpdateWithoutSharedWithInput
      >,
      PaperlessInstanceUncheckedUpdateWithoutSharedWithInput
    >;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type UserCreateNestedOneWithoutSharedAiAccountsInput = {
    create?: XOR<
      UserCreateWithoutSharedAiAccountsInput,
      UserUncheckedCreateWithoutSharedAiAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSharedAiAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AiAccountCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<
      AiAccountCreateWithoutSharedWithInput,
      AiAccountUncheckedCreateWithoutSharedWithInput
    >;
    connectOrCreate?: AiAccountCreateOrConnectWithoutSharedWithInput;
    connect?: AiAccountWhereUniqueInput;
  };

  export type UserUpdateOneWithoutSharedAiAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutSharedAiAccountsInput,
      UserUncheckedCreateWithoutSharedAiAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSharedAiAccountsInput;
    upsert?: UserUpsertWithoutSharedAiAccountsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutSharedAiAccountsInput,
        UserUpdateWithoutSharedAiAccountsInput
      >,
      UserUncheckedUpdateWithoutSharedAiAccountsInput
    >;
  };

  export type AiAccountUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<
      AiAccountCreateWithoutSharedWithInput,
      AiAccountUncheckedCreateWithoutSharedWithInput
    >;
    connectOrCreate?: AiAccountCreateOrConnectWithoutSharedWithInput;
    upsert?: AiAccountUpsertWithoutSharedWithInput;
    connect?: AiAccountWhereUniqueInput;
    update?: XOR<
      XOR<
        AiAccountUpdateToOneWithWhereWithoutSharedWithInput,
        AiAccountUpdateWithoutSharedWithInput
      >,
      AiAccountUncheckedUpdateWithoutSharedWithInput
    >;
  };

  export type UserCreateNestedOneWithoutSharedAiModelsInput = {
    create?: XOR<
      UserCreateWithoutSharedAiModelsInput,
      UserUncheckedCreateWithoutSharedAiModelsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSharedAiModelsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AiModelCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<AiModelCreateWithoutSharedWithInput, AiModelUncheckedCreateWithoutSharedWithInput>;
    connectOrCreate?: AiModelCreateOrConnectWithoutSharedWithInput;
    connect?: AiModelWhereUniqueInput;
  };

  export type UserUpdateOneWithoutSharedAiModelsNestedInput = {
    create?: XOR<
      UserCreateWithoutSharedAiModelsInput,
      UserUncheckedCreateWithoutSharedAiModelsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutSharedAiModelsInput;
    upsert?: UserUpsertWithoutSharedAiModelsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSharedAiModelsInput, UserUpdateWithoutSharedAiModelsInput>,
      UserUncheckedUpdateWithoutSharedAiModelsInput
    >;
  };

  export type AiModelUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<AiModelCreateWithoutSharedWithInput, AiModelUncheckedCreateWithoutSharedWithInput>;
    connectOrCreate?: AiModelCreateOrConnectWithoutSharedWithInput;
    upsert?: AiModelUpsertWithoutSharedWithInput;
    connect?: AiModelWhereUniqueInput;
    update?: XOR<
      XOR<AiModelUpdateToOneWithWhereWithoutSharedWithInput, AiModelUpdateWithoutSharedWithInput>,
      AiModelUncheckedUpdateWithoutSharedWithInput
    >;
  };

  export type UserCreateNestedOneWithoutSharedAiBotsInput = {
    create?: XOR<UserCreateWithoutSharedAiBotsInput, UserUncheckedCreateWithoutSharedAiBotsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSharedAiBotsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AiBotCreateNestedOneWithoutSharedWithInput = {
    create?: XOR<AiBotCreateWithoutSharedWithInput, AiBotUncheckedCreateWithoutSharedWithInput>;
    connectOrCreate?: AiBotCreateOrConnectWithoutSharedWithInput;
    connect?: AiBotWhereUniqueInput;
  };

  export type UserUpdateOneWithoutSharedAiBotsNestedInput = {
    create?: XOR<UserCreateWithoutSharedAiBotsInput, UserUncheckedCreateWithoutSharedAiBotsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutSharedAiBotsInput;
    upsert?: UserUpsertWithoutSharedAiBotsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutSharedAiBotsInput, UserUpdateWithoutSharedAiBotsInput>,
      UserUncheckedUpdateWithoutSharedAiBotsInput
    >;
  };

  export type AiBotUpdateOneRequiredWithoutSharedWithNestedInput = {
    create?: XOR<AiBotCreateWithoutSharedWithInput, AiBotUncheckedCreateWithoutSharedWithInput>;
    connectOrCreate?: AiBotCreateOrConnectWithoutSharedWithInput;
    upsert?: AiBotUpsertWithoutSharedWithInput;
    connect?: AiBotWhereUniqueInput;
    update?: XOR<
      XOR<AiBotUpdateToOneWithWhereWithoutSharedWithInput, AiBotUpdateWithoutSharedWithInput>,
      AiBotUncheckedUpdateWithoutSharedWithInput
    >;
  };

  export type PaperlessInstanceCreateimportFilterTagsInput = {
    set: number[];
  };

  export type AiBotCreateNestedOneWithoutDefaultForInstancesInput = {
    create?: XOR<
      AiBotCreateWithoutDefaultForInstancesInput,
      AiBotUncheckedCreateWithoutDefaultForInstancesInput
    >;
    connectOrCreate?: AiBotCreateOrConnectWithoutDefaultForInstancesInput;
    connect?: AiBotWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutOwnedPaperlessInstancesInput = {
    create?: XOR<
      UserCreateWithoutOwnedPaperlessInstancesInput,
      UserUncheckedCreateWithoutOwnedPaperlessInstancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedPaperlessInstancesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutInstanceInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput
        >
      | UserPaperlessInstanceAccessCreateWithoutInstanceInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyInstanceInputEnvelope;
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
  };

  export type PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput = {
    create?:
      | XOR<
          PaperlessDocumentCreateWithoutPaperlessInstanceInput,
          PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput
        >
      | PaperlessDocumentCreateWithoutPaperlessInstanceInput[]
      | PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput[];
    createMany?: PaperlessDocumentCreateManyPaperlessInstanceInputEnvelope;
    connect?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
  };

  export type ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutPaperlessInstanceInput,
          ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ProcessingQueueCreateWithoutPaperlessInstanceInput[]
      | ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput[];
    createMany?: ProcessingQueueCreateManyPaperlessInstanceInputEnvelope;
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
  };

  export type ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput = {
    create?:
      | XOR<
          ImportHistoryCreateWithoutPaperlessInstanceInput,
          ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ImportHistoryCreateWithoutPaperlessInstanceInput[]
      | ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput[];
    createMany?: ImportHistoryCreateManyPaperlessInstanceInputEnvelope;
    connect?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
  };

  export type UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutInstanceInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput
        >
      | UserPaperlessInstanceAccessCreateWithoutInstanceInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyInstanceInputEnvelope;
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
  };

  export type PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput = {
    create?:
      | XOR<
          PaperlessDocumentCreateWithoutPaperlessInstanceInput,
          PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput
        >
      | PaperlessDocumentCreateWithoutPaperlessInstanceInput[]
      | PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput[];
    createMany?: PaperlessDocumentCreateManyPaperlessInstanceInputEnvelope;
    connect?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
  };

  export type ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutPaperlessInstanceInput,
          ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ProcessingQueueCreateWithoutPaperlessInstanceInput[]
      | ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput[];
    createMany?: ProcessingQueueCreateManyPaperlessInstanceInputEnvelope;
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
  };

  export type ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput = {
    create?:
      | XOR<
          ImportHistoryCreateWithoutPaperlessInstanceInput,
          ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ImportHistoryCreateWithoutPaperlessInstanceInput[]
      | ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput[];
    createMany?: ImportHistoryCreateManyPaperlessInstanceInputEnvelope;
    connect?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
  };

  export type PaperlessInstanceUpdateimportFilterTagsInput = {
    set?: number[];
    push?: number | number[];
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type AiBotUpdateOneWithoutDefaultForInstancesNestedInput = {
    create?: XOR<
      AiBotCreateWithoutDefaultForInstancesInput,
      AiBotUncheckedCreateWithoutDefaultForInstancesInput
    >;
    connectOrCreate?: AiBotCreateOrConnectWithoutDefaultForInstancesInput;
    upsert?: AiBotUpsertWithoutDefaultForInstancesInput;
    disconnect?: AiBotWhereInput | boolean;
    delete?: AiBotWhereInput | boolean;
    connect?: AiBotWhereUniqueInput;
    update?: XOR<
      XOR<
        AiBotUpdateToOneWithWhereWithoutDefaultForInstancesInput,
        AiBotUpdateWithoutDefaultForInstancesInput
      >,
      AiBotUncheckedUpdateWithoutDefaultForInstancesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput = {
    create?: XOR<
      UserCreateWithoutOwnedPaperlessInstancesInput,
      UserUncheckedCreateWithoutOwnedPaperlessInstancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedPaperlessInstancesInput;
    upsert?: UserUpsertWithoutOwnedPaperlessInstancesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutOwnedPaperlessInstancesInput,
        UserUpdateWithoutOwnedPaperlessInstancesInput
      >,
      UserUncheckedUpdateWithoutOwnedPaperlessInstancesInput
    >;
  };

  export type UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutInstanceInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput
        >
      | UserPaperlessInstanceAccessCreateWithoutInstanceInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput[];
    upsert?:
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutInstanceInput
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutInstanceInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyInstanceInputEnvelope;
    set?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    disconnect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    delete?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    update?:
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutInstanceInput
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutInstanceInput[];
    updateMany?:
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutInstanceInput
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutInstanceInput[];
    deleteMany?:
      | UserPaperlessInstanceAccessScalarWhereInput
      | UserPaperlessInstanceAccessScalarWhereInput[];
  };

  export type PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput = {
    create?:
      | XOR<
          PaperlessDocumentCreateWithoutPaperlessInstanceInput,
          PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput
        >
      | PaperlessDocumentCreateWithoutPaperlessInstanceInput[]
      | PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput[];
    upsert?:
      | PaperlessDocumentUpsertWithWhereUniqueWithoutPaperlessInstanceInput
      | PaperlessDocumentUpsertWithWhereUniqueWithoutPaperlessInstanceInput[];
    createMany?: PaperlessDocumentCreateManyPaperlessInstanceInputEnvelope;
    set?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    disconnect?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    delete?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    connect?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    update?:
      | PaperlessDocumentUpdateWithWhereUniqueWithoutPaperlessInstanceInput
      | PaperlessDocumentUpdateWithWhereUniqueWithoutPaperlessInstanceInput[];
    updateMany?:
      | PaperlessDocumentUpdateManyWithWhereWithoutPaperlessInstanceInput
      | PaperlessDocumentUpdateManyWithWhereWithoutPaperlessInstanceInput[];
    deleteMany?: PaperlessDocumentScalarWhereInput | PaperlessDocumentScalarWhereInput[];
  };

  export type ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutPaperlessInstanceInput,
          ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ProcessingQueueCreateWithoutPaperlessInstanceInput[]
      | ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput[];
    upsert?:
      | ProcessingQueueUpsertWithWhereUniqueWithoutPaperlessInstanceInput
      | ProcessingQueueUpsertWithWhereUniqueWithoutPaperlessInstanceInput[];
    createMany?: ProcessingQueueCreateManyPaperlessInstanceInputEnvelope;
    set?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    disconnect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    delete?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    update?:
      | ProcessingQueueUpdateWithWhereUniqueWithoutPaperlessInstanceInput
      | ProcessingQueueUpdateWithWhereUniqueWithoutPaperlessInstanceInput[];
    updateMany?:
      | ProcessingQueueUpdateManyWithWhereWithoutPaperlessInstanceInput
      | ProcessingQueueUpdateManyWithWhereWithoutPaperlessInstanceInput[];
    deleteMany?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
  };

  export type ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput = {
    create?:
      | XOR<
          ImportHistoryCreateWithoutPaperlessInstanceInput,
          ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ImportHistoryCreateWithoutPaperlessInstanceInput[]
      | ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput[];
    upsert?:
      | ImportHistoryUpsertWithWhereUniqueWithoutPaperlessInstanceInput
      | ImportHistoryUpsertWithWhereUniqueWithoutPaperlessInstanceInput[];
    createMany?: ImportHistoryCreateManyPaperlessInstanceInputEnvelope;
    set?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    disconnect?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    delete?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    connect?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    update?:
      | ImportHistoryUpdateWithWhereUniqueWithoutPaperlessInstanceInput
      | ImportHistoryUpdateWithWhereUniqueWithoutPaperlessInstanceInput[];
    updateMany?:
      | ImportHistoryUpdateManyWithWhereWithoutPaperlessInstanceInput
      | ImportHistoryUpdateManyWithWhereWithoutPaperlessInstanceInput[];
    deleteMany?: ImportHistoryScalarWhereInput | ImportHistoryScalarWhereInput[];
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput = {
    create?:
      | XOR<
          UserPaperlessInstanceAccessCreateWithoutInstanceInput,
          UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput
        >
      | UserPaperlessInstanceAccessCreateWithoutInstanceInput[]
      | UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput[];
    connectOrCreate?:
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput
      | UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput[];
    upsert?:
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutInstanceInput
      | UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutInstanceInput[];
    createMany?: UserPaperlessInstanceAccessCreateManyInstanceInputEnvelope;
    set?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    disconnect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    delete?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    connect?:
      | UserPaperlessInstanceAccessWhereUniqueInput
      | UserPaperlessInstanceAccessWhereUniqueInput[];
    update?:
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutInstanceInput
      | UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutInstanceInput[];
    updateMany?:
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutInstanceInput
      | UserPaperlessInstanceAccessUpdateManyWithWhereWithoutInstanceInput[];
    deleteMany?:
      | UserPaperlessInstanceAccessScalarWhereInput
      | UserPaperlessInstanceAccessScalarWhereInput[];
  };

  export type PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput = {
    create?:
      | XOR<
          PaperlessDocumentCreateWithoutPaperlessInstanceInput,
          PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput
        >
      | PaperlessDocumentCreateWithoutPaperlessInstanceInput[]
      | PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput
      | PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput[];
    upsert?:
      | PaperlessDocumentUpsertWithWhereUniqueWithoutPaperlessInstanceInput
      | PaperlessDocumentUpsertWithWhereUniqueWithoutPaperlessInstanceInput[];
    createMany?: PaperlessDocumentCreateManyPaperlessInstanceInputEnvelope;
    set?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    disconnect?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    delete?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    connect?: PaperlessDocumentWhereUniqueInput | PaperlessDocumentWhereUniqueInput[];
    update?:
      | PaperlessDocumentUpdateWithWhereUniqueWithoutPaperlessInstanceInput
      | PaperlessDocumentUpdateWithWhereUniqueWithoutPaperlessInstanceInput[];
    updateMany?:
      | PaperlessDocumentUpdateManyWithWhereWithoutPaperlessInstanceInput
      | PaperlessDocumentUpdateManyWithWhereWithoutPaperlessInstanceInput[];
    deleteMany?: PaperlessDocumentScalarWhereInput | PaperlessDocumentScalarWhereInput[];
  };

  export type ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutPaperlessInstanceInput,
          ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ProcessingQueueCreateWithoutPaperlessInstanceInput[]
      | ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput
      | ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput[];
    upsert?:
      | ProcessingQueueUpsertWithWhereUniqueWithoutPaperlessInstanceInput
      | ProcessingQueueUpsertWithWhereUniqueWithoutPaperlessInstanceInput[];
    createMany?: ProcessingQueueCreateManyPaperlessInstanceInputEnvelope;
    set?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    disconnect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    delete?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    update?:
      | ProcessingQueueUpdateWithWhereUniqueWithoutPaperlessInstanceInput
      | ProcessingQueueUpdateWithWhereUniqueWithoutPaperlessInstanceInput[];
    updateMany?:
      | ProcessingQueueUpdateManyWithWhereWithoutPaperlessInstanceInput
      | ProcessingQueueUpdateManyWithWhereWithoutPaperlessInstanceInput[];
    deleteMany?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
  };

  export type ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput = {
    create?:
      | XOR<
          ImportHistoryCreateWithoutPaperlessInstanceInput,
          ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput
        >
      | ImportHistoryCreateWithoutPaperlessInstanceInput[]
      | ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput[];
    connectOrCreate?:
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput
      | ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput[];
    upsert?:
      | ImportHistoryUpsertWithWhereUniqueWithoutPaperlessInstanceInput
      | ImportHistoryUpsertWithWhereUniqueWithoutPaperlessInstanceInput[];
    createMany?: ImportHistoryCreateManyPaperlessInstanceInputEnvelope;
    set?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    disconnect?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    delete?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    connect?: ImportHistoryWhereUniqueInput | ImportHistoryWhereUniqueInput[];
    update?:
      | ImportHistoryUpdateWithWhereUniqueWithoutPaperlessInstanceInput
      | ImportHistoryUpdateWithWhereUniqueWithoutPaperlessInstanceInput[];
    updateMany?:
      | ImportHistoryUpdateManyWithWhereWithoutPaperlessInstanceInput
      | ImportHistoryUpdateManyWithWhereWithoutPaperlessInstanceInput[];
    deleteMany?: ImportHistoryScalarWhereInput | ImportHistoryScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutOwnedAiAccountsInput = {
    create?: XOR<
      UserCreateWithoutOwnedAiAccountsInput,
      UserUncheckedCreateWithoutOwnedAiAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAiAccountsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserAiAccountAccessCreateNestedManyWithoutAiAccountInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutAiAccountInput,
          UserAiAccountAccessUncheckedCreateWithoutAiAccountInput
        >
      | UserAiAccountAccessCreateWithoutAiAccountInput[]
      | UserAiAccountAccessUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput[];
    createMany?: UserAiAccountAccessCreateManyAiAccountInputEnvelope;
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
  };

  export type AiModelCreateNestedManyWithoutAiAccountInput = {
    create?:
      | XOR<AiModelCreateWithoutAiAccountInput, AiModelUncheckedCreateWithoutAiAccountInput>
      | AiModelCreateWithoutAiAccountInput[]
      | AiModelUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutAiAccountInput
      | AiModelCreateOrConnectWithoutAiAccountInput[];
    createMany?: AiModelCreateManyAiAccountInputEnvelope;
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
  };

  export type AiUsageMetricCreateNestedManyWithoutAiAccountInput = {
    create?:
      | XOR<
          AiUsageMetricCreateWithoutAiAccountInput,
          AiUsageMetricUncheckedCreateWithoutAiAccountInput
        >
      | AiUsageMetricCreateWithoutAiAccountInput[]
      | AiUsageMetricUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput[];
    createMany?: AiUsageMetricCreateManyAiAccountInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type UserAiAccountAccessUncheckedCreateNestedManyWithoutAiAccountInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutAiAccountInput,
          UserAiAccountAccessUncheckedCreateWithoutAiAccountInput
        >
      | UserAiAccountAccessCreateWithoutAiAccountInput[]
      | UserAiAccountAccessUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput[];
    createMany?: UserAiAccountAccessCreateManyAiAccountInputEnvelope;
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
  };

  export type AiModelUncheckedCreateNestedManyWithoutAiAccountInput = {
    create?:
      | XOR<AiModelCreateWithoutAiAccountInput, AiModelUncheckedCreateWithoutAiAccountInput>
      | AiModelCreateWithoutAiAccountInput[]
      | AiModelUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutAiAccountInput
      | AiModelCreateOrConnectWithoutAiAccountInput[];
    createMany?: AiModelCreateManyAiAccountInputEnvelope;
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
  };

  export type AiUsageMetricUncheckedCreateNestedManyWithoutAiAccountInput = {
    create?:
      | XOR<
          AiUsageMetricCreateWithoutAiAccountInput,
          AiUsageMetricUncheckedCreateWithoutAiAccountInput
        >
      | AiUsageMetricCreateWithoutAiAccountInput[]
      | AiUsageMetricUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput[];
    createMany?: AiUsageMetricCreateManyAiAccountInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutOwnedAiAccountsNestedInput = {
    create?: XOR<
      UserCreateWithoutOwnedAiAccountsInput,
      UserUncheckedCreateWithoutOwnedAiAccountsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAiAccountsInput;
    upsert?: UserUpsertWithoutOwnedAiAccountsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutOwnedAiAccountsInput,
        UserUpdateWithoutOwnedAiAccountsInput
      >,
      UserUncheckedUpdateWithoutOwnedAiAccountsInput
    >;
  };

  export type UserAiAccountAccessUpdateManyWithoutAiAccountNestedInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutAiAccountInput,
          UserAiAccountAccessUncheckedCreateWithoutAiAccountInput
        >
      | UserAiAccountAccessCreateWithoutAiAccountInput[]
      | UserAiAccountAccessUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput[];
    upsert?:
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutAiAccountInput
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutAiAccountInput[];
    createMany?: UserAiAccountAccessCreateManyAiAccountInputEnvelope;
    set?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    disconnect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    delete?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    update?:
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutAiAccountInput
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutAiAccountInput[];
    updateMany?:
      | UserAiAccountAccessUpdateManyWithWhereWithoutAiAccountInput
      | UserAiAccountAccessUpdateManyWithWhereWithoutAiAccountInput[];
    deleteMany?: UserAiAccountAccessScalarWhereInput | UserAiAccountAccessScalarWhereInput[];
  };

  export type AiModelUpdateManyWithoutAiAccountNestedInput = {
    create?:
      | XOR<AiModelCreateWithoutAiAccountInput, AiModelUncheckedCreateWithoutAiAccountInput>
      | AiModelCreateWithoutAiAccountInput[]
      | AiModelUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutAiAccountInput
      | AiModelCreateOrConnectWithoutAiAccountInput[];
    upsert?:
      | AiModelUpsertWithWhereUniqueWithoutAiAccountInput
      | AiModelUpsertWithWhereUniqueWithoutAiAccountInput[];
    createMany?: AiModelCreateManyAiAccountInputEnvelope;
    set?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    disconnect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    delete?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    update?:
      | AiModelUpdateWithWhereUniqueWithoutAiAccountInput
      | AiModelUpdateWithWhereUniqueWithoutAiAccountInput[];
    updateMany?:
      | AiModelUpdateManyWithWhereWithoutAiAccountInput
      | AiModelUpdateManyWithWhereWithoutAiAccountInput[];
    deleteMany?: AiModelScalarWhereInput | AiModelScalarWhereInput[];
  };

  export type AiUsageMetricUpdateManyWithoutAiAccountNestedInput = {
    create?:
      | XOR<
          AiUsageMetricCreateWithoutAiAccountInput,
          AiUsageMetricUncheckedCreateWithoutAiAccountInput
        >
      | AiUsageMetricCreateWithoutAiAccountInput[]
      | AiUsageMetricUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiAccountInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiAccountInput[];
    createMany?: AiUsageMetricCreateManyAiAccountInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiAccountInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiAccountInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutAiAccountInput
      | AiUsageMetricUpdateManyWithWhereWithoutAiAccountInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountNestedInput = {
    create?:
      | XOR<
          UserAiAccountAccessCreateWithoutAiAccountInput,
          UserAiAccountAccessUncheckedCreateWithoutAiAccountInput
        >
      | UserAiAccountAccessCreateWithoutAiAccountInput[]
      | UserAiAccountAccessUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput
      | UserAiAccountAccessCreateOrConnectWithoutAiAccountInput[];
    upsert?:
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutAiAccountInput
      | UserAiAccountAccessUpsertWithWhereUniqueWithoutAiAccountInput[];
    createMany?: UserAiAccountAccessCreateManyAiAccountInputEnvelope;
    set?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    disconnect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    delete?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    connect?: UserAiAccountAccessWhereUniqueInput | UserAiAccountAccessWhereUniqueInput[];
    update?:
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutAiAccountInput
      | UserAiAccountAccessUpdateWithWhereUniqueWithoutAiAccountInput[];
    updateMany?:
      | UserAiAccountAccessUpdateManyWithWhereWithoutAiAccountInput
      | UserAiAccountAccessUpdateManyWithWhereWithoutAiAccountInput[];
    deleteMany?: UserAiAccountAccessScalarWhereInput | UserAiAccountAccessScalarWhereInput[];
  };

  export type AiModelUncheckedUpdateManyWithoutAiAccountNestedInput = {
    create?:
      | XOR<AiModelCreateWithoutAiAccountInput, AiModelUncheckedCreateWithoutAiAccountInput>
      | AiModelCreateWithoutAiAccountInput[]
      | AiModelUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiModelCreateOrConnectWithoutAiAccountInput
      | AiModelCreateOrConnectWithoutAiAccountInput[];
    upsert?:
      | AiModelUpsertWithWhereUniqueWithoutAiAccountInput
      | AiModelUpsertWithWhereUniqueWithoutAiAccountInput[];
    createMany?: AiModelCreateManyAiAccountInputEnvelope;
    set?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    disconnect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    delete?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    connect?: AiModelWhereUniqueInput | AiModelWhereUniqueInput[];
    update?:
      | AiModelUpdateWithWhereUniqueWithoutAiAccountInput
      | AiModelUpdateWithWhereUniqueWithoutAiAccountInput[];
    updateMany?:
      | AiModelUpdateManyWithWhereWithoutAiAccountInput
      | AiModelUpdateManyWithWhereWithoutAiAccountInput[];
    deleteMany?: AiModelScalarWhereInput | AiModelScalarWhereInput[];
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutAiAccountNestedInput = {
    create?:
      | XOR<
          AiUsageMetricCreateWithoutAiAccountInput,
          AiUsageMetricUncheckedCreateWithoutAiAccountInput
        >
      | AiUsageMetricCreateWithoutAiAccountInput[]
      | AiUsageMetricUncheckedCreateWithoutAiAccountInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput
      | AiUsageMetricCreateOrConnectWithoutAiAccountInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiAccountInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiAccountInput[];
    createMany?: AiUsageMetricCreateManyAiAccountInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiAccountInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiAccountInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutAiAccountInput
      | AiUsageMetricUpdateManyWithWhereWithoutAiAccountInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutOwnedAiModelsInput = {
    create?: XOR<UserCreateWithoutOwnedAiModelsInput, UserUncheckedCreateWithoutOwnedAiModelsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAiModelsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AiAccountCreateNestedOneWithoutModelsInput = {
    create?: XOR<AiAccountCreateWithoutModelsInput, AiAccountUncheckedCreateWithoutModelsInput>;
    connectOrCreate?: AiAccountCreateOrConnectWithoutModelsInput;
    connect?: AiAccountWhereUniqueInput;
  };

  export type UserAiModelAccessCreateNestedManyWithoutAiModelInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutAiModelInput,
          UserAiModelAccessUncheckedCreateWithoutAiModelInput
        >
      | UserAiModelAccessCreateWithoutAiModelInput[]
      | UserAiModelAccessUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput[];
    createMany?: UserAiModelAccessCreateManyAiModelInputEnvelope;
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
  };

  export type AiBotCreateNestedManyWithoutAiModelInput = {
    create?:
      | XOR<AiBotCreateWithoutAiModelInput, AiBotUncheckedCreateWithoutAiModelInput>
      | AiBotCreateWithoutAiModelInput[]
      | AiBotUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutAiModelInput
      | AiBotCreateOrConnectWithoutAiModelInput[];
    createMany?: AiBotCreateManyAiModelInputEnvelope;
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
  };

  export type AiUsageMetricCreateNestedManyWithoutAiModelInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiModelInput, AiUsageMetricUncheckedCreateWithoutAiModelInput>
      | AiUsageMetricCreateWithoutAiModelInput[]
      | AiUsageMetricUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiModelInput
      | AiUsageMetricCreateOrConnectWithoutAiModelInput[];
    createMany?: AiUsageMetricCreateManyAiModelInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type UserAiModelAccessUncheckedCreateNestedManyWithoutAiModelInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutAiModelInput,
          UserAiModelAccessUncheckedCreateWithoutAiModelInput
        >
      | UserAiModelAccessCreateWithoutAiModelInput[]
      | UserAiModelAccessUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput[];
    createMany?: UserAiModelAccessCreateManyAiModelInputEnvelope;
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
  };

  export type AiBotUncheckedCreateNestedManyWithoutAiModelInput = {
    create?:
      | XOR<AiBotCreateWithoutAiModelInput, AiBotUncheckedCreateWithoutAiModelInput>
      | AiBotCreateWithoutAiModelInput[]
      | AiBotUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutAiModelInput
      | AiBotCreateOrConnectWithoutAiModelInput[];
    createMany?: AiBotCreateManyAiModelInputEnvelope;
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
  };

  export type AiUsageMetricUncheckedCreateNestedManyWithoutAiModelInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiModelInput, AiUsageMetricUncheckedCreateWithoutAiModelInput>
      | AiUsageMetricCreateWithoutAiModelInput[]
      | AiUsageMetricUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiModelInput
      | AiUsageMetricCreateOrConnectWithoutAiModelInput[];
    createMany?: AiUsageMetricCreateManyAiModelInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutOwnedAiModelsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedAiModelsInput, UserUncheckedCreateWithoutOwnedAiModelsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAiModelsInput;
    upsert?: UserUpsertWithoutOwnedAiModelsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutOwnedAiModelsInput, UserUpdateWithoutOwnedAiModelsInput>,
      UserUncheckedUpdateWithoutOwnedAiModelsInput
    >;
  };

  export type AiAccountUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<AiAccountCreateWithoutModelsInput, AiAccountUncheckedCreateWithoutModelsInput>;
    connectOrCreate?: AiAccountCreateOrConnectWithoutModelsInput;
    upsert?: AiAccountUpsertWithoutModelsInput;
    connect?: AiAccountWhereUniqueInput;
    update?: XOR<
      XOR<AiAccountUpdateToOneWithWhereWithoutModelsInput, AiAccountUpdateWithoutModelsInput>,
      AiAccountUncheckedUpdateWithoutModelsInput
    >;
  };

  export type UserAiModelAccessUpdateManyWithoutAiModelNestedInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutAiModelInput,
          UserAiModelAccessUncheckedCreateWithoutAiModelInput
        >
      | UserAiModelAccessCreateWithoutAiModelInput[]
      | UserAiModelAccessUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput[];
    upsert?:
      | UserAiModelAccessUpsertWithWhereUniqueWithoutAiModelInput
      | UserAiModelAccessUpsertWithWhereUniqueWithoutAiModelInput[];
    createMany?: UserAiModelAccessCreateManyAiModelInputEnvelope;
    set?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    disconnect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    delete?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    update?:
      | UserAiModelAccessUpdateWithWhereUniqueWithoutAiModelInput
      | UserAiModelAccessUpdateWithWhereUniqueWithoutAiModelInput[];
    updateMany?:
      | UserAiModelAccessUpdateManyWithWhereWithoutAiModelInput
      | UserAiModelAccessUpdateManyWithWhereWithoutAiModelInput[];
    deleteMany?: UserAiModelAccessScalarWhereInput | UserAiModelAccessScalarWhereInput[];
  };

  export type AiBotUpdateManyWithoutAiModelNestedInput = {
    create?:
      | XOR<AiBotCreateWithoutAiModelInput, AiBotUncheckedCreateWithoutAiModelInput>
      | AiBotCreateWithoutAiModelInput[]
      | AiBotUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutAiModelInput
      | AiBotCreateOrConnectWithoutAiModelInput[];
    upsert?:
      | AiBotUpsertWithWhereUniqueWithoutAiModelInput
      | AiBotUpsertWithWhereUniqueWithoutAiModelInput[];
    createMany?: AiBotCreateManyAiModelInputEnvelope;
    set?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    disconnect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    delete?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    update?:
      | AiBotUpdateWithWhereUniqueWithoutAiModelInput
      | AiBotUpdateWithWhereUniqueWithoutAiModelInput[];
    updateMany?:
      | AiBotUpdateManyWithWhereWithoutAiModelInput
      | AiBotUpdateManyWithWhereWithoutAiModelInput[];
    deleteMany?: AiBotScalarWhereInput | AiBotScalarWhereInput[];
  };

  export type AiUsageMetricUpdateManyWithoutAiModelNestedInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiModelInput, AiUsageMetricUncheckedCreateWithoutAiModelInput>
      | AiUsageMetricCreateWithoutAiModelInput[]
      | AiUsageMetricUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiModelInput
      | AiUsageMetricCreateOrConnectWithoutAiModelInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiModelInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiModelInput[];
    createMany?: AiUsageMetricCreateManyAiModelInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiModelInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiModelInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutAiModelInput
      | AiUsageMetricUpdateManyWithWhereWithoutAiModelInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type UserAiModelAccessUncheckedUpdateManyWithoutAiModelNestedInput = {
    create?:
      | XOR<
          UserAiModelAccessCreateWithoutAiModelInput,
          UserAiModelAccessUncheckedCreateWithoutAiModelInput
        >
      | UserAiModelAccessCreateWithoutAiModelInput[]
      | UserAiModelAccessUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput
      | UserAiModelAccessCreateOrConnectWithoutAiModelInput[];
    upsert?:
      | UserAiModelAccessUpsertWithWhereUniqueWithoutAiModelInput
      | UserAiModelAccessUpsertWithWhereUniqueWithoutAiModelInput[];
    createMany?: UserAiModelAccessCreateManyAiModelInputEnvelope;
    set?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    disconnect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    delete?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    connect?: UserAiModelAccessWhereUniqueInput | UserAiModelAccessWhereUniqueInput[];
    update?:
      | UserAiModelAccessUpdateWithWhereUniqueWithoutAiModelInput
      | UserAiModelAccessUpdateWithWhereUniqueWithoutAiModelInput[];
    updateMany?:
      | UserAiModelAccessUpdateManyWithWhereWithoutAiModelInput
      | UserAiModelAccessUpdateManyWithWhereWithoutAiModelInput[];
    deleteMany?: UserAiModelAccessScalarWhereInput | UserAiModelAccessScalarWhereInput[];
  };

  export type AiBotUncheckedUpdateManyWithoutAiModelNestedInput = {
    create?:
      | XOR<AiBotCreateWithoutAiModelInput, AiBotUncheckedCreateWithoutAiModelInput>
      | AiBotCreateWithoutAiModelInput[]
      | AiBotUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiBotCreateOrConnectWithoutAiModelInput
      | AiBotCreateOrConnectWithoutAiModelInput[];
    upsert?:
      | AiBotUpsertWithWhereUniqueWithoutAiModelInput
      | AiBotUpsertWithWhereUniqueWithoutAiModelInput[];
    createMany?: AiBotCreateManyAiModelInputEnvelope;
    set?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    disconnect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    delete?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    connect?: AiBotWhereUniqueInput | AiBotWhereUniqueInput[];
    update?:
      | AiBotUpdateWithWhereUniqueWithoutAiModelInput
      | AiBotUpdateWithWhereUniqueWithoutAiModelInput[];
    updateMany?:
      | AiBotUpdateManyWithWhereWithoutAiModelInput
      | AiBotUpdateManyWithWhereWithoutAiModelInput[];
    deleteMany?: AiBotScalarWhereInput | AiBotScalarWhereInput[];
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutAiModelNestedInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiModelInput, AiUsageMetricUncheckedCreateWithoutAiModelInput>
      | AiUsageMetricCreateWithoutAiModelInput[]
      | AiUsageMetricUncheckedCreateWithoutAiModelInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiModelInput
      | AiUsageMetricCreateOrConnectWithoutAiModelInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiModelInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiModelInput[];
    createMany?: AiUsageMetricCreateManyAiModelInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiModelInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiModelInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutAiModelInput
      | AiUsageMetricUpdateManyWithWhereWithoutAiModelInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutOwnedAiBotsInput = {
    create?: XOR<UserCreateWithoutOwnedAiBotsInput, UserUncheckedCreateWithoutOwnedAiBotsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAiBotsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AiModelCreateNestedOneWithoutBotsInput = {
    create?: XOR<AiModelCreateWithoutBotsInput, AiModelUncheckedCreateWithoutBotsInput>;
    connectOrCreate?: AiModelCreateOrConnectWithoutBotsInput;
    connect?: AiModelWhereUniqueInput;
  };

  export type UserAiBotAccessCreateNestedManyWithoutAiBotInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutAiBotInput, UserAiBotAccessUncheckedCreateWithoutAiBotInput>
      | UserAiBotAccessCreateWithoutAiBotInput[]
      | UserAiBotAccessUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput[];
    createMany?: UserAiBotAccessCreateManyAiBotInputEnvelope;
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
  };

  export type AiUsageMetricCreateNestedManyWithoutAiBotInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiBotInput, AiUsageMetricUncheckedCreateWithoutAiBotInput>
      | AiUsageMetricCreateWithoutAiBotInput[]
      | AiUsageMetricUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiBotInput
      | AiUsageMetricCreateOrConnectWithoutAiBotInput[];
    createMany?: AiUsageMetricCreateManyAiBotInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutDefaultAiBotInput,
          PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput
        >
      | PaperlessInstanceCreateWithoutDefaultAiBotInput[]
      | PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput[];
    createMany?: PaperlessInstanceCreateManyDefaultAiBotInputEnvelope;
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
  };

  export type ProcessingQueueCreateNestedManyWithoutAiBotInput = {
    create?:
      | XOR<ProcessingQueueCreateWithoutAiBotInput, ProcessingQueueUncheckedCreateWithoutAiBotInput>
      | ProcessingQueueCreateWithoutAiBotInput[]
      | ProcessingQueueUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutAiBotInput
      | ProcessingQueueCreateOrConnectWithoutAiBotInput[];
    createMany?: ProcessingQueueCreateManyAiBotInputEnvelope;
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
  };

  export type UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutAiBotInput, UserAiBotAccessUncheckedCreateWithoutAiBotInput>
      | UserAiBotAccessCreateWithoutAiBotInput[]
      | UserAiBotAccessUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput[];
    createMany?: UserAiBotAccessCreateManyAiBotInputEnvelope;
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
  };

  export type AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiBotInput, AiUsageMetricUncheckedCreateWithoutAiBotInput>
      | AiUsageMetricCreateWithoutAiBotInput[]
      | AiUsageMetricUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiBotInput
      | AiUsageMetricCreateOrConnectWithoutAiBotInput[];
    createMany?: AiUsageMetricCreateManyAiBotInputEnvelope;
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
  };

  export type PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutDefaultAiBotInput,
          PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput
        >
      | PaperlessInstanceCreateWithoutDefaultAiBotInput[]
      | PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput[];
    createMany?: PaperlessInstanceCreateManyDefaultAiBotInputEnvelope;
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
  };

  export type ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput = {
    create?:
      | XOR<ProcessingQueueCreateWithoutAiBotInput, ProcessingQueueUncheckedCreateWithoutAiBotInput>
      | ProcessingQueueCreateWithoutAiBotInput[]
      | ProcessingQueueUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutAiBotInput
      | ProcessingQueueCreateOrConnectWithoutAiBotInput[];
    createMany?: ProcessingQueueCreateManyAiBotInputEnvelope;
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedAiBotsInput, UserUncheckedCreateWithoutOwnedAiBotsInput>;
    connectOrCreate?: UserCreateOrConnectWithoutOwnedAiBotsInput;
    upsert?: UserUpsertWithoutOwnedAiBotsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutOwnedAiBotsInput, UserUpdateWithoutOwnedAiBotsInput>,
      UserUncheckedUpdateWithoutOwnedAiBotsInput
    >;
  };

  export type AiModelUpdateOneRequiredWithoutBotsNestedInput = {
    create?: XOR<AiModelCreateWithoutBotsInput, AiModelUncheckedCreateWithoutBotsInput>;
    connectOrCreate?: AiModelCreateOrConnectWithoutBotsInput;
    upsert?: AiModelUpsertWithoutBotsInput;
    connect?: AiModelWhereUniqueInput;
    update?: XOR<
      XOR<AiModelUpdateToOneWithWhereWithoutBotsInput, AiModelUpdateWithoutBotsInput>,
      AiModelUncheckedUpdateWithoutBotsInput
    >;
  };

  export type UserAiBotAccessUpdateManyWithoutAiBotNestedInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutAiBotInput, UserAiBotAccessUncheckedCreateWithoutAiBotInput>
      | UserAiBotAccessCreateWithoutAiBotInput[]
      | UserAiBotAccessUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput[];
    upsert?:
      | UserAiBotAccessUpsertWithWhereUniqueWithoutAiBotInput
      | UserAiBotAccessUpsertWithWhereUniqueWithoutAiBotInput[];
    createMany?: UserAiBotAccessCreateManyAiBotInputEnvelope;
    set?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    disconnect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    delete?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    update?:
      | UserAiBotAccessUpdateWithWhereUniqueWithoutAiBotInput
      | UserAiBotAccessUpdateWithWhereUniqueWithoutAiBotInput[];
    updateMany?:
      | UserAiBotAccessUpdateManyWithWhereWithoutAiBotInput
      | UserAiBotAccessUpdateManyWithWhereWithoutAiBotInput[];
    deleteMany?: UserAiBotAccessScalarWhereInput | UserAiBotAccessScalarWhereInput[];
  };

  export type AiUsageMetricUpdateManyWithoutAiBotNestedInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiBotInput, AiUsageMetricUncheckedCreateWithoutAiBotInput>
      | AiUsageMetricCreateWithoutAiBotInput[]
      | AiUsageMetricUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiBotInput
      | AiUsageMetricCreateOrConnectWithoutAiBotInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiBotInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiBotInput[];
    createMany?: AiUsageMetricCreateManyAiBotInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiBotInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiBotInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutAiBotInput
      | AiUsageMetricUpdateManyWithWhereWithoutAiBotInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutDefaultAiBotInput,
          PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput
        >
      | PaperlessInstanceCreateWithoutDefaultAiBotInput[]
      | PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput[];
    upsert?:
      | PaperlessInstanceUpsertWithWhereUniqueWithoutDefaultAiBotInput
      | PaperlessInstanceUpsertWithWhereUniqueWithoutDefaultAiBotInput[];
    createMany?: PaperlessInstanceCreateManyDefaultAiBotInputEnvelope;
    set?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    disconnect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    delete?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    update?:
      | PaperlessInstanceUpdateWithWhereUniqueWithoutDefaultAiBotInput
      | PaperlessInstanceUpdateWithWhereUniqueWithoutDefaultAiBotInput[];
    updateMany?:
      | PaperlessInstanceUpdateManyWithWhereWithoutDefaultAiBotInput
      | PaperlessInstanceUpdateManyWithWhereWithoutDefaultAiBotInput[];
    deleteMany?: PaperlessInstanceScalarWhereInput | PaperlessInstanceScalarWhereInput[];
  };

  export type ProcessingQueueUpdateManyWithoutAiBotNestedInput = {
    create?:
      | XOR<ProcessingQueueCreateWithoutAiBotInput, ProcessingQueueUncheckedCreateWithoutAiBotInput>
      | ProcessingQueueCreateWithoutAiBotInput[]
      | ProcessingQueueUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutAiBotInput
      | ProcessingQueueCreateOrConnectWithoutAiBotInput[];
    upsert?:
      | ProcessingQueueUpsertWithWhereUniqueWithoutAiBotInput
      | ProcessingQueueUpsertWithWhereUniqueWithoutAiBotInput[];
    createMany?: ProcessingQueueCreateManyAiBotInputEnvelope;
    set?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    disconnect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    delete?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    update?:
      | ProcessingQueueUpdateWithWhereUniqueWithoutAiBotInput
      | ProcessingQueueUpdateWithWhereUniqueWithoutAiBotInput[];
    updateMany?:
      | ProcessingQueueUpdateManyWithWhereWithoutAiBotInput
      | ProcessingQueueUpdateManyWithWhereWithoutAiBotInput[];
    deleteMany?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
  };

  export type UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput = {
    create?:
      | XOR<UserAiBotAccessCreateWithoutAiBotInput, UserAiBotAccessUncheckedCreateWithoutAiBotInput>
      | UserAiBotAccessCreateWithoutAiBotInput[]
      | UserAiBotAccessUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput
      | UserAiBotAccessCreateOrConnectWithoutAiBotInput[];
    upsert?:
      | UserAiBotAccessUpsertWithWhereUniqueWithoutAiBotInput
      | UserAiBotAccessUpsertWithWhereUniqueWithoutAiBotInput[];
    createMany?: UserAiBotAccessCreateManyAiBotInputEnvelope;
    set?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    disconnect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    delete?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    connect?: UserAiBotAccessWhereUniqueInput | UserAiBotAccessWhereUniqueInput[];
    update?:
      | UserAiBotAccessUpdateWithWhereUniqueWithoutAiBotInput
      | UserAiBotAccessUpdateWithWhereUniqueWithoutAiBotInput[];
    updateMany?:
      | UserAiBotAccessUpdateManyWithWhereWithoutAiBotInput
      | UserAiBotAccessUpdateManyWithWhereWithoutAiBotInput[];
    deleteMany?: UserAiBotAccessScalarWhereInput | UserAiBotAccessScalarWhereInput[];
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput = {
    create?:
      | XOR<AiUsageMetricCreateWithoutAiBotInput, AiUsageMetricUncheckedCreateWithoutAiBotInput>
      | AiUsageMetricCreateWithoutAiBotInput[]
      | AiUsageMetricUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | AiUsageMetricCreateOrConnectWithoutAiBotInput
      | AiUsageMetricCreateOrConnectWithoutAiBotInput[];
    upsert?:
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiBotInput
      | AiUsageMetricUpsertWithWhereUniqueWithoutAiBotInput[];
    createMany?: AiUsageMetricCreateManyAiBotInputEnvelope;
    set?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    disconnect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    delete?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    connect?: AiUsageMetricWhereUniqueInput | AiUsageMetricWhereUniqueInput[];
    update?:
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiBotInput
      | AiUsageMetricUpdateWithWhereUniqueWithoutAiBotInput[];
    updateMany?:
      | AiUsageMetricUpdateManyWithWhereWithoutAiBotInput
      | AiUsageMetricUpdateManyWithWhereWithoutAiBotInput[];
    deleteMany?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
  };

  export type PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput = {
    create?:
      | XOR<
          PaperlessInstanceCreateWithoutDefaultAiBotInput,
          PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput
        >
      | PaperlessInstanceCreateWithoutDefaultAiBotInput[]
      | PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput[];
    connectOrCreate?:
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput
      | PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput[];
    upsert?:
      | PaperlessInstanceUpsertWithWhereUniqueWithoutDefaultAiBotInput
      | PaperlessInstanceUpsertWithWhereUniqueWithoutDefaultAiBotInput[];
    createMany?: PaperlessInstanceCreateManyDefaultAiBotInputEnvelope;
    set?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    disconnect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    delete?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    connect?: PaperlessInstanceWhereUniqueInput | PaperlessInstanceWhereUniqueInput[];
    update?:
      | PaperlessInstanceUpdateWithWhereUniqueWithoutDefaultAiBotInput
      | PaperlessInstanceUpdateWithWhereUniqueWithoutDefaultAiBotInput[];
    updateMany?:
      | PaperlessInstanceUpdateManyWithWhereWithoutDefaultAiBotInput
      | PaperlessInstanceUpdateManyWithWhereWithoutDefaultAiBotInput[];
    deleteMany?: PaperlessInstanceScalarWhereInput | PaperlessInstanceScalarWhereInput[];
  };

  export type ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput = {
    create?:
      | XOR<ProcessingQueueCreateWithoutAiBotInput, ProcessingQueueUncheckedCreateWithoutAiBotInput>
      | ProcessingQueueCreateWithoutAiBotInput[]
      | ProcessingQueueUncheckedCreateWithoutAiBotInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutAiBotInput
      | ProcessingQueueCreateOrConnectWithoutAiBotInput[];
    upsert?:
      | ProcessingQueueUpsertWithWhereUniqueWithoutAiBotInput
      | ProcessingQueueUpsertWithWhereUniqueWithoutAiBotInput[];
    createMany?: ProcessingQueueCreateManyAiBotInputEnvelope;
    set?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    disconnect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    delete?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    update?:
      | ProcessingQueueUpdateWithWhereUniqueWithoutAiBotInput
      | ProcessingQueueUpdateWithWhereUniqueWithoutAiBotInput[];
    updateMany?:
      | ProcessingQueueUpdateManyWithWhereWithoutAiBotInput
      | ProcessingQueueUpdateManyWithWhereWithoutAiBotInput[];
    deleteMany?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
  };

  export type PaperlessDocumentCreatetagIdsInput = {
    set: number[];
  };

  export type PaperlessInstanceCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutDocumentsInput,
      PaperlessInstanceUncheckedCreateWithoutDocumentsInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutDocumentsInput;
    connect?: PaperlessInstanceWhereUniqueInput;
  };

  export type DocumentProcessingResultCreateNestedManyWithoutDocumentInput = {
    create?:
      | XOR<
          DocumentProcessingResultCreateWithoutDocumentInput,
          DocumentProcessingResultUncheckedCreateWithoutDocumentInput
        >
      | DocumentProcessingResultCreateWithoutDocumentInput[]
      | DocumentProcessingResultUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput[];
    createMany?: DocumentProcessingResultCreateManyDocumentInputEnvelope;
    connect?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
  };

  export type ProcessingQueueCreateNestedManyWithoutDocumentInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutDocumentInput,
          ProcessingQueueUncheckedCreateWithoutDocumentInput
        >
      | ProcessingQueueCreateWithoutDocumentInput[]
      | ProcessingQueueUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutDocumentInput
      | ProcessingQueueCreateOrConnectWithoutDocumentInput[];
    createMany?: ProcessingQueueCreateManyDocumentInputEnvelope;
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
  };

  export type DocumentProcessingResultUncheckedCreateNestedManyWithoutDocumentInput = {
    create?:
      | XOR<
          DocumentProcessingResultCreateWithoutDocumentInput,
          DocumentProcessingResultUncheckedCreateWithoutDocumentInput
        >
      | DocumentProcessingResultCreateWithoutDocumentInput[]
      | DocumentProcessingResultUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput[];
    createMany?: DocumentProcessingResultCreateManyDocumentInputEnvelope;
    connect?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
  };

  export type ProcessingQueueUncheckedCreateNestedManyWithoutDocumentInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutDocumentInput,
          ProcessingQueueUncheckedCreateWithoutDocumentInput
        >
      | ProcessingQueueCreateWithoutDocumentInput[]
      | ProcessingQueueUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutDocumentInput
      | ProcessingQueueCreateOrConnectWithoutDocumentInput[];
    createMany?: ProcessingQueueCreateManyDocumentInputEnvelope;
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type PaperlessDocumentUpdatetagIdsInput = {
    set?: number[];
    push?: number | number[];
  };

  export type PaperlessInstanceUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutDocumentsInput,
      PaperlessInstanceUncheckedCreateWithoutDocumentsInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutDocumentsInput;
    upsert?: PaperlessInstanceUpsertWithoutDocumentsInput;
    connect?: PaperlessInstanceWhereUniqueInput;
    update?: XOR<
      XOR<
        PaperlessInstanceUpdateToOneWithWhereWithoutDocumentsInput,
        PaperlessInstanceUpdateWithoutDocumentsInput
      >,
      PaperlessInstanceUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type DocumentProcessingResultUpdateManyWithoutDocumentNestedInput = {
    create?:
      | XOR<
          DocumentProcessingResultCreateWithoutDocumentInput,
          DocumentProcessingResultUncheckedCreateWithoutDocumentInput
        >
      | DocumentProcessingResultCreateWithoutDocumentInput[]
      | DocumentProcessingResultUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput[];
    upsert?:
      | DocumentProcessingResultUpsertWithWhereUniqueWithoutDocumentInput
      | DocumentProcessingResultUpsertWithWhereUniqueWithoutDocumentInput[];
    createMany?: DocumentProcessingResultCreateManyDocumentInputEnvelope;
    set?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
    disconnect?:
      | DocumentProcessingResultWhereUniqueInput
      | DocumentProcessingResultWhereUniqueInput[];
    delete?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
    connect?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
    update?:
      | DocumentProcessingResultUpdateWithWhereUniqueWithoutDocumentInput
      | DocumentProcessingResultUpdateWithWhereUniqueWithoutDocumentInput[];
    updateMany?:
      | DocumentProcessingResultUpdateManyWithWhereWithoutDocumentInput
      | DocumentProcessingResultUpdateManyWithWhereWithoutDocumentInput[];
    deleteMany?:
      | DocumentProcessingResultScalarWhereInput
      | DocumentProcessingResultScalarWhereInput[];
  };

  export type ProcessingQueueUpdateManyWithoutDocumentNestedInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutDocumentInput,
          ProcessingQueueUncheckedCreateWithoutDocumentInput
        >
      | ProcessingQueueCreateWithoutDocumentInput[]
      | ProcessingQueueUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutDocumentInput
      | ProcessingQueueCreateOrConnectWithoutDocumentInput[];
    upsert?:
      | ProcessingQueueUpsertWithWhereUniqueWithoutDocumentInput
      | ProcessingQueueUpsertWithWhereUniqueWithoutDocumentInput[];
    createMany?: ProcessingQueueCreateManyDocumentInputEnvelope;
    set?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    disconnect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    delete?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    update?:
      | ProcessingQueueUpdateWithWhereUniqueWithoutDocumentInput
      | ProcessingQueueUpdateWithWhereUniqueWithoutDocumentInput[];
    updateMany?:
      | ProcessingQueueUpdateManyWithWhereWithoutDocumentInput
      | ProcessingQueueUpdateManyWithWhereWithoutDocumentInput[];
    deleteMany?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
  };

  export type DocumentProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?:
      | XOR<
          DocumentProcessingResultCreateWithoutDocumentInput,
          DocumentProcessingResultUncheckedCreateWithoutDocumentInput
        >
      | DocumentProcessingResultCreateWithoutDocumentInput[]
      | DocumentProcessingResultUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput
      | DocumentProcessingResultCreateOrConnectWithoutDocumentInput[];
    upsert?:
      | DocumentProcessingResultUpsertWithWhereUniqueWithoutDocumentInput
      | DocumentProcessingResultUpsertWithWhereUniqueWithoutDocumentInput[];
    createMany?: DocumentProcessingResultCreateManyDocumentInputEnvelope;
    set?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
    disconnect?:
      | DocumentProcessingResultWhereUniqueInput
      | DocumentProcessingResultWhereUniqueInput[];
    delete?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
    connect?: DocumentProcessingResultWhereUniqueInput | DocumentProcessingResultWhereUniqueInput[];
    update?:
      | DocumentProcessingResultUpdateWithWhereUniqueWithoutDocumentInput
      | DocumentProcessingResultUpdateWithWhereUniqueWithoutDocumentInput[];
    updateMany?:
      | DocumentProcessingResultUpdateManyWithWhereWithoutDocumentInput
      | DocumentProcessingResultUpdateManyWithWhereWithoutDocumentInput[];
    deleteMany?:
      | DocumentProcessingResultScalarWhereInput
      | DocumentProcessingResultScalarWhereInput[];
  };

  export type ProcessingQueueUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?:
      | XOR<
          ProcessingQueueCreateWithoutDocumentInput,
          ProcessingQueueUncheckedCreateWithoutDocumentInput
        >
      | ProcessingQueueCreateWithoutDocumentInput[]
      | ProcessingQueueUncheckedCreateWithoutDocumentInput[];
    connectOrCreate?:
      | ProcessingQueueCreateOrConnectWithoutDocumentInput
      | ProcessingQueueCreateOrConnectWithoutDocumentInput[];
    upsert?:
      | ProcessingQueueUpsertWithWhereUniqueWithoutDocumentInput
      | ProcessingQueueUpsertWithWhereUniqueWithoutDocumentInput[];
    createMany?: ProcessingQueueCreateManyDocumentInputEnvelope;
    set?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    disconnect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    delete?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    connect?: ProcessingQueueWhereUniqueInput | ProcessingQueueWhereUniqueInput[];
    update?:
      | ProcessingQueueUpdateWithWhereUniqueWithoutDocumentInput
      | ProcessingQueueUpdateWithWhereUniqueWithoutDocumentInput[];
    updateMany?:
      | ProcessingQueueUpdateManyWithWhereWithoutDocumentInput
      | ProcessingQueueUpdateManyWithWhereWithoutDocumentInput[];
    deleteMany?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
  };

  export type DocumentProcessingResultCreateoriginalTagsInput = {
    set: string[];
  };

  export type PaperlessDocumentCreateNestedOneWithoutProcessingResultsInput = {
    create?: XOR<
      PaperlessDocumentCreateWithoutProcessingResultsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingResultsInput
    >;
    connectOrCreate?: PaperlessDocumentCreateOrConnectWithoutProcessingResultsInput;
    connect?: PaperlessDocumentWhereUniqueInput;
  };

  export type DocumentProcessingResultUpdateoriginalTagsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type PaperlessDocumentUpdateOneRequiredWithoutProcessingResultsNestedInput = {
    create?: XOR<
      PaperlessDocumentCreateWithoutProcessingResultsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingResultsInput
    >;
    connectOrCreate?: PaperlessDocumentCreateOrConnectWithoutProcessingResultsInput;
    upsert?: PaperlessDocumentUpsertWithoutProcessingResultsInput;
    connect?: PaperlessDocumentWhereUniqueInput;
    update?: XOR<
      XOR<
        PaperlessDocumentUpdateToOneWithWhereWithoutProcessingResultsInput,
        PaperlessDocumentUpdateWithoutProcessingResultsInput
      >,
      PaperlessDocumentUncheckedUpdateWithoutProcessingResultsInput
    >;
  };

  export type PaperlessInstanceCreateNestedOneWithoutProcessingQueueInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutProcessingQueueInput,
      PaperlessInstanceUncheckedCreateWithoutProcessingQueueInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutProcessingQueueInput;
    connect?: PaperlessInstanceWhereUniqueInput;
  };

  export type PaperlessDocumentCreateNestedOneWithoutProcessingQueueItemsInput = {
    create?: XOR<
      PaperlessDocumentCreateWithoutProcessingQueueItemsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingQueueItemsInput
    >;
    connectOrCreate?: PaperlessDocumentCreateOrConnectWithoutProcessingQueueItemsInput;
    connect?: PaperlessDocumentWhereUniqueInput;
  };

  export type AiBotCreateNestedOneWithoutProcessingQueueItemsInput = {
    create?: XOR<
      AiBotCreateWithoutProcessingQueueItemsInput,
      AiBotUncheckedCreateWithoutProcessingQueueItemsInput
    >;
    connectOrCreate?: AiBotCreateOrConnectWithoutProcessingQueueItemsInput;
    connect?: AiBotWhereUniqueInput;
  };

  export type PaperlessInstanceUpdateOneRequiredWithoutProcessingQueueNestedInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutProcessingQueueInput,
      PaperlessInstanceUncheckedCreateWithoutProcessingQueueInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutProcessingQueueInput;
    upsert?: PaperlessInstanceUpsertWithoutProcessingQueueInput;
    connect?: PaperlessInstanceWhereUniqueInput;
    update?: XOR<
      XOR<
        PaperlessInstanceUpdateToOneWithWhereWithoutProcessingQueueInput,
        PaperlessInstanceUpdateWithoutProcessingQueueInput
      >,
      PaperlessInstanceUncheckedUpdateWithoutProcessingQueueInput
    >;
  };

  export type PaperlessDocumentUpdateOneWithoutProcessingQueueItemsNestedInput = {
    create?: XOR<
      PaperlessDocumentCreateWithoutProcessingQueueItemsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingQueueItemsInput
    >;
    connectOrCreate?: PaperlessDocumentCreateOrConnectWithoutProcessingQueueItemsInput;
    upsert?: PaperlessDocumentUpsertWithoutProcessingQueueItemsInput;
    disconnect?: PaperlessDocumentWhereInput | boolean;
    delete?: PaperlessDocumentWhereInput | boolean;
    connect?: PaperlessDocumentWhereUniqueInput;
    update?: XOR<
      XOR<
        PaperlessDocumentUpdateToOneWithWhereWithoutProcessingQueueItemsInput,
        PaperlessDocumentUpdateWithoutProcessingQueueItemsInput
      >,
      PaperlessDocumentUncheckedUpdateWithoutProcessingQueueItemsInput
    >;
  };

  export type AiBotUpdateOneWithoutProcessingQueueItemsNestedInput = {
    create?: XOR<
      AiBotCreateWithoutProcessingQueueItemsInput,
      AiBotUncheckedCreateWithoutProcessingQueueItemsInput
    >;
    connectOrCreate?: AiBotCreateOrConnectWithoutProcessingQueueItemsInput;
    upsert?: AiBotUpsertWithoutProcessingQueueItemsInput;
    disconnect?: AiBotWhereInput | boolean;
    delete?: AiBotWhereInput | boolean;
    connect?: AiBotWhereUniqueInput;
    update?: XOR<
      XOR<
        AiBotUpdateToOneWithWhereWithoutProcessingQueueItemsInput,
        AiBotUpdateWithoutProcessingQueueItemsInput
      >,
      AiBotUncheckedUpdateWithoutProcessingQueueItemsInput
    >;
  };

  export type PaperlessInstanceCreateNestedOneWithoutImportHistoryInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutImportHistoryInput,
      PaperlessInstanceUncheckedCreateWithoutImportHistoryInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutImportHistoryInput;
    connect?: PaperlessInstanceWhereUniqueInput;
  };

  export type PaperlessInstanceUpdateOneRequiredWithoutImportHistoryNestedInput = {
    create?: XOR<
      PaperlessInstanceCreateWithoutImportHistoryInput,
      PaperlessInstanceUncheckedCreateWithoutImportHistoryInput
    >;
    connectOrCreate?: PaperlessInstanceCreateOrConnectWithoutImportHistoryInput;
    upsert?: PaperlessInstanceUpsertWithoutImportHistoryInput;
    connect?: PaperlessInstanceWhereUniqueInput;
    update?: XOR<
      XOR<
        PaperlessInstanceUpdateToOneWithWhereWithoutImportHistoryInput,
        PaperlessInstanceUpdateWithoutImportHistoryInput
      >,
      PaperlessInstanceUncheckedUpdateWithoutImportHistoryInput
    >;
  };

  export type UserCreateNestedOneWithoutAiUsageMetricsInput = {
    create?: XOR<
      UserCreateWithoutAiUsageMetricsInput,
      UserUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAiUsageMetricsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AiAccountCreateNestedOneWithoutAiUsageMetricsInput = {
    create?: XOR<
      AiAccountCreateWithoutAiUsageMetricsInput,
      AiAccountUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: AiAccountCreateOrConnectWithoutAiUsageMetricsInput;
    connect?: AiAccountWhereUniqueInput;
  };

  export type AiModelCreateNestedOneWithoutAiUsageMetricsInput = {
    create?: XOR<
      AiModelCreateWithoutAiUsageMetricsInput,
      AiModelUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: AiModelCreateOrConnectWithoutAiUsageMetricsInput;
    connect?: AiModelWhereUniqueInput;
  };

  export type AiBotCreateNestedOneWithoutAiUsageMetricsInput = {
    create?: XOR<
      AiBotCreateWithoutAiUsageMetricsInput,
      AiBotUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: AiBotCreateOrConnectWithoutAiUsageMetricsInput;
    connect?: AiBotWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutAiUsageMetricsNestedInput = {
    create?: XOR<
      UserCreateWithoutAiUsageMetricsInput,
      UserUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAiUsageMetricsInput;
    upsert?: UserUpsertWithoutAiUsageMetricsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<UserUpdateToOneWithWhereWithoutAiUsageMetricsInput, UserUpdateWithoutAiUsageMetricsInput>,
      UserUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type AiAccountUpdateOneRequiredWithoutAiUsageMetricsNestedInput = {
    create?: XOR<
      AiAccountCreateWithoutAiUsageMetricsInput,
      AiAccountUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: AiAccountCreateOrConnectWithoutAiUsageMetricsInput;
    upsert?: AiAccountUpsertWithoutAiUsageMetricsInput;
    connect?: AiAccountWhereUniqueInput;
    update?: XOR<
      XOR<
        AiAccountUpdateToOneWithWhereWithoutAiUsageMetricsInput,
        AiAccountUpdateWithoutAiUsageMetricsInput
      >,
      AiAccountUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type AiModelUpdateOneWithoutAiUsageMetricsNestedInput = {
    create?: XOR<
      AiModelCreateWithoutAiUsageMetricsInput,
      AiModelUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: AiModelCreateOrConnectWithoutAiUsageMetricsInput;
    upsert?: AiModelUpsertWithoutAiUsageMetricsInput;
    disconnect?: AiModelWhereInput | boolean;
    delete?: AiModelWhereInput | boolean;
    connect?: AiModelWhereUniqueInput;
    update?: XOR<
      XOR<
        AiModelUpdateToOneWithWhereWithoutAiUsageMetricsInput,
        AiModelUpdateWithoutAiUsageMetricsInput
      >,
      AiModelUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type AiBotUpdateOneWithoutAiUsageMetricsNestedInput = {
    create?: XOR<
      AiBotCreateWithoutAiUsageMetricsInput,
      AiBotUncheckedCreateWithoutAiUsageMetricsInput
    >;
    connectOrCreate?: AiBotCreateOrConnectWithoutAiUsageMetricsInput;
    upsert?: AiBotUpsertWithoutAiUsageMetricsInput;
    disconnect?: AiBotWhereInput | boolean;
    delete?: AiBotWhereInput | boolean;
    connect?: AiBotWhereUniqueInput;
    update?: XOR<
      XOR<
        AiBotUpdateToOneWithWhereWithoutAiUsageMetricsInput,
        AiBotUpdateWithoutAiUsageMetricsInput
      >,
      AiBotUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type WebAuthnCredentialCreatetransportsInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutWebAuthnCredentialsInput = {
    create?: XOR<
      UserCreateWithoutWebAuthnCredentialsInput,
      UserUncheckedCreateWithoutWebAuthnCredentialsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutWebAuthnCredentialsInput;
    connect?: UserWhereUniqueInput;
  };

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes;
  };

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number;
    increment?: bigint | number;
    decrement?: bigint | number;
    multiply?: bigint | number;
    divide?: bigint | number;
  };

  export type WebAuthnCredentialUpdatetransportsInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutWebAuthnCredentialsNestedInput = {
    create?: XOR<
      UserCreateWithoutWebAuthnCredentialsInput,
      UserUncheckedCreateWithoutWebAuthnCredentialsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutWebAuthnCredentialsInput;
    upsert?: UserUpsertWithoutWebAuthnCredentialsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutWebAuthnCredentialsInput,
        UserUpdateWithoutWebAuthnCredentialsInput
      >,
      UserUncheckedUpdateWithoutWebAuthnCredentialsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedEnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>;
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>;
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>;
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPermissionFilter<$PrismaModel>;
    _max?: NestedEnumPermissionFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter;
  };

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>;
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    not?: NestedBytesFilter<$PrismaModel> | Bytes;
  };

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number;
  };

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>;
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>;
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBytesFilter<$PrismaModel>;
    _max?: NestedBytesFilter<$PrismaModel>;
  };

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>;
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>;
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedBigIntFilter<$PrismaModel>;
    _min?: NestedBigIntFilter<$PrismaModel>;
    _max?: NestedBigIntFilter<$PrismaModel>;
  };

  export type PaperlessInstanceCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    defaultAiBot?: AiBotCreateNestedOneWithoutDefaultForInstancesInput;
    sharedWith?: UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    sharedWith?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceCreateOrConnectWithoutOwnerInput = {
    where: PaperlessInstanceWhereUniqueInput;
    create: XOR<
      PaperlessInstanceCreateWithoutOwnerInput,
      PaperlessInstanceUncheckedCreateWithoutOwnerInput
    >;
  };

  export type PaperlessInstanceCreateManyOwnerInputEnvelope = {
    data: PaperlessInstanceCreateManyOwnerInput | PaperlessInstanceCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type AiAccountCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    sharedWith?: UserAiAccountAccessCreateNestedManyWithoutAiAccountInput;
    models?: AiModelCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountUncheckedCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    sharedWith?: UserAiAccountAccessUncheckedCreateNestedManyWithoutAiAccountInput;
    models?: AiModelUncheckedCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountCreateOrConnectWithoutOwnerInput = {
    where: AiAccountWhereUniqueInput;
    create: XOR<AiAccountCreateWithoutOwnerInput, AiAccountUncheckedCreateWithoutOwnerInput>;
  };

  export type AiAccountCreateManyOwnerInputEnvelope = {
    data: AiAccountCreateManyOwnerInput | AiAccountCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type AiModelCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiAccount: AiAccountCreateNestedOneWithoutModelsInput;
    sharedWith?: UserAiModelAccessCreateNestedManyWithoutAiModelInput;
    bots?: AiBotCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUncheckedCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiAccountId: string;
    sharedWith?: UserAiModelAccessUncheckedCreateNestedManyWithoutAiModelInput;
    bots?: AiBotUncheckedCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelCreateOrConnectWithoutOwnerInput = {
    where: AiModelWhereUniqueInput;
    create: XOR<AiModelCreateWithoutOwnerInput, AiModelUncheckedCreateWithoutOwnerInput>;
  };

  export type AiModelCreateManyOwnerInputEnvelope = {
    data: AiModelCreateManyOwnerInput | AiModelCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type AiBotCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiModel: AiModelCreateNestedOneWithoutBotsInput;
    sharedWith?: UserAiBotAccessCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUncheckedCreateWithoutOwnerInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiModelId: string;
    sharedWith?: UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotCreateOrConnectWithoutOwnerInput = {
    where: AiBotWhereUniqueInput;
    create: XOR<AiBotCreateWithoutOwnerInput, AiBotUncheckedCreateWithoutOwnerInput>;
  };

  export type AiBotCreateManyOwnerInputEnvelope = {
    data: AiBotCreateManyOwnerInput | AiBotCreateManyOwnerInput[];
    skipDuplicates?: boolean;
  };

  export type UserPaperlessInstanceAccessCreateWithoutUserInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    instance: PaperlessInstanceCreateNestedOneWithoutSharedWithInput;
  };

  export type UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput = {
    id?: string;
    instanceId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserPaperlessInstanceAccessCreateOrConnectWithoutUserInput = {
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    create: XOR<
      UserPaperlessInstanceAccessCreateWithoutUserInput,
      UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserPaperlessInstanceAccessCreateManyUserInputEnvelope = {
    data:
      | UserPaperlessInstanceAccessCreateManyUserInput
      | UserPaperlessInstanceAccessCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserAiAccountAccessCreateWithoutUserInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    aiAccount: AiAccountCreateNestedOneWithoutSharedWithInput;
  };

  export type UserAiAccountAccessUncheckedCreateWithoutUserInput = {
    id?: string;
    aiAccountId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiAccountAccessCreateOrConnectWithoutUserInput = {
    where: UserAiAccountAccessWhereUniqueInput;
    create: XOR<
      UserAiAccountAccessCreateWithoutUserInput,
      UserAiAccountAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserAiAccountAccessCreateManyUserInputEnvelope = {
    data: UserAiAccountAccessCreateManyUserInput | UserAiAccountAccessCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserAiModelAccessCreateWithoutUserInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    aiModel: AiModelCreateNestedOneWithoutSharedWithInput;
  };

  export type UserAiModelAccessUncheckedCreateWithoutUserInput = {
    id?: string;
    aiModelId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiModelAccessCreateOrConnectWithoutUserInput = {
    where: UserAiModelAccessWhereUniqueInput;
    create: XOR<
      UserAiModelAccessCreateWithoutUserInput,
      UserAiModelAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserAiModelAccessCreateManyUserInputEnvelope = {
    data: UserAiModelAccessCreateManyUserInput | UserAiModelAccessCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserAiBotAccessCreateWithoutUserInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    aiBot: AiBotCreateNestedOneWithoutSharedWithInput;
  };

  export type UserAiBotAccessUncheckedCreateWithoutUserInput = {
    id?: string;
    aiBotId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiBotAccessCreateOrConnectWithoutUserInput = {
    where: UserAiBotAccessWhereUniqueInput;
    create: XOR<
      UserAiBotAccessCreateWithoutUserInput,
      UserAiBotAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserAiBotAccessCreateManyUserInputEnvelope = {
    data: UserAiBotAccessCreateManyUserInput | UserAiBotAccessCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AiUsageMetricCreateWithoutUserInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    aiAccount: AiAccountCreateNestedOneWithoutAiUsageMetricsInput;
    aiModel?: AiModelCreateNestedOneWithoutAiUsageMetricsInput;
    aiBot?: AiBotCreateNestedOneWithoutAiUsageMetricsInput;
  };

  export type AiUsageMetricUncheckedCreateWithoutUserInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    aiAccountId: string;
    aiModelId?: string | null;
    aiBotId?: string | null;
  };

  export type AiUsageMetricCreateOrConnectWithoutUserInput = {
    where: AiUsageMetricWhereUniqueInput;
    create: XOR<AiUsageMetricCreateWithoutUserInput, AiUsageMetricUncheckedCreateWithoutUserInput>;
  };

  export type AiUsageMetricCreateManyUserInputEnvelope = {
    data: AiUsageMetricCreateManyUserInput | AiUsageMetricCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type WebAuthnCredentialCreateWithoutUserInput = {
    id?: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter?: bigint | number;
    deviceType?: string;
    backedUp?: boolean;
    transports?: WebAuthnCredentialCreatetransportsInput | string[];
    name?: string | null;
    createdAt?: Date | string;
    lastUsedAt?: Date | string | null;
  };

  export type WebAuthnCredentialUncheckedCreateWithoutUserInput = {
    id?: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter?: bigint | number;
    deviceType?: string;
    backedUp?: boolean;
    transports?: WebAuthnCredentialCreatetransportsInput | string[];
    name?: string | null;
    createdAt?: Date | string;
    lastUsedAt?: Date | string | null;
  };

  export type WebAuthnCredentialCreateOrConnectWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput;
    create: XOR<
      WebAuthnCredentialCreateWithoutUserInput,
      WebAuthnCredentialUncheckedCreateWithoutUserInput
    >;
  };

  export type WebAuthnCredentialCreateManyUserInputEnvelope = {
    data: WebAuthnCredentialCreateManyUserInput | WebAuthnCredentialCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type PaperlessInstanceUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PaperlessInstanceWhereUniqueInput;
    update: XOR<
      PaperlessInstanceUpdateWithoutOwnerInput,
      PaperlessInstanceUncheckedUpdateWithoutOwnerInput
    >;
    create: XOR<
      PaperlessInstanceCreateWithoutOwnerInput,
      PaperlessInstanceUncheckedCreateWithoutOwnerInput
    >;
  };

  export type PaperlessInstanceUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PaperlessInstanceWhereUniqueInput;
    data: XOR<
      PaperlessInstanceUpdateWithoutOwnerInput,
      PaperlessInstanceUncheckedUpdateWithoutOwnerInput
    >;
  };

  export type PaperlessInstanceUpdateManyWithWhereWithoutOwnerInput = {
    where: PaperlessInstanceScalarWhereInput;
    data: XOR<
      PaperlessInstanceUpdateManyMutationInput,
      PaperlessInstanceUncheckedUpdateManyWithoutOwnerInput
    >;
  };

  export type PaperlessInstanceScalarWhereInput = {
    AND?: PaperlessInstanceScalarWhereInput | PaperlessInstanceScalarWhereInput[];
    OR?: PaperlessInstanceScalarWhereInput[];
    NOT?: PaperlessInstanceScalarWhereInput | PaperlessInstanceScalarWhereInput[];
    id?: StringFilter<'PaperlessInstance'> | string;
    name?: StringFilter<'PaperlessInstance'> | string;
    apiUrl?: StringFilter<'PaperlessInstance'> | string;
    apiToken?: StringFilter<'PaperlessInstance'> | string;
    importFilterTags?: IntNullableListFilter<'PaperlessInstance'>;
    createdAt?: DateTimeFilter<'PaperlessInstance'> | Date | string;
    updatedAt?: DateTimeFilter<'PaperlessInstance'> | Date | string;
    autoProcessEnabled?: BoolFilter<'PaperlessInstance'> | boolean;
    scanCronExpression?: StringFilter<'PaperlessInstance'> | string;
    lastScanAt?: DateTimeNullableFilter<'PaperlessInstance'> | Date | string | null;
    nextScanAt?: DateTimeNullableFilter<'PaperlessInstance'> | Date | string | null;
    defaultAiBotId?: StringNullableFilter<'PaperlessInstance'> | string | null;
    autoApplyTitle?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyCorrespondent?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyDocumentType?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyTags?: BoolFilter<'PaperlessInstance'> | boolean;
    autoApplyDate?: BoolFilter<'PaperlessInstance'> | boolean;
    ownerId?: StringFilter<'PaperlessInstance'> | string;
  };

  export type AiAccountUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AiAccountWhereUniqueInput;
    update: XOR<AiAccountUpdateWithoutOwnerInput, AiAccountUncheckedUpdateWithoutOwnerInput>;
    create: XOR<AiAccountCreateWithoutOwnerInput, AiAccountUncheckedCreateWithoutOwnerInput>;
  };

  export type AiAccountUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AiAccountWhereUniqueInput;
    data: XOR<AiAccountUpdateWithoutOwnerInput, AiAccountUncheckedUpdateWithoutOwnerInput>;
  };

  export type AiAccountUpdateManyWithWhereWithoutOwnerInput = {
    where: AiAccountScalarWhereInput;
    data: XOR<AiAccountUpdateManyMutationInput, AiAccountUncheckedUpdateManyWithoutOwnerInput>;
  };

  export type AiAccountScalarWhereInput = {
    AND?: AiAccountScalarWhereInput | AiAccountScalarWhereInput[];
    OR?: AiAccountScalarWhereInput[];
    NOT?: AiAccountScalarWhereInput | AiAccountScalarWhereInput[];
    id?: StringFilter<'AiAccount'> | string;
    name?: StringFilter<'AiAccount'> | string;
    provider?: StringFilter<'AiAccount'> | string;
    apiKey?: StringFilter<'AiAccount'> | string;
    baseUrl?: StringNullableFilter<'AiAccount'> | string | null;
    isActive?: BoolFilter<'AiAccount'> | boolean;
    createdAt?: DateTimeFilter<'AiAccount'> | Date | string;
    updatedAt?: DateTimeFilter<'AiAccount'> | Date | string;
    ownerId?: StringFilter<'AiAccount'> | string;
  };

  export type AiModelUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AiModelWhereUniqueInput;
    update: XOR<AiModelUpdateWithoutOwnerInput, AiModelUncheckedUpdateWithoutOwnerInput>;
    create: XOR<AiModelCreateWithoutOwnerInput, AiModelUncheckedCreateWithoutOwnerInput>;
  };

  export type AiModelUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AiModelWhereUniqueInput;
    data: XOR<AiModelUpdateWithoutOwnerInput, AiModelUncheckedUpdateWithoutOwnerInput>;
  };

  export type AiModelUpdateManyWithWhereWithoutOwnerInput = {
    where: AiModelScalarWhereInput;
    data: XOR<AiModelUpdateManyMutationInput, AiModelUncheckedUpdateManyWithoutOwnerInput>;
  };

  export type AiModelScalarWhereInput = {
    AND?: AiModelScalarWhereInput | AiModelScalarWhereInput[];
    OR?: AiModelScalarWhereInput[];
    NOT?: AiModelScalarWhereInput | AiModelScalarWhereInput[];
    id?: StringFilter<'AiModel'> | string;
    name?: StringFilter<'AiModel'> | string;
    modelIdentifier?: StringFilter<'AiModel'> | string;
    inputTokenPrice?: FloatNullableFilter<'AiModel'> | number | null;
    outputTokenPrice?: FloatNullableFilter<'AiModel'> | number | null;
    isActive?: BoolFilter<'AiModel'> | boolean;
    createdAt?: DateTimeFilter<'AiModel'> | Date | string;
    updatedAt?: DateTimeFilter<'AiModel'> | Date | string;
    ownerId?: StringFilter<'AiModel'> | string;
    aiAccountId?: StringFilter<'AiModel'> | string;
  };

  export type AiBotUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AiBotWhereUniqueInput;
    update: XOR<AiBotUpdateWithoutOwnerInput, AiBotUncheckedUpdateWithoutOwnerInput>;
    create: XOR<AiBotCreateWithoutOwnerInput, AiBotUncheckedCreateWithoutOwnerInput>;
  };

  export type AiBotUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AiBotWhereUniqueInput;
    data: XOR<AiBotUpdateWithoutOwnerInput, AiBotUncheckedUpdateWithoutOwnerInput>;
  };

  export type AiBotUpdateManyWithWhereWithoutOwnerInput = {
    where: AiBotScalarWhereInput;
    data: XOR<AiBotUpdateManyMutationInput, AiBotUncheckedUpdateManyWithoutOwnerInput>;
  };

  export type AiBotScalarWhereInput = {
    AND?: AiBotScalarWhereInput | AiBotScalarWhereInput[];
    OR?: AiBotScalarWhereInput[];
    NOT?: AiBotScalarWhereInput | AiBotScalarWhereInput[];
    id?: StringFilter<'AiBot'> | string;
    name?: StringFilter<'AiBot'> | string;
    systemPrompt?: StringFilter<'AiBot'> | string;
    responseLanguage?: StringFilter<'AiBot'> | string;
    createdAt?: DateTimeFilter<'AiBot'> | Date | string;
    updatedAt?: DateTimeFilter<'AiBot'> | Date | string;
    ownerId?: StringFilter<'AiBot'> | string;
    aiModelId?: StringFilter<'AiBot'> | string;
  };

  export type UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    update: XOR<
      UserPaperlessInstanceAccessUpdateWithoutUserInput,
      UserPaperlessInstanceAccessUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserPaperlessInstanceAccessCreateWithoutUserInput,
      UserPaperlessInstanceAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    data: XOR<
      UserPaperlessInstanceAccessUpdateWithoutUserInput,
      UserPaperlessInstanceAccessUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserPaperlessInstanceAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserPaperlessInstanceAccessScalarWhereInput;
    data: XOR<
      UserPaperlessInstanceAccessUpdateManyMutationInput,
      UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserPaperlessInstanceAccessScalarWhereInput = {
    AND?:
      | UserPaperlessInstanceAccessScalarWhereInput
      | UserPaperlessInstanceAccessScalarWhereInput[];
    OR?: UserPaperlessInstanceAccessScalarWhereInput[];
    NOT?:
      | UserPaperlessInstanceAccessScalarWhereInput
      | UserPaperlessInstanceAccessScalarWhereInput[];
    id?: StringFilter<'UserPaperlessInstanceAccess'> | string;
    userId?: StringNullableFilter<'UserPaperlessInstanceAccess'> | string | null;
    instanceId?: StringFilter<'UserPaperlessInstanceAccess'> | string;
    permission?: EnumPermissionFilter<'UserPaperlessInstanceAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserPaperlessInstanceAccess'> | Date | string;
  };

  export type UserAiAccountAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAiAccountAccessWhereUniqueInput;
    update: XOR<
      UserAiAccountAccessUpdateWithoutUserInput,
      UserAiAccountAccessUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserAiAccountAccessCreateWithoutUserInput,
      UserAiAccountAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserAiAccountAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAiAccountAccessWhereUniqueInput;
    data: XOR<
      UserAiAccountAccessUpdateWithoutUserInput,
      UserAiAccountAccessUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserAiAccountAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserAiAccountAccessScalarWhereInput;
    data: XOR<
      UserAiAccountAccessUpdateManyMutationInput,
      UserAiAccountAccessUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserAiAccountAccessScalarWhereInput = {
    AND?: UserAiAccountAccessScalarWhereInput | UserAiAccountAccessScalarWhereInput[];
    OR?: UserAiAccountAccessScalarWhereInput[];
    NOT?: UserAiAccountAccessScalarWhereInput | UserAiAccountAccessScalarWhereInput[];
    id?: StringFilter<'UserAiAccountAccess'> | string;
    userId?: StringNullableFilter<'UserAiAccountAccess'> | string | null;
    aiAccountId?: StringFilter<'UserAiAccountAccess'> | string;
    permission?: EnumPermissionFilter<'UserAiAccountAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserAiAccountAccess'> | Date | string;
  };

  export type UserAiModelAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAiModelAccessWhereUniqueInput;
    update: XOR<
      UserAiModelAccessUpdateWithoutUserInput,
      UserAiModelAccessUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserAiModelAccessCreateWithoutUserInput,
      UserAiModelAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserAiModelAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAiModelAccessWhereUniqueInput;
    data: XOR<
      UserAiModelAccessUpdateWithoutUserInput,
      UserAiModelAccessUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserAiModelAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserAiModelAccessScalarWhereInput;
    data: XOR<
      UserAiModelAccessUpdateManyMutationInput,
      UserAiModelAccessUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserAiModelAccessScalarWhereInput = {
    AND?: UserAiModelAccessScalarWhereInput | UserAiModelAccessScalarWhereInput[];
    OR?: UserAiModelAccessScalarWhereInput[];
    NOT?: UserAiModelAccessScalarWhereInput | UserAiModelAccessScalarWhereInput[];
    id?: StringFilter<'UserAiModelAccess'> | string;
    userId?: StringNullableFilter<'UserAiModelAccess'> | string | null;
    aiModelId?: StringFilter<'UserAiModelAccess'> | string;
    permission?: EnumPermissionFilter<'UserAiModelAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserAiModelAccess'> | Date | string;
  };

  export type UserAiBotAccessUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAiBotAccessWhereUniqueInput;
    update: XOR<
      UserAiBotAccessUpdateWithoutUserInput,
      UserAiBotAccessUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserAiBotAccessCreateWithoutUserInput,
      UserAiBotAccessUncheckedCreateWithoutUserInput
    >;
  };

  export type UserAiBotAccessUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAiBotAccessWhereUniqueInput;
    data: XOR<
      UserAiBotAccessUpdateWithoutUserInput,
      UserAiBotAccessUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserAiBotAccessUpdateManyWithWhereWithoutUserInput = {
    where: UserAiBotAccessScalarWhereInput;
    data: XOR<
      UserAiBotAccessUpdateManyMutationInput,
      UserAiBotAccessUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserAiBotAccessScalarWhereInput = {
    AND?: UserAiBotAccessScalarWhereInput | UserAiBotAccessScalarWhereInput[];
    OR?: UserAiBotAccessScalarWhereInput[];
    NOT?: UserAiBotAccessScalarWhereInput | UserAiBotAccessScalarWhereInput[];
    id?: StringFilter<'UserAiBotAccess'> | string;
    userId?: StringNullableFilter<'UserAiBotAccess'> | string | null;
    aiBotId?: StringFilter<'UserAiBotAccess'> | string;
    permission?: EnumPermissionFilter<'UserAiBotAccess'> | $Enums.Permission;
    createdAt?: DateTimeFilter<'UserAiBotAccess'> | Date | string;
  };

  export type AiUsageMetricUpsertWithWhereUniqueWithoutUserInput = {
    where: AiUsageMetricWhereUniqueInput;
    update: XOR<AiUsageMetricUpdateWithoutUserInput, AiUsageMetricUncheckedUpdateWithoutUserInput>;
    create: XOR<AiUsageMetricCreateWithoutUserInput, AiUsageMetricUncheckedCreateWithoutUserInput>;
  };

  export type AiUsageMetricUpdateWithWhereUniqueWithoutUserInput = {
    where: AiUsageMetricWhereUniqueInput;
    data: XOR<AiUsageMetricUpdateWithoutUserInput, AiUsageMetricUncheckedUpdateWithoutUserInput>;
  };

  export type AiUsageMetricUpdateManyWithWhereWithoutUserInput = {
    where: AiUsageMetricScalarWhereInput;
    data: XOR<
      AiUsageMetricUpdateManyMutationInput,
      AiUsageMetricUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AiUsageMetricScalarWhereInput = {
    AND?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
    OR?: AiUsageMetricScalarWhereInput[];
    NOT?: AiUsageMetricScalarWhereInput | AiUsageMetricScalarWhereInput[];
    id?: StringFilter<'AiUsageMetric'> | string;
    provider?: StringFilter<'AiUsageMetric'> | string;
    model?: StringFilter<'AiUsageMetric'> | string;
    promptTokens?: IntFilter<'AiUsageMetric'> | number;
    completionTokens?: IntFilter<'AiUsageMetric'> | number;
    totalTokens?: IntFilter<'AiUsageMetric'> | number;
    estimatedCost?: FloatNullableFilter<'AiUsageMetric'> | number | null;
    documentId?: IntNullableFilter<'AiUsageMetric'> | number | null;
    createdAt?: DateTimeFilter<'AiUsageMetric'> | Date | string;
    userId?: StringFilter<'AiUsageMetric'> | string;
    aiAccountId?: StringFilter<'AiUsageMetric'> | string;
    aiModelId?: StringNullableFilter<'AiUsageMetric'> | string | null;
    aiBotId?: StringNullableFilter<'AiUsageMetric'> | string | null;
  };

  export type WebAuthnCredentialUpsertWithWhereUniqueWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput;
    update: XOR<
      WebAuthnCredentialUpdateWithoutUserInput,
      WebAuthnCredentialUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      WebAuthnCredentialCreateWithoutUserInput,
      WebAuthnCredentialUncheckedCreateWithoutUserInput
    >;
  };

  export type WebAuthnCredentialUpdateWithWhereUniqueWithoutUserInput = {
    where: WebAuthnCredentialWhereUniqueInput;
    data: XOR<
      WebAuthnCredentialUpdateWithoutUserInput,
      WebAuthnCredentialUncheckedUpdateWithoutUserInput
    >;
  };

  export type WebAuthnCredentialUpdateManyWithWhereWithoutUserInput = {
    where: WebAuthnCredentialScalarWhereInput;
    data: XOR<
      WebAuthnCredentialUpdateManyMutationInput,
      WebAuthnCredentialUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type WebAuthnCredentialScalarWhereInput = {
    AND?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[];
    OR?: WebAuthnCredentialScalarWhereInput[];
    NOT?: WebAuthnCredentialScalarWhereInput | WebAuthnCredentialScalarWhereInput[];
    id?: StringFilter<'WebAuthnCredential'> | string;
    credentialId?: BytesFilter<'WebAuthnCredential'> | Bytes;
    publicKey?: BytesFilter<'WebAuthnCredential'> | Bytes;
    counter?: BigIntFilter<'WebAuthnCredential'> | bigint | number;
    deviceType?: StringFilter<'WebAuthnCredential'> | string;
    backedUp?: BoolFilter<'WebAuthnCredential'> | boolean;
    transports?: StringNullableListFilter<'WebAuthnCredential'>;
    name?: StringNullableFilter<'WebAuthnCredential'> | string | null;
    createdAt?: DateTimeFilter<'WebAuthnCredential'> | Date | string;
    lastUsedAt?: DateTimeNullableFilter<'WebAuthnCredential'> | Date | string | null;
    userId?: StringFilter<'WebAuthnCredential'> | string;
  };

  export type UserCreateWithoutSharedPaperlessInstancesInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSharedPaperlessInstancesInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSharedPaperlessInstancesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSharedPaperlessInstancesInput,
      UserUncheckedCreateWithoutSharedPaperlessInstancesInput
    >;
  };

  export type PaperlessInstanceCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    defaultAiBot?: AiBotCreateNestedOneWithoutDefaultForInstancesInput;
    owner: UserCreateNestedOneWithoutOwnedPaperlessInstancesInput;
    documents?: PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
    documents?: PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceCreateOrConnectWithoutSharedWithInput = {
    where: PaperlessInstanceWhereUniqueInput;
    create: XOR<
      PaperlessInstanceCreateWithoutSharedWithInput,
      PaperlessInstanceUncheckedCreateWithoutSharedWithInput
    >;
  };

  export type UserUpsertWithoutSharedPaperlessInstancesInput = {
    update: XOR<
      UserUpdateWithoutSharedPaperlessInstancesInput,
      UserUncheckedUpdateWithoutSharedPaperlessInstancesInput
    >;
    create: XOR<
      UserCreateWithoutSharedPaperlessInstancesInput,
      UserUncheckedCreateWithoutSharedPaperlessInstancesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSharedPaperlessInstancesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSharedPaperlessInstancesInput,
      UserUncheckedUpdateWithoutSharedPaperlessInstancesInput
    >;
  };

  export type UserUpdateWithoutSharedPaperlessInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSharedPaperlessInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type PaperlessInstanceUpsertWithoutSharedWithInput = {
    update: XOR<
      PaperlessInstanceUpdateWithoutSharedWithInput,
      PaperlessInstanceUncheckedUpdateWithoutSharedWithInput
    >;
    create: XOR<
      PaperlessInstanceCreateWithoutSharedWithInput,
      PaperlessInstanceUncheckedCreateWithoutSharedWithInput
    >;
    where?: PaperlessInstanceWhereInput;
  };

  export type PaperlessInstanceUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: PaperlessInstanceWhereInput;
    data: XOR<
      PaperlessInstanceUpdateWithoutSharedWithInput,
      PaperlessInstanceUncheckedUpdateWithoutSharedWithInput
    >;
  };

  export type PaperlessInstanceUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    defaultAiBot?: AiBotUpdateOneWithoutDefaultForInstancesNestedInput;
    owner?: UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput;
    documents?: PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
    documents?: PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type UserCreateWithoutSharedAiAccountsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSharedAiAccountsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSharedAiAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSharedAiAccountsInput,
      UserUncheckedCreateWithoutSharedAiAccountsInput
    >;
  };

  export type AiAccountCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiAccountsInput;
    models?: AiModelCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountUncheckedCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    models?: AiModelUncheckedCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountCreateOrConnectWithoutSharedWithInput = {
    where: AiAccountWhereUniqueInput;
    create: XOR<
      AiAccountCreateWithoutSharedWithInput,
      AiAccountUncheckedCreateWithoutSharedWithInput
    >;
  };

  export type UserUpsertWithoutSharedAiAccountsInput = {
    update: XOR<
      UserUpdateWithoutSharedAiAccountsInput,
      UserUncheckedUpdateWithoutSharedAiAccountsInput
    >;
    create: XOR<
      UserCreateWithoutSharedAiAccountsInput,
      UserUncheckedCreateWithoutSharedAiAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSharedAiAccountsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutSharedAiAccountsInput,
      UserUncheckedUpdateWithoutSharedAiAccountsInput
    >;
  };

  export type UserUpdateWithoutSharedAiAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSharedAiAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AiAccountUpsertWithoutSharedWithInput = {
    update: XOR<
      AiAccountUpdateWithoutSharedWithInput,
      AiAccountUncheckedUpdateWithoutSharedWithInput
    >;
    create: XOR<
      AiAccountCreateWithoutSharedWithInput,
      AiAccountUncheckedCreateWithoutSharedWithInput
    >;
    where?: AiAccountWhereInput;
  };

  export type AiAccountUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: AiAccountWhereInput;
    data: XOR<
      AiAccountUpdateWithoutSharedWithInput,
      AiAccountUncheckedUpdateWithoutSharedWithInput
    >;
  };

  export type AiAccountUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiAccountsNestedInput;
    models?: AiModelUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    models?: AiModelUncheckedUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiAccountNestedInput;
  };

  export type UserCreateWithoutSharedAiModelsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSharedAiModelsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSharedAiModelsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutSharedAiModelsInput,
      UserUncheckedCreateWithoutSharedAiModelsInput
    >;
  };

  export type AiModelCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiModelsInput;
    aiAccount: AiAccountCreateNestedOneWithoutModelsInput;
    bots?: AiBotCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUncheckedCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiAccountId: string;
    bots?: AiBotUncheckedCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelCreateOrConnectWithoutSharedWithInput = {
    where: AiModelWhereUniqueInput;
    create: XOR<AiModelCreateWithoutSharedWithInput, AiModelUncheckedCreateWithoutSharedWithInput>;
  };

  export type UserUpsertWithoutSharedAiModelsInput = {
    update: XOR<
      UserUpdateWithoutSharedAiModelsInput,
      UserUncheckedUpdateWithoutSharedAiModelsInput
    >;
    create: XOR<
      UserCreateWithoutSharedAiModelsInput,
      UserUncheckedCreateWithoutSharedAiModelsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSharedAiModelsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSharedAiModelsInput, UserUncheckedUpdateWithoutSharedAiModelsInput>;
  };

  export type UserUpdateWithoutSharedAiModelsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSharedAiModelsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AiModelUpsertWithoutSharedWithInput = {
    update: XOR<AiModelUpdateWithoutSharedWithInput, AiModelUncheckedUpdateWithoutSharedWithInput>;
    create: XOR<AiModelCreateWithoutSharedWithInput, AiModelUncheckedCreateWithoutSharedWithInput>;
    where?: AiModelWhereInput;
  };

  export type AiModelUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: AiModelWhereInput;
    data: XOR<AiModelUpdateWithoutSharedWithInput, AiModelUncheckedUpdateWithoutSharedWithInput>;
  };

  export type AiModelUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiModelsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutModelsNestedInput;
    bots?: AiBotUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    bots?: AiBotUncheckedUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiModelNestedInput;
  };

  export type UserCreateWithoutSharedAiBotsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutSharedAiBotsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutSharedAiBotsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutSharedAiBotsInput, UserUncheckedCreateWithoutSharedAiBotsInput>;
  };

  export type AiBotCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiBotsInput;
    aiModel: AiModelCreateNestedOneWithoutBotsInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUncheckedCreateWithoutSharedWithInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiModelId: string;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotCreateOrConnectWithoutSharedWithInput = {
    where: AiBotWhereUniqueInput;
    create: XOR<AiBotCreateWithoutSharedWithInput, AiBotUncheckedCreateWithoutSharedWithInput>;
  };

  export type UserUpsertWithoutSharedAiBotsInput = {
    update: XOR<UserUpdateWithoutSharedAiBotsInput, UserUncheckedUpdateWithoutSharedAiBotsInput>;
    create: XOR<UserCreateWithoutSharedAiBotsInput, UserUncheckedCreateWithoutSharedAiBotsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutSharedAiBotsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutSharedAiBotsInput, UserUncheckedUpdateWithoutSharedAiBotsInput>;
  };

  export type UserUpdateWithoutSharedAiBotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutSharedAiBotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AiBotUpsertWithoutSharedWithInput = {
    update: XOR<AiBotUpdateWithoutSharedWithInput, AiBotUncheckedUpdateWithoutSharedWithInput>;
    create: XOR<AiBotCreateWithoutSharedWithInput, AiBotUncheckedCreateWithoutSharedWithInput>;
    where?: AiBotWhereInput;
  };

  export type AiBotUpdateToOneWithWhereWithoutSharedWithInput = {
    where?: AiBotWhereInput;
    data: XOR<AiBotUpdateWithoutSharedWithInput, AiBotUncheckedUpdateWithoutSharedWithInput>;
  };

  export type AiBotUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput;
    aiModel?: AiModelUpdateOneRequiredWithoutBotsNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateWithoutSharedWithInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotCreateWithoutDefaultForInstancesInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiBotsInput;
    aiModel: AiModelCreateNestedOneWithoutBotsInput;
    sharedWith?: UserAiBotAccessCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiBotInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUncheckedCreateWithoutDefaultForInstancesInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiModelId: string;
    sharedWith?: UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotCreateOrConnectWithoutDefaultForInstancesInput = {
    where: AiBotWhereUniqueInput;
    create: XOR<
      AiBotCreateWithoutDefaultForInstancesInput,
      AiBotUncheckedCreateWithoutDefaultForInstancesInput
    >;
  };

  export type UserCreateWithoutOwnedPaperlessInstancesInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOwnedPaperlessInstancesInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOwnedPaperlessInstancesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutOwnedPaperlessInstancesInput,
      UserUncheckedCreateWithoutOwnedPaperlessInstancesInput
    >;
  };

  export type UserPaperlessInstanceAccessCreateWithoutInstanceInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedPaperlessInstancesInput;
  };

  export type UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserPaperlessInstanceAccessCreateOrConnectWithoutInstanceInput = {
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    create: XOR<
      UserPaperlessInstanceAccessCreateWithoutInstanceInput,
      UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput
    >;
  };

  export type UserPaperlessInstanceAccessCreateManyInstanceInputEnvelope = {
    data:
      | UserPaperlessInstanceAccessCreateManyInstanceInput
      | UserPaperlessInstanceAccessCreateManyInstanceInput[];
    skipDuplicates?: boolean;
  };

  export type PaperlessDocumentCreateWithoutPaperlessInstanceInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    processingResults?: DocumentProcessingResultCreateNestedManyWithoutDocumentInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    processingResults?: DocumentProcessingResultUncheckedCreateNestedManyWithoutDocumentInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentCreateOrConnectWithoutPaperlessInstanceInput = {
    where: PaperlessDocumentWhereUniqueInput;
    create: XOR<
      PaperlessDocumentCreateWithoutPaperlessInstanceInput,
      PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput
    >;
  };

  export type PaperlessDocumentCreateManyPaperlessInstanceInputEnvelope = {
    data:
      | PaperlessDocumentCreateManyPaperlessInstanceInput
      | PaperlessDocumentCreateManyPaperlessInstanceInput[];
    skipDuplicates?: boolean;
  };

  export type ProcessingQueueCreateWithoutPaperlessInstanceInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    document?: PaperlessDocumentCreateNestedOneWithoutProcessingQueueItemsInput;
    aiBot?: AiBotCreateNestedOneWithoutProcessingQueueItemsInput;
  };

  export type ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    documentId?: string | null;
    aiBotId?: string | null;
  };

  export type ProcessingQueueCreateOrConnectWithoutPaperlessInstanceInput = {
    where: ProcessingQueueWhereUniqueInput;
    create: XOR<
      ProcessingQueueCreateWithoutPaperlessInstanceInput,
      ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput
    >;
  };

  export type ProcessingQueueCreateManyPaperlessInstanceInputEnvelope = {
    data:
      | ProcessingQueueCreateManyPaperlessInstanceInput
      | ProcessingQueueCreateManyPaperlessInstanceInput[];
    skipDuplicates?: boolean;
  };

  export type ImportHistoryCreateWithoutPaperlessInstanceInput = {
    id?: string;
    importedAt?: Date | string;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
  };

  export type ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput = {
    id?: string;
    importedAt?: Date | string;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
  };

  export type ImportHistoryCreateOrConnectWithoutPaperlessInstanceInput = {
    where: ImportHistoryWhereUniqueInput;
    create: XOR<
      ImportHistoryCreateWithoutPaperlessInstanceInput,
      ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput
    >;
  };

  export type ImportHistoryCreateManyPaperlessInstanceInputEnvelope = {
    data:
      | ImportHistoryCreateManyPaperlessInstanceInput
      | ImportHistoryCreateManyPaperlessInstanceInput[];
    skipDuplicates?: boolean;
  };

  export type AiBotUpsertWithoutDefaultForInstancesInput = {
    update: XOR<
      AiBotUpdateWithoutDefaultForInstancesInput,
      AiBotUncheckedUpdateWithoutDefaultForInstancesInput
    >;
    create: XOR<
      AiBotCreateWithoutDefaultForInstancesInput,
      AiBotUncheckedCreateWithoutDefaultForInstancesInput
    >;
    where?: AiBotWhereInput;
  };

  export type AiBotUpdateToOneWithWhereWithoutDefaultForInstancesInput = {
    where?: AiBotWhereInput;
    data: XOR<
      AiBotUpdateWithoutDefaultForInstancesInput,
      AiBotUncheckedUpdateWithoutDefaultForInstancesInput
    >;
  };

  export type AiBotUpdateWithoutDefaultForInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput;
    aiModel?: AiModelUpdateOneRequiredWithoutBotsNestedInput;
    sharedWith?: UserAiBotAccessUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateWithoutDefaultForInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput;
  };

  export type UserUpsertWithoutOwnedPaperlessInstancesInput = {
    update: XOR<
      UserUpdateWithoutOwnedPaperlessInstancesInput,
      UserUncheckedUpdateWithoutOwnedPaperlessInstancesInput
    >;
    create: XOR<
      UserCreateWithoutOwnedPaperlessInstancesInput,
      UserUncheckedCreateWithoutOwnedPaperlessInstancesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOwnedPaperlessInstancesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutOwnedPaperlessInstancesInput,
      UserUncheckedUpdateWithoutOwnedPaperlessInstancesInput
    >;
  };

  export type UserUpdateWithoutOwnedPaperlessInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOwnedPaperlessInstancesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserPaperlessInstanceAccessUpsertWithWhereUniqueWithoutInstanceInput = {
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    update: XOR<
      UserPaperlessInstanceAccessUpdateWithoutInstanceInput,
      UserPaperlessInstanceAccessUncheckedUpdateWithoutInstanceInput
    >;
    create: XOR<
      UserPaperlessInstanceAccessCreateWithoutInstanceInput,
      UserPaperlessInstanceAccessUncheckedCreateWithoutInstanceInput
    >;
  };

  export type UserPaperlessInstanceAccessUpdateWithWhereUniqueWithoutInstanceInput = {
    where: UserPaperlessInstanceAccessWhereUniqueInput;
    data: XOR<
      UserPaperlessInstanceAccessUpdateWithoutInstanceInput,
      UserPaperlessInstanceAccessUncheckedUpdateWithoutInstanceInput
    >;
  };

  export type UserPaperlessInstanceAccessUpdateManyWithWhereWithoutInstanceInput = {
    where: UserPaperlessInstanceAccessScalarWhereInput;
    data: XOR<
      UserPaperlessInstanceAccessUpdateManyMutationInput,
      UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceInput
    >;
  };

  export type PaperlessDocumentUpsertWithWhereUniqueWithoutPaperlessInstanceInput = {
    where: PaperlessDocumentWhereUniqueInput;
    update: XOR<
      PaperlessDocumentUpdateWithoutPaperlessInstanceInput,
      PaperlessDocumentUncheckedUpdateWithoutPaperlessInstanceInput
    >;
    create: XOR<
      PaperlessDocumentCreateWithoutPaperlessInstanceInput,
      PaperlessDocumentUncheckedCreateWithoutPaperlessInstanceInput
    >;
  };

  export type PaperlessDocumentUpdateWithWhereUniqueWithoutPaperlessInstanceInput = {
    where: PaperlessDocumentWhereUniqueInput;
    data: XOR<
      PaperlessDocumentUpdateWithoutPaperlessInstanceInput,
      PaperlessDocumentUncheckedUpdateWithoutPaperlessInstanceInput
    >;
  };

  export type PaperlessDocumentUpdateManyWithWhereWithoutPaperlessInstanceInput = {
    where: PaperlessDocumentScalarWhereInput;
    data: XOR<
      PaperlessDocumentUpdateManyMutationInput,
      PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceInput
    >;
  };

  export type PaperlessDocumentScalarWhereInput = {
    AND?: PaperlessDocumentScalarWhereInput | PaperlessDocumentScalarWhereInput[];
    OR?: PaperlessDocumentScalarWhereInput[];
    NOT?: PaperlessDocumentScalarWhereInput | PaperlessDocumentScalarWhereInput[];
    id?: StringFilter<'PaperlessDocument'> | string;
    paperlessId?: IntFilter<'PaperlessDocument'> | number;
    title?: StringFilter<'PaperlessDocument'> | string;
    content?: StringFilter<'PaperlessDocument'> | string;
    correspondentId?: IntNullableFilter<'PaperlessDocument'> | number | null;
    tagIds?: IntNullableListFilter<'PaperlessDocument'>;
    documentDate?: DateTimeNullableFilter<'PaperlessDocument'> | Date | string | null;
    paperlessModified?: DateTimeNullableFilter<'PaperlessDocument'> | Date | string | null;
    importedAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
    createdAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
    updatedAt?: DateTimeFilter<'PaperlessDocument'> | Date | string;
    paperlessInstanceId?: StringFilter<'PaperlessDocument'> | string;
  };

  export type ProcessingQueueUpsertWithWhereUniqueWithoutPaperlessInstanceInput = {
    where: ProcessingQueueWhereUniqueInput;
    update: XOR<
      ProcessingQueueUpdateWithoutPaperlessInstanceInput,
      ProcessingQueueUncheckedUpdateWithoutPaperlessInstanceInput
    >;
    create: XOR<
      ProcessingQueueCreateWithoutPaperlessInstanceInput,
      ProcessingQueueUncheckedCreateWithoutPaperlessInstanceInput
    >;
  };

  export type ProcessingQueueUpdateWithWhereUniqueWithoutPaperlessInstanceInput = {
    where: ProcessingQueueWhereUniqueInput;
    data: XOR<
      ProcessingQueueUpdateWithoutPaperlessInstanceInput,
      ProcessingQueueUncheckedUpdateWithoutPaperlessInstanceInput
    >;
  };

  export type ProcessingQueueUpdateManyWithWhereWithoutPaperlessInstanceInput = {
    where: ProcessingQueueScalarWhereInput;
    data: XOR<
      ProcessingQueueUpdateManyMutationInput,
      ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceInput
    >;
  };

  export type ProcessingQueueScalarWhereInput = {
    AND?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
    OR?: ProcessingQueueScalarWhereInput[];
    NOT?: ProcessingQueueScalarWhereInput | ProcessingQueueScalarWhereInput[];
    id?: StringFilter<'ProcessingQueue'> | string;
    paperlessDocumentId?: IntFilter<'ProcessingQueue'> | number;
    status?: StringFilter<'ProcessingQueue'> | string;
    priority?: IntFilter<'ProcessingQueue'> | number;
    attempts?: IntFilter<'ProcessingQueue'> | number;
    maxAttempts?: IntFilter<'ProcessingQueue'> | number;
    lastError?: StringNullableFilter<'ProcessingQueue'> | string | null;
    scheduledFor?: DateTimeFilter<'ProcessingQueue'> | Date | string;
    startedAt?: DateTimeNullableFilter<'ProcessingQueue'> | Date | string | null;
    completedAt?: DateTimeNullableFilter<'ProcessingQueue'> | Date | string | null;
    createdAt?: DateTimeFilter<'ProcessingQueue'> | Date | string;
    updatedAt?: DateTimeFilter<'ProcessingQueue'> | Date | string;
    paperlessInstanceId?: StringFilter<'ProcessingQueue'> | string;
    documentId?: StringNullableFilter<'ProcessingQueue'> | string | null;
    aiBotId?: StringNullableFilter<'ProcessingQueue'> | string | null;
  };

  export type ImportHistoryUpsertWithWhereUniqueWithoutPaperlessInstanceInput = {
    where: ImportHistoryWhereUniqueInput;
    update: XOR<
      ImportHistoryUpdateWithoutPaperlessInstanceInput,
      ImportHistoryUncheckedUpdateWithoutPaperlessInstanceInput
    >;
    create: XOR<
      ImportHistoryCreateWithoutPaperlessInstanceInput,
      ImportHistoryUncheckedCreateWithoutPaperlessInstanceInput
    >;
  };

  export type ImportHistoryUpdateWithWhereUniqueWithoutPaperlessInstanceInput = {
    where: ImportHistoryWhereUniqueInput;
    data: XOR<
      ImportHistoryUpdateWithoutPaperlessInstanceInput,
      ImportHistoryUncheckedUpdateWithoutPaperlessInstanceInput
    >;
  };

  export type ImportHistoryUpdateManyWithWhereWithoutPaperlessInstanceInput = {
    where: ImportHistoryScalarWhereInput;
    data: XOR<
      ImportHistoryUpdateManyMutationInput,
      ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceInput
    >;
  };

  export type ImportHistoryScalarWhereInput = {
    AND?: ImportHistoryScalarWhereInput | ImportHistoryScalarWhereInput[];
    OR?: ImportHistoryScalarWhereInput[];
    NOT?: ImportHistoryScalarWhereInput | ImportHistoryScalarWhereInput[];
    id?: StringFilter<'ImportHistory'> | string;
    importedAt?: DateTimeFilter<'ImportHistory'> | Date | string;
    documentsImported?: IntFilter<'ImportHistory'> | number;
    documentsUpdated?: IntFilter<'ImportHistory'> | number;
    documentsUnchanged?: IntFilter<'ImportHistory'> | number;
    totalInPaperless?: IntFilter<'ImportHistory'> | number;
    paperlessInstanceId?: StringFilter<'ImportHistory'> | string;
  };

  export type UserCreateWithoutOwnedAiAccountsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOwnedAiAccountsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOwnedAiAccountsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutOwnedAiAccountsInput,
      UserUncheckedCreateWithoutOwnedAiAccountsInput
    >;
  };

  export type UserAiAccountAccessCreateWithoutAiAccountInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedAiAccountsInput;
  };

  export type UserAiAccountAccessUncheckedCreateWithoutAiAccountInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiAccountAccessCreateOrConnectWithoutAiAccountInput = {
    where: UserAiAccountAccessWhereUniqueInput;
    create: XOR<
      UserAiAccountAccessCreateWithoutAiAccountInput,
      UserAiAccountAccessUncheckedCreateWithoutAiAccountInput
    >;
  };

  export type UserAiAccountAccessCreateManyAiAccountInputEnvelope = {
    data:
      | UserAiAccountAccessCreateManyAiAccountInput
      | UserAiAccountAccessCreateManyAiAccountInput[];
    skipDuplicates?: boolean;
  };

  export type AiModelCreateWithoutAiAccountInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiModelsInput;
    sharedWith?: UserAiModelAccessCreateNestedManyWithoutAiModelInput;
    bots?: AiBotCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUncheckedCreateWithoutAiAccountInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    sharedWith?: UserAiModelAccessUncheckedCreateNestedManyWithoutAiModelInput;
    bots?: AiBotUncheckedCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelCreateOrConnectWithoutAiAccountInput = {
    where: AiModelWhereUniqueInput;
    create: XOR<AiModelCreateWithoutAiAccountInput, AiModelUncheckedCreateWithoutAiAccountInput>;
  };

  export type AiModelCreateManyAiAccountInputEnvelope = {
    data: AiModelCreateManyAiAccountInput | AiModelCreateManyAiAccountInput[];
    skipDuplicates?: boolean;
  };

  export type AiUsageMetricCreateWithoutAiAccountInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutAiUsageMetricsInput;
    aiModel?: AiModelCreateNestedOneWithoutAiUsageMetricsInput;
    aiBot?: AiBotCreateNestedOneWithoutAiUsageMetricsInput;
  };

  export type AiUsageMetricUncheckedCreateWithoutAiAccountInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiModelId?: string | null;
    aiBotId?: string | null;
  };

  export type AiUsageMetricCreateOrConnectWithoutAiAccountInput = {
    where: AiUsageMetricWhereUniqueInput;
    create: XOR<
      AiUsageMetricCreateWithoutAiAccountInput,
      AiUsageMetricUncheckedCreateWithoutAiAccountInput
    >;
  };

  export type AiUsageMetricCreateManyAiAccountInputEnvelope = {
    data: AiUsageMetricCreateManyAiAccountInput | AiUsageMetricCreateManyAiAccountInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutOwnedAiAccountsInput = {
    update: XOR<
      UserUpdateWithoutOwnedAiAccountsInput,
      UserUncheckedUpdateWithoutOwnedAiAccountsInput
    >;
    create: XOR<
      UserCreateWithoutOwnedAiAccountsInput,
      UserUncheckedCreateWithoutOwnedAiAccountsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOwnedAiAccountsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutOwnedAiAccountsInput,
      UserUncheckedUpdateWithoutOwnedAiAccountsInput
    >;
  };

  export type UserUpdateWithoutOwnedAiAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOwnedAiAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type UserAiAccountAccessUpsertWithWhereUniqueWithoutAiAccountInput = {
    where: UserAiAccountAccessWhereUniqueInput;
    update: XOR<
      UserAiAccountAccessUpdateWithoutAiAccountInput,
      UserAiAccountAccessUncheckedUpdateWithoutAiAccountInput
    >;
    create: XOR<
      UserAiAccountAccessCreateWithoutAiAccountInput,
      UserAiAccountAccessUncheckedCreateWithoutAiAccountInput
    >;
  };

  export type UserAiAccountAccessUpdateWithWhereUniqueWithoutAiAccountInput = {
    where: UserAiAccountAccessWhereUniqueInput;
    data: XOR<
      UserAiAccountAccessUpdateWithoutAiAccountInput,
      UserAiAccountAccessUncheckedUpdateWithoutAiAccountInput
    >;
  };

  export type UserAiAccountAccessUpdateManyWithWhereWithoutAiAccountInput = {
    where: UserAiAccountAccessScalarWhereInput;
    data: XOR<
      UserAiAccountAccessUpdateManyMutationInput,
      UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountInput
    >;
  };

  export type AiModelUpsertWithWhereUniqueWithoutAiAccountInput = {
    where: AiModelWhereUniqueInput;
    update: XOR<AiModelUpdateWithoutAiAccountInput, AiModelUncheckedUpdateWithoutAiAccountInput>;
    create: XOR<AiModelCreateWithoutAiAccountInput, AiModelUncheckedCreateWithoutAiAccountInput>;
  };

  export type AiModelUpdateWithWhereUniqueWithoutAiAccountInput = {
    where: AiModelWhereUniqueInput;
    data: XOR<AiModelUpdateWithoutAiAccountInput, AiModelUncheckedUpdateWithoutAiAccountInput>;
  };

  export type AiModelUpdateManyWithWhereWithoutAiAccountInput = {
    where: AiModelScalarWhereInput;
    data: XOR<AiModelUpdateManyMutationInput, AiModelUncheckedUpdateManyWithoutAiAccountInput>;
  };

  export type AiUsageMetricUpsertWithWhereUniqueWithoutAiAccountInput = {
    where: AiUsageMetricWhereUniqueInput;
    update: XOR<
      AiUsageMetricUpdateWithoutAiAccountInput,
      AiUsageMetricUncheckedUpdateWithoutAiAccountInput
    >;
    create: XOR<
      AiUsageMetricCreateWithoutAiAccountInput,
      AiUsageMetricUncheckedCreateWithoutAiAccountInput
    >;
  };

  export type AiUsageMetricUpdateWithWhereUniqueWithoutAiAccountInput = {
    where: AiUsageMetricWhereUniqueInput;
    data: XOR<
      AiUsageMetricUpdateWithoutAiAccountInput,
      AiUsageMetricUncheckedUpdateWithoutAiAccountInput
    >;
  };

  export type AiUsageMetricUpdateManyWithWhereWithoutAiAccountInput = {
    where: AiUsageMetricScalarWhereInput;
    data: XOR<
      AiUsageMetricUpdateManyMutationInput,
      AiUsageMetricUncheckedUpdateManyWithoutAiAccountInput
    >;
  };

  export type UserCreateWithoutOwnedAiModelsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOwnedAiModelsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOwnedAiModelsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutOwnedAiModelsInput, UserUncheckedCreateWithoutOwnedAiModelsInput>;
  };

  export type AiAccountCreateWithoutModelsInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiAccountsInput;
    sharedWith?: UserAiAccountAccessCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountUncheckedCreateWithoutModelsInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    sharedWith?: UserAiAccountAccessUncheckedCreateNestedManyWithoutAiAccountInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountCreateOrConnectWithoutModelsInput = {
    where: AiAccountWhereUniqueInput;
    create: XOR<AiAccountCreateWithoutModelsInput, AiAccountUncheckedCreateWithoutModelsInput>;
  };

  export type UserAiModelAccessCreateWithoutAiModelInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedAiModelsInput;
  };

  export type UserAiModelAccessUncheckedCreateWithoutAiModelInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiModelAccessCreateOrConnectWithoutAiModelInput = {
    where: UserAiModelAccessWhereUniqueInput;
    create: XOR<
      UserAiModelAccessCreateWithoutAiModelInput,
      UserAiModelAccessUncheckedCreateWithoutAiModelInput
    >;
  };

  export type UserAiModelAccessCreateManyAiModelInputEnvelope = {
    data: UserAiModelAccessCreateManyAiModelInput | UserAiModelAccessCreateManyAiModelInput[];
    skipDuplicates?: boolean;
  };

  export type AiBotCreateWithoutAiModelInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiBotsInput;
    sharedWith?: UserAiBotAccessCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUncheckedCreateWithoutAiModelInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    sharedWith?: UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotCreateOrConnectWithoutAiModelInput = {
    where: AiBotWhereUniqueInput;
    create: XOR<AiBotCreateWithoutAiModelInput, AiBotUncheckedCreateWithoutAiModelInput>;
  };

  export type AiBotCreateManyAiModelInputEnvelope = {
    data: AiBotCreateManyAiModelInput | AiBotCreateManyAiModelInput[];
    skipDuplicates?: boolean;
  };

  export type AiUsageMetricCreateWithoutAiModelInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutAiUsageMetricsInput;
    aiAccount: AiAccountCreateNestedOneWithoutAiUsageMetricsInput;
    aiBot?: AiBotCreateNestedOneWithoutAiUsageMetricsInput;
  };

  export type AiUsageMetricUncheckedCreateWithoutAiModelInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiAccountId: string;
    aiBotId?: string | null;
  };

  export type AiUsageMetricCreateOrConnectWithoutAiModelInput = {
    where: AiUsageMetricWhereUniqueInput;
    create: XOR<
      AiUsageMetricCreateWithoutAiModelInput,
      AiUsageMetricUncheckedCreateWithoutAiModelInput
    >;
  };

  export type AiUsageMetricCreateManyAiModelInputEnvelope = {
    data: AiUsageMetricCreateManyAiModelInput | AiUsageMetricCreateManyAiModelInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutOwnedAiModelsInput = {
    update: XOR<UserUpdateWithoutOwnedAiModelsInput, UserUncheckedUpdateWithoutOwnedAiModelsInput>;
    create: XOR<UserCreateWithoutOwnedAiModelsInput, UserUncheckedCreateWithoutOwnedAiModelsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOwnedAiModelsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutOwnedAiModelsInput, UserUncheckedUpdateWithoutOwnedAiModelsInput>;
  };

  export type UserUpdateWithoutOwnedAiModelsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOwnedAiModelsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AiAccountUpsertWithoutModelsInput = {
    update: XOR<AiAccountUpdateWithoutModelsInput, AiAccountUncheckedUpdateWithoutModelsInput>;
    create: XOR<AiAccountCreateWithoutModelsInput, AiAccountUncheckedCreateWithoutModelsInput>;
    where?: AiAccountWhereInput;
  };

  export type AiAccountUpdateToOneWithWhereWithoutModelsInput = {
    where?: AiAccountWhereInput;
    data: XOR<AiAccountUpdateWithoutModelsInput, AiAccountUncheckedUpdateWithoutModelsInput>;
  };

  export type AiAccountUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiAccountsNestedInput;
    sharedWith?: UserAiAccountAccessUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountUncheckedUpdateWithoutModelsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiAccountNestedInput;
  };

  export type UserAiModelAccessUpsertWithWhereUniqueWithoutAiModelInput = {
    where: UserAiModelAccessWhereUniqueInput;
    update: XOR<
      UserAiModelAccessUpdateWithoutAiModelInput,
      UserAiModelAccessUncheckedUpdateWithoutAiModelInput
    >;
    create: XOR<
      UserAiModelAccessCreateWithoutAiModelInput,
      UserAiModelAccessUncheckedCreateWithoutAiModelInput
    >;
  };

  export type UserAiModelAccessUpdateWithWhereUniqueWithoutAiModelInput = {
    where: UserAiModelAccessWhereUniqueInput;
    data: XOR<
      UserAiModelAccessUpdateWithoutAiModelInput,
      UserAiModelAccessUncheckedUpdateWithoutAiModelInput
    >;
  };

  export type UserAiModelAccessUpdateManyWithWhereWithoutAiModelInput = {
    where: UserAiModelAccessScalarWhereInput;
    data: XOR<
      UserAiModelAccessUpdateManyMutationInput,
      UserAiModelAccessUncheckedUpdateManyWithoutAiModelInput
    >;
  };

  export type AiBotUpsertWithWhereUniqueWithoutAiModelInput = {
    where: AiBotWhereUniqueInput;
    update: XOR<AiBotUpdateWithoutAiModelInput, AiBotUncheckedUpdateWithoutAiModelInput>;
    create: XOR<AiBotCreateWithoutAiModelInput, AiBotUncheckedCreateWithoutAiModelInput>;
  };

  export type AiBotUpdateWithWhereUniqueWithoutAiModelInput = {
    where: AiBotWhereUniqueInput;
    data: XOR<AiBotUpdateWithoutAiModelInput, AiBotUncheckedUpdateWithoutAiModelInput>;
  };

  export type AiBotUpdateManyWithWhereWithoutAiModelInput = {
    where: AiBotScalarWhereInput;
    data: XOR<AiBotUpdateManyMutationInput, AiBotUncheckedUpdateManyWithoutAiModelInput>;
  };

  export type AiUsageMetricUpsertWithWhereUniqueWithoutAiModelInput = {
    where: AiUsageMetricWhereUniqueInput;
    update: XOR<
      AiUsageMetricUpdateWithoutAiModelInput,
      AiUsageMetricUncheckedUpdateWithoutAiModelInput
    >;
    create: XOR<
      AiUsageMetricCreateWithoutAiModelInput,
      AiUsageMetricUncheckedCreateWithoutAiModelInput
    >;
  };

  export type AiUsageMetricUpdateWithWhereUniqueWithoutAiModelInput = {
    where: AiUsageMetricWhereUniqueInput;
    data: XOR<
      AiUsageMetricUpdateWithoutAiModelInput,
      AiUsageMetricUncheckedUpdateWithoutAiModelInput
    >;
  };

  export type AiUsageMetricUpdateManyWithWhereWithoutAiModelInput = {
    where: AiUsageMetricScalarWhereInput;
    data: XOR<
      AiUsageMetricUpdateManyMutationInput,
      AiUsageMetricUncheckedUpdateManyWithoutAiModelInput
    >;
  };

  export type UserCreateWithoutOwnedAiBotsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutOwnedAiBotsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutOwnedAiBotsInput = {
    where: UserWhereUniqueInput;
    create: XOR<UserCreateWithoutOwnedAiBotsInput, UserUncheckedCreateWithoutOwnedAiBotsInput>;
  };

  export type AiModelCreateWithoutBotsInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiModelsInput;
    aiAccount: AiAccountCreateNestedOneWithoutModelsInput;
    sharedWith?: UserAiModelAccessCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUncheckedCreateWithoutBotsInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiAccountId: string;
    sharedWith?: UserAiModelAccessUncheckedCreateNestedManyWithoutAiModelInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelCreateOrConnectWithoutBotsInput = {
    where: AiModelWhereUniqueInput;
    create: XOR<AiModelCreateWithoutBotsInput, AiModelUncheckedCreateWithoutBotsInput>;
  };

  export type UserAiBotAccessCreateWithoutAiBotInput = {
    id?: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
    user?: UserCreateNestedOneWithoutSharedAiBotsInput;
  };

  export type UserAiBotAccessUncheckedCreateWithoutAiBotInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiBotAccessCreateOrConnectWithoutAiBotInput = {
    where: UserAiBotAccessWhereUniqueInput;
    create: XOR<
      UserAiBotAccessCreateWithoutAiBotInput,
      UserAiBotAccessUncheckedCreateWithoutAiBotInput
    >;
  };

  export type UserAiBotAccessCreateManyAiBotInputEnvelope = {
    data: UserAiBotAccessCreateManyAiBotInput | UserAiBotAccessCreateManyAiBotInput[];
    skipDuplicates?: boolean;
  };

  export type AiUsageMetricCreateWithoutAiBotInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutAiUsageMetricsInput;
    aiAccount: AiAccountCreateNestedOneWithoutAiUsageMetricsInput;
    aiModel?: AiModelCreateNestedOneWithoutAiUsageMetricsInput;
  };

  export type AiUsageMetricUncheckedCreateWithoutAiBotInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiAccountId: string;
    aiModelId?: string | null;
  };

  export type AiUsageMetricCreateOrConnectWithoutAiBotInput = {
    where: AiUsageMetricWhereUniqueInput;
    create: XOR<
      AiUsageMetricCreateWithoutAiBotInput,
      AiUsageMetricUncheckedCreateWithoutAiBotInput
    >;
  };

  export type AiUsageMetricCreateManyAiBotInputEnvelope = {
    data: AiUsageMetricCreateManyAiBotInput | AiUsageMetricCreateManyAiBotInput[];
    skipDuplicates?: boolean;
  };

  export type PaperlessInstanceCreateWithoutDefaultAiBotInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    owner: UserCreateNestedOneWithoutOwnedPaperlessInstancesInput;
    sharedWith?: UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceCreateOrConnectWithoutDefaultAiBotInput = {
    where: PaperlessInstanceWhereUniqueInput;
    create: XOR<
      PaperlessInstanceCreateWithoutDefaultAiBotInput,
      PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput
    >;
  };

  export type PaperlessInstanceCreateManyDefaultAiBotInputEnvelope = {
    data:
      | PaperlessInstanceCreateManyDefaultAiBotInput
      | PaperlessInstanceCreateManyDefaultAiBotInput[];
    skipDuplicates?: boolean;
  };

  export type ProcessingQueueCreateWithoutAiBotInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutProcessingQueueInput;
    document?: PaperlessDocumentCreateNestedOneWithoutProcessingQueueItemsInput;
  };

  export type ProcessingQueueUncheckedCreateWithoutAiBotInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    documentId?: string | null;
  };

  export type ProcessingQueueCreateOrConnectWithoutAiBotInput = {
    where: ProcessingQueueWhereUniqueInput;
    create: XOR<
      ProcessingQueueCreateWithoutAiBotInput,
      ProcessingQueueUncheckedCreateWithoutAiBotInput
    >;
  };

  export type ProcessingQueueCreateManyAiBotInputEnvelope = {
    data: ProcessingQueueCreateManyAiBotInput | ProcessingQueueCreateManyAiBotInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutOwnedAiBotsInput = {
    update: XOR<UserUpdateWithoutOwnedAiBotsInput, UserUncheckedUpdateWithoutOwnedAiBotsInput>;
    create: XOR<UserCreateWithoutOwnedAiBotsInput, UserUncheckedCreateWithoutOwnedAiBotsInput>;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutOwnedAiBotsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutOwnedAiBotsInput, UserUncheckedUpdateWithoutOwnedAiBotsInput>;
  };

  export type UserUpdateWithoutOwnedAiBotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutOwnedAiBotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AiModelUpsertWithoutBotsInput = {
    update: XOR<AiModelUpdateWithoutBotsInput, AiModelUncheckedUpdateWithoutBotsInput>;
    create: XOR<AiModelCreateWithoutBotsInput, AiModelUncheckedCreateWithoutBotsInput>;
    where?: AiModelWhereInput;
  };

  export type AiModelUpdateToOneWithWhereWithoutBotsInput = {
    where?: AiModelWhereInput;
    data: XOR<AiModelUpdateWithoutBotsInput, AiModelUncheckedUpdateWithoutBotsInput>;
  };

  export type AiModelUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiModelsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutModelsNestedInput;
    sharedWith?: UserAiModelAccessUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiModelAccessUncheckedUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiModelNestedInput;
  };

  export type UserAiBotAccessUpsertWithWhereUniqueWithoutAiBotInput = {
    where: UserAiBotAccessWhereUniqueInput;
    update: XOR<
      UserAiBotAccessUpdateWithoutAiBotInput,
      UserAiBotAccessUncheckedUpdateWithoutAiBotInput
    >;
    create: XOR<
      UserAiBotAccessCreateWithoutAiBotInput,
      UserAiBotAccessUncheckedCreateWithoutAiBotInput
    >;
  };

  export type UserAiBotAccessUpdateWithWhereUniqueWithoutAiBotInput = {
    where: UserAiBotAccessWhereUniqueInput;
    data: XOR<
      UserAiBotAccessUpdateWithoutAiBotInput,
      UserAiBotAccessUncheckedUpdateWithoutAiBotInput
    >;
  };

  export type UserAiBotAccessUpdateManyWithWhereWithoutAiBotInput = {
    where: UserAiBotAccessScalarWhereInput;
    data: XOR<
      UserAiBotAccessUpdateManyMutationInput,
      UserAiBotAccessUncheckedUpdateManyWithoutAiBotInput
    >;
  };

  export type AiUsageMetricUpsertWithWhereUniqueWithoutAiBotInput = {
    where: AiUsageMetricWhereUniqueInput;
    update: XOR<
      AiUsageMetricUpdateWithoutAiBotInput,
      AiUsageMetricUncheckedUpdateWithoutAiBotInput
    >;
    create: XOR<
      AiUsageMetricCreateWithoutAiBotInput,
      AiUsageMetricUncheckedCreateWithoutAiBotInput
    >;
  };

  export type AiUsageMetricUpdateWithWhereUniqueWithoutAiBotInput = {
    where: AiUsageMetricWhereUniqueInput;
    data: XOR<AiUsageMetricUpdateWithoutAiBotInput, AiUsageMetricUncheckedUpdateWithoutAiBotInput>;
  };

  export type AiUsageMetricUpdateManyWithWhereWithoutAiBotInput = {
    where: AiUsageMetricScalarWhereInput;
    data: XOR<
      AiUsageMetricUpdateManyMutationInput,
      AiUsageMetricUncheckedUpdateManyWithoutAiBotInput
    >;
  };

  export type PaperlessInstanceUpsertWithWhereUniqueWithoutDefaultAiBotInput = {
    where: PaperlessInstanceWhereUniqueInput;
    update: XOR<
      PaperlessInstanceUpdateWithoutDefaultAiBotInput,
      PaperlessInstanceUncheckedUpdateWithoutDefaultAiBotInput
    >;
    create: XOR<
      PaperlessInstanceCreateWithoutDefaultAiBotInput,
      PaperlessInstanceUncheckedCreateWithoutDefaultAiBotInput
    >;
  };

  export type PaperlessInstanceUpdateWithWhereUniqueWithoutDefaultAiBotInput = {
    where: PaperlessInstanceWhereUniqueInput;
    data: XOR<
      PaperlessInstanceUpdateWithoutDefaultAiBotInput,
      PaperlessInstanceUncheckedUpdateWithoutDefaultAiBotInput
    >;
  };

  export type PaperlessInstanceUpdateManyWithWhereWithoutDefaultAiBotInput = {
    where: PaperlessInstanceScalarWhereInput;
    data: XOR<
      PaperlessInstanceUpdateManyMutationInput,
      PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotInput
    >;
  };

  export type ProcessingQueueUpsertWithWhereUniqueWithoutAiBotInput = {
    where: ProcessingQueueWhereUniqueInput;
    update: XOR<
      ProcessingQueueUpdateWithoutAiBotInput,
      ProcessingQueueUncheckedUpdateWithoutAiBotInput
    >;
    create: XOR<
      ProcessingQueueCreateWithoutAiBotInput,
      ProcessingQueueUncheckedCreateWithoutAiBotInput
    >;
  };

  export type ProcessingQueueUpdateWithWhereUniqueWithoutAiBotInput = {
    where: ProcessingQueueWhereUniqueInput;
    data: XOR<
      ProcessingQueueUpdateWithoutAiBotInput,
      ProcessingQueueUncheckedUpdateWithoutAiBotInput
    >;
  };

  export type ProcessingQueueUpdateManyWithWhereWithoutAiBotInput = {
    where: ProcessingQueueScalarWhereInput;
    data: XOR<
      ProcessingQueueUpdateManyMutationInput,
      ProcessingQueueUncheckedUpdateManyWithoutAiBotInput
    >;
  };

  export type PaperlessInstanceCreateWithoutDocumentsInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    defaultAiBot?: AiBotCreateNestedOneWithoutDefaultForInstancesInput;
    owner: UserCreateNestedOneWithoutOwnedPaperlessInstancesInput;
    sharedWith?: UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput;
    processingQueue?: ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateWithoutDocumentsInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput;
    processingQueue?: ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceCreateOrConnectWithoutDocumentsInput = {
    where: PaperlessInstanceWhereUniqueInput;
    create: XOR<
      PaperlessInstanceCreateWithoutDocumentsInput,
      PaperlessInstanceUncheckedCreateWithoutDocumentsInput
    >;
  };

  export type DocumentProcessingResultCreateWithoutDocumentInput = {
    id?: string;
    processedAt?: Date | string;
    aiProvider: string;
    inputTokens?: number;
    outputTokens?: number;
    estimatedCost?: number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: string | null;
    originalCorrespondent?: string | null;
    originalDocumentType?: string | null;
    originalTags?: DocumentProcessingResultCreateoriginalTagsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentProcessingResultUncheckedCreateWithoutDocumentInput = {
    id?: string;
    processedAt?: Date | string;
    aiProvider: string;
    inputTokens?: number;
    outputTokens?: number;
    estimatedCost?: number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: string | null;
    originalCorrespondent?: string | null;
    originalDocumentType?: string | null;
    originalTags?: DocumentProcessingResultCreateoriginalTagsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DocumentProcessingResultCreateOrConnectWithoutDocumentInput = {
    where: DocumentProcessingResultWhereUniqueInput;
    create: XOR<
      DocumentProcessingResultCreateWithoutDocumentInput,
      DocumentProcessingResultUncheckedCreateWithoutDocumentInput
    >;
  };

  export type DocumentProcessingResultCreateManyDocumentInputEnvelope = {
    data:
      | DocumentProcessingResultCreateManyDocumentInput
      | DocumentProcessingResultCreateManyDocumentInput[];
    skipDuplicates?: boolean;
  };

  export type ProcessingQueueCreateWithoutDocumentInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutProcessingQueueInput;
    aiBot?: AiBotCreateNestedOneWithoutProcessingQueueItemsInput;
  };

  export type ProcessingQueueUncheckedCreateWithoutDocumentInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    aiBotId?: string | null;
  };

  export type ProcessingQueueCreateOrConnectWithoutDocumentInput = {
    where: ProcessingQueueWhereUniqueInput;
    create: XOR<
      ProcessingQueueCreateWithoutDocumentInput,
      ProcessingQueueUncheckedCreateWithoutDocumentInput
    >;
  };

  export type ProcessingQueueCreateManyDocumentInputEnvelope = {
    data: ProcessingQueueCreateManyDocumentInput | ProcessingQueueCreateManyDocumentInput[];
    skipDuplicates?: boolean;
  };

  export type PaperlessInstanceUpsertWithoutDocumentsInput = {
    update: XOR<
      PaperlessInstanceUpdateWithoutDocumentsInput,
      PaperlessInstanceUncheckedUpdateWithoutDocumentsInput
    >;
    create: XOR<
      PaperlessInstanceCreateWithoutDocumentsInput,
      PaperlessInstanceUncheckedCreateWithoutDocumentsInput
    >;
    where?: PaperlessInstanceWhereInput;
  };

  export type PaperlessInstanceUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PaperlessInstanceWhereInput;
    data: XOR<
      PaperlessInstanceUpdateWithoutDocumentsInput,
      PaperlessInstanceUncheckedUpdateWithoutDocumentsInput
    >;
  };

  export type PaperlessInstanceUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    defaultAiBot?: AiBotUpdateOneWithoutDefaultForInstancesNestedInput;
    owner?: UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput;
    sharedWith?: UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput;
    processingQueue?: ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput;
    processingQueue?: ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type DocumentProcessingResultUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentProcessingResultWhereUniqueInput;
    update: XOR<
      DocumentProcessingResultUpdateWithoutDocumentInput,
      DocumentProcessingResultUncheckedUpdateWithoutDocumentInput
    >;
    create: XOR<
      DocumentProcessingResultCreateWithoutDocumentInput,
      DocumentProcessingResultUncheckedCreateWithoutDocumentInput
    >;
  };

  export type DocumentProcessingResultUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentProcessingResultWhereUniqueInput;
    data: XOR<
      DocumentProcessingResultUpdateWithoutDocumentInput,
      DocumentProcessingResultUncheckedUpdateWithoutDocumentInput
    >;
  };

  export type DocumentProcessingResultUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentProcessingResultScalarWhereInput;
    data: XOR<
      DocumentProcessingResultUpdateManyMutationInput,
      DocumentProcessingResultUncheckedUpdateManyWithoutDocumentInput
    >;
  };

  export type DocumentProcessingResultScalarWhereInput = {
    AND?: DocumentProcessingResultScalarWhereInput | DocumentProcessingResultScalarWhereInput[];
    OR?: DocumentProcessingResultScalarWhereInput[];
    NOT?: DocumentProcessingResultScalarWhereInput | DocumentProcessingResultScalarWhereInput[];
    id?: StringFilter<'DocumentProcessingResult'> | string;
    processedAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
    aiProvider?: StringFilter<'DocumentProcessingResult'> | string;
    inputTokens?: IntFilter<'DocumentProcessingResult'> | number;
    outputTokens?: IntFilter<'DocumentProcessingResult'> | number;
    estimatedCost?: FloatNullableFilter<'DocumentProcessingResult'> | number | null;
    changes?: JsonNullableFilter<'DocumentProcessingResult'>;
    toolCalls?: JsonNullableFilter<'DocumentProcessingResult'>;
    originalTitle?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
    originalCorrespondent?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
    originalDocumentType?: StringNullableFilter<'DocumentProcessingResult'> | string | null;
    originalTags?: StringNullableListFilter<'DocumentProcessingResult'>;
    createdAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
    updatedAt?: DateTimeFilter<'DocumentProcessingResult'> | Date | string;
    documentId?: StringFilter<'DocumentProcessingResult'> | string;
  };

  export type ProcessingQueueUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ProcessingQueueWhereUniqueInput;
    update: XOR<
      ProcessingQueueUpdateWithoutDocumentInput,
      ProcessingQueueUncheckedUpdateWithoutDocumentInput
    >;
    create: XOR<
      ProcessingQueueCreateWithoutDocumentInput,
      ProcessingQueueUncheckedCreateWithoutDocumentInput
    >;
  };

  export type ProcessingQueueUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ProcessingQueueWhereUniqueInput;
    data: XOR<
      ProcessingQueueUpdateWithoutDocumentInput,
      ProcessingQueueUncheckedUpdateWithoutDocumentInput
    >;
  };

  export type ProcessingQueueUpdateManyWithWhereWithoutDocumentInput = {
    where: ProcessingQueueScalarWhereInput;
    data: XOR<
      ProcessingQueueUpdateManyMutationInput,
      ProcessingQueueUncheckedUpdateManyWithoutDocumentInput
    >;
  };

  export type PaperlessDocumentCreateWithoutProcessingResultsInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutDocumentsInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentUncheckedCreateWithoutProcessingResultsInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentCreateOrConnectWithoutProcessingResultsInput = {
    where: PaperlessDocumentWhereUniqueInput;
    create: XOR<
      PaperlessDocumentCreateWithoutProcessingResultsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingResultsInput
    >;
  };

  export type PaperlessDocumentUpsertWithoutProcessingResultsInput = {
    update: XOR<
      PaperlessDocumentUpdateWithoutProcessingResultsInput,
      PaperlessDocumentUncheckedUpdateWithoutProcessingResultsInput
    >;
    create: XOR<
      PaperlessDocumentCreateWithoutProcessingResultsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingResultsInput
    >;
    where?: PaperlessDocumentWhereInput;
  };

  export type PaperlessDocumentUpdateToOneWithWhereWithoutProcessingResultsInput = {
    where?: PaperlessDocumentWhereInput;
    data: XOR<
      PaperlessDocumentUpdateWithoutProcessingResultsInput,
      PaperlessDocumentUncheckedUpdateWithoutProcessingResultsInput
    >;
  };

  export type PaperlessDocumentUpdateWithoutProcessingResultsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutDocumentsNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessDocumentUncheckedUpdateWithoutProcessingResultsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessInstanceCreateWithoutProcessingQueueInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    defaultAiBot?: AiBotCreateNestedOneWithoutDefaultForInstancesInput;
    owner: UserCreateNestedOneWithoutOwnedPaperlessInstancesInput;
    sharedWith?: UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateWithoutProcessingQueueInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    importHistory?: ImportHistoryUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceCreateOrConnectWithoutProcessingQueueInput = {
    where: PaperlessInstanceWhereUniqueInput;
    create: XOR<
      PaperlessInstanceCreateWithoutProcessingQueueInput,
      PaperlessInstanceUncheckedCreateWithoutProcessingQueueInput
    >;
  };

  export type PaperlessDocumentCreateWithoutProcessingQueueItemsInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstance: PaperlessInstanceCreateNestedOneWithoutDocumentsInput;
    processingResults?: DocumentProcessingResultCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentUncheckedCreateWithoutProcessingQueueItemsInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    processingResults?: DocumentProcessingResultUncheckedCreateNestedManyWithoutDocumentInput;
  };

  export type PaperlessDocumentCreateOrConnectWithoutProcessingQueueItemsInput = {
    where: PaperlessDocumentWhereUniqueInput;
    create: XOR<
      PaperlessDocumentCreateWithoutProcessingQueueItemsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingQueueItemsInput
    >;
  };

  export type AiBotCreateWithoutProcessingQueueItemsInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiBotsInput;
    aiModel: AiModelCreateNestedOneWithoutBotsInput;
    sharedWith?: UserAiBotAccessCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput;
  };

  export type AiBotUncheckedCreateWithoutProcessingQueueItemsInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiModelId: string;
    sharedWith?: UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput;
  };

  export type AiBotCreateOrConnectWithoutProcessingQueueItemsInput = {
    where: AiBotWhereUniqueInput;
    create: XOR<
      AiBotCreateWithoutProcessingQueueItemsInput,
      AiBotUncheckedCreateWithoutProcessingQueueItemsInput
    >;
  };

  export type PaperlessInstanceUpsertWithoutProcessingQueueInput = {
    update: XOR<
      PaperlessInstanceUpdateWithoutProcessingQueueInput,
      PaperlessInstanceUncheckedUpdateWithoutProcessingQueueInput
    >;
    create: XOR<
      PaperlessInstanceCreateWithoutProcessingQueueInput,
      PaperlessInstanceUncheckedCreateWithoutProcessingQueueInput
    >;
    where?: PaperlessInstanceWhereInput;
  };

  export type PaperlessInstanceUpdateToOneWithWhereWithoutProcessingQueueInput = {
    where?: PaperlessInstanceWhereInput;
    data: XOR<
      PaperlessInstanceUpdateWithoutProcessingQueueInput,
      PaperlessInstanceUncheckedUpdateWithoutProcessingQueueInput
    >;
  };

  export type PaperlessInstanceUpdateWithoutProcessingQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    defaultAiBot?: AiBotUpdateOneWithoutDefaultForInstancesNestedInput;
    owner?: UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput;
    sharedWith?: UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateWithoutProcessingQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessDocumentUpsertWithoutProcessingQueueItemsInput = {
    update: XOR<
      PaperlessDocumentUpdateWithoutProcessingQueueItemsInput,
      PaperlessDocumentUncheckedUpdateWithoutProcessingQueueItemsInput
    >;
    create: XOR<
      PaperlessDocumentCreateWithoutProcessingQueueItemsInput,
      PaperlessDocumentUncheckedCreateWithoutProcessingQueueItemsInput
    >;
    where?: PaperlessDocumentWhereInput;
  };

  export type PaperlessDocumentUpdateToOneWithWhereWithoutProcessingQueueItemsInput = {
    where?: PaperlessDocumentWhereInput;
    data: XOR<
      PaperlessDocumentUpdateWithoutProcessingQueueItemsInput,
      PaperlessDocumentUncheckedUpdateWithoutProcessingQueueItemsInput
    >;
  };

  export type PaperlessDocumentUpdateWithoutProcessingQueueItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutDocumentsNestedInput;
    processingResults?: DocumentProcessingResultUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessDocumentUncheckedUpdateWithoutProcessingQueueItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    processingResults?: DocumentProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput;
  };

  export type AiBotUpsertWithoutProcessingQueueItemsInput = {
    update: XOR<
      AiBotUpdateWithoutProcessingQueueItemsInput,
      AiBotUncheckedUpdateWithoutProcessingQueueItemsInput
    >;
    create: XOR<
      AiBotCreateWithoutProcessingQueueItemsInput,
      AiBotUncheckedCreateWithoutProcessingQueueItemsInput
    >;
    where?: AiBotWhereInput;
  };

  export type AiBotUpdateToOneWithWhereWithoutProcessingQueueItemsInput = {
    where?: AiBotWhereInput;
    data: XOR<
      AiBotUpdateWithoutProcessingQueueItemsInput,
      AiBotUncheckedUpdateWithoutProcessingQueueItemsInput
    >;
  };

  export type AiBotUpdateWithoutProcessingQueueItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput;
    aiModel?: AiModelUpdateOneRequiredWithoutBotsNestedInput;
    sharedWith?: UserAiBotAccessUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateWithoutProcessingQueueItemsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput;
  };

  export type PaperlessInstanceCreateWithoutImportHistoryInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    defaultAiBot?: AiBotCreateNestedOneWithoutDefaultForInstancesInput;
    owner: UserCreateNestedOneWithoutOwnedPaperlessInstancesInput;
    sharedWith?: UserPaperlessInstanceAccessCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceUncheckedCreateWithoutImportHistoryInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutInstanceInput;
    documents?: PaperlessDocumentUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
    processingQueue?: ProcessingQueueUncheckedCreateNestedManyWithoutPaperlessInstanceInput;
  };

  export type PaperlessInstanceCreateOrConnectWithoutImportHistoryInput = {
    where: PaperlessInstanceWhereUniqueInput;
    create: XOR<
      PaperlessInstanceCreateWithoutImportHistoryInput,
      PaperlessInstanceUncheckedCreateWithoutImportHistoryInput
    >;
  };

  export type PaperlessInstanceUpsertWithoutImportHistoryInput = {
    update: XOR<
      PaperlessInstanceUpdateWithoutImportHistoryInput,
      PaperlessInstanceUncheckedUpdateWithoutImportHistoryInput
    >;
    create: XOR<
      PaperlessInstanceCreateWithoutImportHistoryInput,
      PaperlessInstanceUncheckedCreateWithoutImportHistoryInput
    >;
    where?: PaperlessInstanceWhereInput;
  };

  export type PaperlessInstanceUpdateToOneWithWhereWithoutImportHistoryInput = {
    where?: PaperlessInstanceWhereInput;
    data: XOR<
      PaperlessInstanceUpdateWithoutImportHistoryInput,
      PaperlessInstanceUncheckedUpdateWithoutImportHistoryInput
    >;
  };

  export type PaperlessInstanceUpdateWithoutImportHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    defaultAiBot?: AiBotUpdateOneWithoutDefaultForInstancesNestedInput;
    owner?: UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput;
    sharedWith?: UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateWithoutImportHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type UserCreateWithoutAiUsageMetricsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutAiUsageMetricsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutAiUsageMetricsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAiUsageMetricsInput,
      UserUncheckedCreateWithoutAiUsageMetricsInput
    >;
  };

  export type AiAccountCreateWithoutAiUsageMetricsInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiAccountsInput;
    sharedWith?: UserAiAccountAccessCreateNestedManyWithoutAiAccountInput;
    models?: AiModelCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountUncheckedCreateWithoutAiUsageMetricsInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    sharedWith?: UserAiAccountAccessUncheckedCreateNestedManyWithoutAiAccountInput;
    models?: AiModelUncheckedCreateNestedManyWithoutAiAccountInput;
  };

  export type AiAccountCreateOrConnectWithoutAiUsageMetricsInput = {
    where: AiAccountWhereUniqueInput;
    create: XOR<
      AiAccountCreateWithoutAiUsageMetricsInput,
      AiAccountUncheckedCreateWithoutAiUsageMetricsInput
    >;
  };

  export type AiModelCreateWithoutAiUsageMetricsInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiModelsInput;
    aiAccount: AiAccountCreateNestedOneWithoutModelsInput;
    sharedWith?: UserAiModelAccessCreateNestedManyWithoutAiModelInput;
    bots?: AiBotCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelUncheckedCreateWithoutAiUsageMetricsInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiAccountId: string;
    sharedWith?: UserAiModelAccessUncheckedCreateNestedManyWithoutAiModelInput;
    bots?: AiBotUncheckedCreateNestedManyWithoutAiModelInput;
  };

  export type AiModelCreateOrConnectWithoutAiUsageMetricsInput = {
    where: AiModelWhereUniqueInput;
    create: XOR<
      AiModelCreateWithoutAiUsageMetricsInput,
      AiModelUncheckedCreateWithoutAiUsageMetricsInput
    >;
  };

  export type AiBotCreateWithoutAiUsageMetricsInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    owner: UserCreateNestedOneWithoutOwnedAiBotsInput;
    aiModel: AiModelCreateNestedOneWithoutBotsInput;
    sharedWith?: UserAiBotAccessCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotUncheckedCreateWithoutAiUsageMetricsInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
    aiModelId: string;
    sharedWith?: UserAiBotAccessUncheckedCreateNestedManyWithoutAiBotInput;
    defaultForInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutDefaultAiBotInput;
    processingQueueItems?: ProcessingQueueUncheckedCreateNestedManyWithoutAiBotInput;
  };

  export type AiBotCreateOrConnectWithoutAiUsageMetricsInput = {
    where: AiBotWhereUniqueInput;
    create: XOR<
      AiBotCreateWithoutAiUsageMetricsInput,
      AiBotUncheckedCreateWithoutAiUsageMetricsInput
    >;
  };

  export type UserUpsertWithoutAiUsageMetricsInput = {
    update: XOR<
      UserUpdateWithoutAiUsageMetricsInput,
      UserUncheckedUpdateWithoutAiUsageMetricsInput
    >;
    create: XOR<
      UserCreateWithoutAiUsageMetricsInput,
      UserUncheckedCreateWithoutAiUsageMetricsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAiUsageMetricsInput = {
    where?: UserWhereInput;
    data: XOR<UserUpdateWithoutAiUsageMetricsInput, UserUncheckedUpdateWithoutAiUsageMetricsInput>;
  };

  export type UserUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    webAuthnCredentials?: WebAuthnCredentialUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type AiAccountUpsertWithoutAiUsageMetricsInput = {
    update: XOR<
      AiAccountUpdateWithoutAiUsageMetricsInput,
      AiAccountUncheckedUpdateWithoutAiUsageMetricsInput
    >;
    create: XOR<
      AiAccountCreateWithoutAiUsageMetricsInput,
      AiAccountUncheckedCreateWithoutAiUsageMetricsInput
    >;
    where?: AiAccountWhereInput;
  };

  export type AiAccountUpdateToOneWithWhereWithoutAiUsageMetricsInput = {
    where?: AiAccountWhereInput;
    data: XOR<
      AiAccountUpdateWithoutAiUsageMetricsInput,
      AiAccountUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type AiAccountUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiAccountsNestedInput;
    sharedWith?: UserAiAccountAccessUpdateManyWithoutAiAccountNestedInput;
    models?: AiModelUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountUncheckedUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountNestedInput;
    models?: AiModelUncheckedUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiModelUpsertWithoutAiUsageMetricsInput = {
    update: XOR<
      AiModelUpdateWithoutAiUsageMetricsInput,
      AiModelUncheckedUpdateWithoutAiUsageMetricsInput
    >;
    create: XOR<
      AiModelCreateWithoutAiUsageMetricsInput,
      AiModelUncheckedCreateWithoutAiUsageMetricsInput
    >;
    where?: AiModelWhereInput;
  };

  export type AiModelUpdateToOneWithWhereWithoutAiUsageMetricsInput = {
    where?: AiModelWhereInput;
    data: XOR<
      AiModelUpdateWithoutAiUsageMetricsInput,
      AiModelUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type AiModelUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiModelsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutModelsNestedInput;
    sharedWith?: UserAiModelAccessUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiModelAccessUncheckedUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUncheckedUpdateManyWithoutAiModelNestedInput;
  };

  export type AiBotUpsertWithoutAiUsageMetricsInput = {
    update: XOR<
      AiBotUpdateWithoutAiUsageMetricsInput,
      AiBotUncheckedUpdateWithoutAiUsageMetricsInput
    >;
    create: XOR<
      AiBotCreateWithoutAiUsageMetricsInput,
      AiBotUncheckedCreateWithoutAiUsageMetricsInput
    >;
    where?: AiBotWhereInput;
  };

  export type AiBotUpdateToOneWithWhereWithoutAiUsageMetricsInput = {
    where?: AiBotWhereInput;
    data: XOR<
      AiBotUpdateWithoutAiUsageMetricsInput,
      AiBotUncheckedUpdateWithoutAiUsageMetricsInput
    >;
  };

  export type AiBotUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput;
    aiModel?: AiModelUpdateOneRequiredWithoutBotsNestedInput;
    sharedWith?: UserAiBotAccessUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateWithoutAiUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput;
  };

  export type UserCreateWithoutWebAuthnCredentialsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricCreateNestedManyWithoutUserInput;
  };

  export type UserUncheckedCreateWithoutWebAuthnCredentialsInput = {
    id?: string;
    username: string;
    passwordHash: string;
    role?: $Enums.UserRole;
    mustChangePassword?: boolean;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiAccounts?: AiAccountUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiModels?: AiModelUncheckedCreateNestedManyWithoutOwnerInput;
    ownedAiBots?: AiBotUncheckedCreateNestedManyWithoutOwnerInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiModels?: UserAiModelAccessUncheckedCreateNestedManyWithoutUserInput;
    sharedAiBots?: UserAiBotAccessUncheckedCreateNestedManyWithoutUserInput;
    aiUsageMetrics?: AiUsageMetricUncheckedCreateNestedManyWithoutUserInput;
  };

  export type UserCreateOrConnectWithoutWebAuthnCredentialsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutWebAuthnCredentialsInput,
      UserUncheckedCreateWithoutWebAuthnCredentialsInput
    >;
  };

  export type UserUpsertWithoutWebAuthnCredentialsInput = {
    update: XOR<
      UserUpdateWithoutWebAuthnCredentialsInput,
      UserUncheckedUpdateWithoutWebAuthnCredentialsInput
    >;
    create: XOR<
      UserCreateWithoutWebAuthnCredentialsInput,
      UserUncheckedCreateWithoutWebAuthnCredentialsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutWebAuthnCredentialsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutWebAuthnCredentialsInput,
      UserUncheckedUpdateWithoutWebAuthnCredentialsInput
    >;
  };

  export type UserUpdateWithoutWebAuthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutWebAuthnCredentialsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    username?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    mustChangePassword?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownedPaperlessInstances?: PaperlessInstanceUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiAccounts?: AiAccountUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiModels?: AiModelUncheckedUpdateManyWithoutOwnerNestedInput;
    ownedAiBots?: AiBotUncheckedUpdateManyWithoutOwnerNestedInput;
    sharedPaperlessInstances?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiAccounts?: UserAiAccountAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiModels?: UserAiModelAccessUncheckedUpdateManyWithoutUserNestedInput;
    sharedAiBots?: UserAiBotAccessUncheckedUpdateManyWithoutUserNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutUserNestedInput;
  };

  export type PaperlessInstanceCreateManyOwnerInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    defaultAiBotId?: string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
  };

  export type AiAccountCreateManyOwnerInput = {
    id?: string;
    name: string;
    provider: string;
    apiKey: string;
    baseUrl?: string | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AiModelCreateManyOwnerInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiAccountId: string;
  };

  export type AiBotCreateManyOwnerInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    aiModelId: string;
  };

  export type UserPaperlessInstanceAccessCreateManyUserInput = {
    id?: string;
    instanceId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiAccountAccessCreateManyUserInput = {
    id?: string;
    aiAccountId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiModelAccessCreateManyUserInput = {
    id?: string;
    aiModelId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type UserAiBotAccessCreateManyUserInput = {
    id?: string;
    aiBotId: string;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type AiUsageMetricCreateManyUserInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    aiAccountId: string;
    aiModelId?: string | null;
    aiBotId?: string | null;
  };

  export type WebAuthnCredentialCreateManyUserInput = {
    id?: string;
    credentialId: Bytes;
    publicKey: Bytes;
    counter?: bigint | number;
    deviceType?: string;
    backedUp?: boolean;
    transports?: WebAuthnCredentialCreatetransportsInput | string[];
    name?: string | null;
    createdAt?: Date | string;
    lastUsedAt?: Date | string | null;
  };

  export type PaperlessInstanceUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    defaultAiBot?: AiBotUpdateOneWithoutDefaultForInstancesNestedInput;
    sharedWith?: UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    sharedWith?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    defaultAiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AiAccountUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sharedWith?: UserAiAccountAccessUpdateManyWithoutAiAccountNestedInput;
    models?: AiModelUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sharedWith?: UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountNestedInput;
    models?: AiModelUncheckedUpdateManyWithoutAiAccountNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiAccountNestedInput;
  };

  export type AiAccountUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    apiKey?: StringFieldUpdateOperationsInput | string;
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiModelUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccount?: AiAccountUpdateOneRequiredWithoutModelsNestedInput;
    sharedWith?: UserAiModelAccessUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiModelAccessUncheckedUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUncheckedUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiBotUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiModel?: AiModelUpdateOneRequiredWithoutBotsNestedInput;
    sharedWith?: UserAiBotAccessUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
  };

  export type UserPaperlessInstanceAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    instance?: PaperlessInstanceUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instanceId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    instanceId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiAccountAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccount?: AiAccountUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserAiAccountAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiAccountAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiModelAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiModel?: AiModelUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserAiModelAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiModelAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    aiModelId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiBotAccessUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiBot?: AiBotUpdateOneRequiredWithoutSharedWithNestedInput;
  };

  export type UserAiBotAccessUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    aiBotId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiBotAccessUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    aiBotId?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiUsageMetricUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccount?: AiAccountUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiModel?: AiModelUpdateOneWithoutAiUsageMetricsNestedInput;
    aiBot?: AiBotUpdateOneWithoutAiUsageMetricsNestedInput;
  };

  export type AiUsageMetricUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type WebAuthnCredentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type WebAuthnCredentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type WebAuthnCredentialUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    credentialId?: BytesFieldUpdateOperationsInput | Bytes;
    publicKey?: BytesFieldUpdateOperationsInput | Bytes;
    counter?: BigIntFieldUpdateOperationsInput | bigint | number;
    deviceType?: StringFieldUpdateOperationsInput | string;
    backedUp?: BoolFieldUpdateOperationsInput | boolean;
    transports?: WebAuthnCredentialUpdatetransportsInput | string[];
    name?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
  };

  export type UserPaperlessInstanceAccessCreateManyInstanceInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type PaperlessDocumentCreateManyPaperlessInstanceInput = {
    id?: string;
    paperlessId: number;
    title: string;
    content: string;
    correspondentId?: number | null;
    tagIds?: PaperlessDocumentCreatetagIdsInput | number[];
    documentDate?: Date | string | null;
    paperlessModified?: Date | string | null;
    importedAt?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProcessingQueueCreateManyPaperlessInstanceInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    documentId?: string | null;
    aiBotId?: string | null;
  };

  export type ImportHistoryCreateManyPaperlessInstanceInput = {
    id?: string;
    importedAt?: Date | string;
    documentsImported: number;
    documentsUpdated: number;
    documentsUnchanged: number;
    totalInPaperless: number;
  };

  export type UserPaperlessInstanceAccessUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedPaperlessInstancesNestedInput;
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaperlessDocumentUpdateWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processingResults?: DocumentProcessingResultUpdateManyWithoutDocumentNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessDocumentUncheckedUpdateWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    processingResults?: DocumentProcessingResultUncheckedUpdateManyWithoutDocumentNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutDocumentNestedInput;
  };

  export type PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessId?: IntFieldUpdateOperationsInput | number;
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    correspondentId?: NullableIntFieldUpdateOperationsInput | number | null;
    tagIds?: PaperlessDocumentUpdatetagIdsInput | number[];
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paperlessModified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProcessingQueueUpdateWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    document?: PaperlessDocumentUpdateOneWithoutProcessingQueueItemsNestedInput;
    aiBot?: AiBotUpdateOneWithoutProcessingQueueItemsNestedInput;
  };

  export type ProcessingQueueUncheckedUpdateWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ImportHistoryUpdateWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
  };

  export type ImportHistoryUncheckedUpdateWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
  };

  export type ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    importedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    documentsImported?: IntFieldUpdateOperationsInput | number;
    documentsUpdated?: IntFieldUpdateOperationsInput | number;
    documentsUnchanged?: IntFieldUpdateOperationsInput | number;
    totalInPaperless?: IntFieldUpdateOperationsInput | number;
  };

  export type UserAiAccountAccessCreateManyAiAccountInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type AiModelCreateManyAiAccountInput = {
    id?: string;
    name: string;
    modelIdentifier: string;
    inputTokenPrice?: number | null;
    outputTokenPrice?: number | null;
    isActive?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
  };

  export type AiUsageMetricCreateManyAiAccountInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiModelId?: string | null;
    aiBotId?: string | null;
  };

  export type UserAiAccountAccessUpdateWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedAiAccountsNestedInput;
  };

  export type UserAiAccountAccessUncheckedUpdateWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiAccountAccessUncheckedUpdateManyWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiModelUpdateWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiModelsNestedInput;
    sharedWith?: UserAiModelAccessUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiModelAccessUncheckedUpdateManyWithoutAiModelNestedInput;
    bots?: AiBotUncheckedUpdateManyWithoutAiModelNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiModelNestedInput;
  };

  export type AiModelUncheckedUpdateManyWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    modelIdentifier?: StringFieldUpdateOperationsInput | string;
    inputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    outputTokenPrice?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiUsageMetricUpdateWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiModel?: AiModelUpdateOneWithoutAiUsageMetricsNestedInput;
    aiBot?: AiBotUpdateOneWithoutAiUsageMetricsNestedInput;
  };

  export type AiUsageMetricUncheckedUpdateWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutAiAccountInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserAiModelAccessCreateManyAiModelInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type AiBotCreateManyAiModelInput = {
    id?: string;
    name: string;
    systemPrompt: string;
    responseLanguage?: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    ownerId: string;
  };

  export type AiUsageMetricCreateManyAiModelInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiAccountId: string;
    aiBotId?: string | null;
  };

  export type UserAiModelAccessUpdateWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedAiModelsNestedInput;
  };

  export type UserAiModelAccessUncheckedUpdateWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiModelAccessUncheckedUpdateManyWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiBotUpdateWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    owner?: UserUpdateOneRequiredWithoutOwnedAiBotsNestedInput;
    sharedWith?: UserAiBotAccessUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserAiBotAccessUncheckedUpdateManyWithoutAiBotNestedInput;
    aiUsageMetrics?: AiUsageMetricUncheckedUpdateManyWithoutAiBotNestedInput;
    defaultForInstances?: PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotNestedInput;
    processingQueueItems?: ProcessingQueueUncheckedUpdateManyWithoutAiBotNestedInput;
  };

  export type AiBotUncheckedUpdateManyWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    systemPrompt?: StringFieldUpdateOperationsInput | string;
    responseLanguage?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    ownerId?: StringFieldUpdateOperationsInput | string;
  };

  export type AiUsageMetricUpdateWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiBot?: AiBotUpdateOneWithoutAiUsageMetricsNestedInput;
  };

  export type AiUsageMetricUncheckedUpdateWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutAiModelInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type UserAiBotAccessCreateManyAiBotInput = {
    id?: string;
    userId?: string | null;
    permission?: $Enums.Permission;
    createdAt?: Date | string;
  };

  export type AiUsageMetricCreateManyAiBotInput = {
    id?: string;
    provider: string;
    model: string;
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
    estimatedCost?: number | null;
    documentId?: number | null;
    createdAt?: Date | string;
    userId: string;
    aiAccountId: string;
    aiModelId?: string | null;
  };

  export type PaperlessInstanceCreateManyDefaultAiBotInput = {
    id?: string;
    name: string;
    apiUrl: string;
    apiToken: string;
    importFilterTags?: PaperlessInstanceCreateimportFilterTagsInput | number[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    autoProcessEnabled?: boolean;
    scanCronExpression?: string;
    lastScanAt?: Date | string | null;
    nextScanAt?: Date | string | null;
    autoApplyTitle?: boolean;
    autoApplyCorrespondent?: boolean;
    autoApplyDocumentType?: boolean;
    autoApplyTags?: boolean;
    autoApplyDate?: boolean;
    ownerId: string;
  };

  export type ProcessingQueueCreateManyAiBotInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    documentId?: string | null;
  };

  export type UserAiBotAccessUpdateWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutSharedAiBotsNestedInput;
  };

  export type UserAiBotAccessUncheckedUpdateWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserAiBotAccessUncheckedUpdateManyWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AiUsageMetricUpdateWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiAccount?: AiAccountUpdateOneRequiredWithoutAiUsageMetricsNestedInput;
    aiModel?: AiModelUpdateOneWithoutAiUsageMetricsNestedInput;
  };

  export type AiUsageMetricUncheckedUpdateWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type AiUsageMetricUncheckedUpdateManyWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    provider?: StringFieldUpdateOperationsInput | string;
    model?: StringFieldUpdateOperationsInput | string;
    promptTokens?: IntFieldUpdateOperationsInput | number;
    completionTokens?: IntFieldUpdateOperationsInput | number;
    totalTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    documentId?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    userId?: StringFieldUpdateOperationsInput | string;
    aiAccountId?: StringFieldUpdateOperationsInput | string;
    aiModelId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PaperlessInstanceUpdateWithoutDefaultAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    owner?: UserUpdateOneRequiredWithoutOwnedPaperlessInstancesNestedInput;
    sharedWith?: UserPaperlessInstanceAccessUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateWithoutDefaultAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
    sharedWith?: UserPaperlessInstanceAccessUncheckedUpdateManyWithoutInstanceNestedInput;
    documents?: PaperlessDocumentUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    processingQueue?: ProcessingQueueUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
    importHistory?: ImportHistoryUncheckedUpdateManyWithoutPaperlessInstanceNestedInput;
  };

  export type PaperlessInstanceUncheckedUpdateManyWithoutDefaultAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    apiUrl?: StringFieldUpdateOperationsInput | string;
    apiToken?: StringFieldUpdateOperationsInput | string;
    importFilterTags?: PaperlessInstanceUpdateimportFilterTagsInput | number[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    autoProcessEnabled?: BoolFieldUpdateOperationsInput | boolean;
    scanCronExpression?: StringFieldUpdateOperationsInput | string;
    lastScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    nextScanAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    autoApplyTitle?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyCorrespondent?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDocumentType?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyTags?: BoolFieldUpdateOperationsInput | boolean;
    autoApplyDate?: BoolFieldUpdateOperationsInput | boolean;
    ownerId?: StringFieldUpdateOperationsInput | string;
  };

  export type ProcessingQueueUpdateWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutProcessingQueueNestedInput;
    document?: PaperlessDocumentUpdateOneWithoutProcessingQueueItemsNestedInput;
  };

  export type ProcessingQueueUncheckedUpdateWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    documentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ProcessingQueueUncheckedUpdateManyWithoutAiBotInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    documentId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type DocumentProcessingResultCreateManyDocumentInput = {
    id?: string;
    processedAt?: Date | string;
    aiProvider: string;
    inputTokens?: number;
    outputTokens?: number;
    estimatedCost?: number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: string | null;
    originalCorrespondent?: string | null;
    originalDocumentType?: string | null;
    originalTags?: DocumentProcessingResultCreateoriginalTagsInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ProcessingQueueCreateManyDocumentInput = {
    id?: string;
    paperlessDocumentId: number;
    status?: string;
    priority?: number;
    attempts?: number;
    maxAttempts?: number;
    lastError?: string | null;
    scheduledFor?: Date | string;
    startedAt?: Date | string | null;
    completedAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    paperlessInstanceId: string;
    aiBotId?: string | null;
  };

  export type DocumentProcessingResultUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentProcessingResultUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DocumentProcessingResultUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    aiProvider?: StringFieldUpdateOperationsInput | string;
    inputTokens?: IntFieldUpdateOperationsInput | number;
    outputTokens?: IntFieldUpdateOperationsInput | number;
    estimatedCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    changes?: NullableJsonNullValueInput | InputJsonValue;
    toolCalls?: NullableJsonNullValueInput | InputJsonValue;
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null;
    originalCorrespondent?: NullableStringFieldUpdateOperationsInput | string | null;
    originalDocumentType?: NullableStringFieldUpdateOperationsInput | string | null;
    originalTags?: DocumentProcessingResultUpdateoriginalTagsInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ProcessingQueueUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstance?: PaperlessInstanceUpdateOneRequiredWithoutProcessingQueueNestedInput;
    aiBot?: AiBotUpdateOneWithoutProcessingQueueItemsNestedInput;
  };

  export type ProcessingQueueUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type ProcessingQueueUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string;
    paperlessDocumentId?: IntFieldUpdateOperationsInput | number;
    status?: StringFieldUpdateOperationsInput | string;
    priority?: IntFieldUpdateOperationsInput | number;
    attempts?: IntFieldUpdateOperationsInput | number;
    maxAttempts?: IntFieldUpdateOperationsInput | number;
    lastError?: NullableStringFieldUpdateOperationsInput | string | null;
    scheduledFor?: DateTimeFieldUpdateOperationsInput | Date | string;
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    paperlessInstanceId?: StringFieldUpdateOperationsInput | string;
    aiBotId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
