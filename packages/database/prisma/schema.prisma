generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// App Settings (Key-Value Store)
// =============================================================================

model Setting {
  settingKey   String   @id // e.g. "security.sharing.mode"
  settingValue String // e.g. "basic" | "advanced"
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

// =============================================================================
// User & Permissions
// =============================================================================

enum UserRole {
  DEFAULT
  ADMIN
}

model User {
  id                 String   @id @default(cuid())
  username           String   @unique
  passwordHash       String
  role               UserRole @default(DEFAULT)
  mustChangePassword Boolean  @default(true) // New users must change initial password
  isActive           Boolean  @default(true) // Soft-delete: false = suspended
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Owned resources
  ownedPaperlessInstances PaperlessInstance[]
  ownedAiAccounts         AiAccount[]
  ownedAiModels           AiModel[]
  ownedAiBots             AiBot[]

  // Shared access
  sharedPaperlessInstances UserPaperlessInstanceAccess[]
  sharedAiAccounts         UserAiAccountAccess[]
  sharedAiModels           UserAiModelAccess[]
  sharedAiBots             UserAiBotAccess[]

  // Usage tracking
  aiUsageMetrics AiUsageMetric[]

  // WebAuthn credentials
  webAuthnCredentials WebAuthnCredential[]

  @@index([role])
  @@index([isActive])
}

// Permission levels for shared resources
enum Permission {
  READ
  WRITE
  FULL
}

// Join table: User <-> PaperlessInstance (shared access)
// Note: userId=NULL means "shared with all users"
model UserPaperlessInstanceAccess {
  id         String            @id @default(cuid())
  user       User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String?
  instance   PaperlessInstance @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  instanceId String
  permission Permission        @default(READ)
  createdAt  DateTime          @default(now())

  @@unique([userId, instanceId])
  @@index([userId])
  @@index([instanceId])
}

// Join table: User <-> AiAccount (shared access)
// Note: userId=NULL means "shared with all users"
model UserAiAccountAccess {
  id          String     @id @default(cuid())
  user        User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String?
  aiAccount   AiAccount  @relation(fields: [aiAccountId], references: [id], onDelete: Cascade)
  aiAccountId String
  permission  Permission @default(READ)
  createdAt   DateTime   @default(now())

  @@unique([userId, aiAccountId])
  @@index([userId])
  @@index([aiAccountId])
}

// Join table: User <-> AiModel (shared access)
// Note: userId=NULL means "shared with all users"
model UserAiModelAccess {
  id         String     @id @default(cuid())
  user       User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String?
  aiModel    AiModel    @relation(fields: [aiModelId], references: [id], onDelete: Cascade)
  aiModelId  String
  permission Permission @default(READ)
  createdAt  DateTime   @default(now())

  @@unique([userId, aiModelId])
  @@index([userId])
  @@index([aiModelId])
}

// Join table: User <-> AiBot (shared access)
// Note: userId=NULL means "shared with all users"
model UserAiBotAccess {
  id         String     @id @default(cuid())
  user       User?      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String?
  aiBot      AiBot      @relation(fields: [aiBotId], references: [id], onDelete: Cascade)
  aiBotId    String
  permission Permission @default(READ)
  createdAt  DateTime   @default(now())

  @@unique([userId, aiBotId])
  @@index([userId])
  @@index([aiBotId])
}

// =============================================================================
// Paperless-NGX Integration
// =============================================================================

model PaperlessInstance {
  id               String   @id @default(cuid())
  name             String
  apiUrl           String
  apiToken         String // Never expose in UI after saving
  importFilterTags Int[]    @default([]) // Only import documents with ALL of these tags (empty = import all)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Scheduling configuration
  autoProcessEnabled  Boolean   @default(false)
  scanCronExpression  String    @default("0 * * * *") // Default: every hour
  lastScanAt          DateTime?
  nextScanAt          DateTime?

  // Default AI Bot for auto-processing
  defaultAiBot   AiBot?  @relation("DefaultAiBotForInstance", fields: [defaultAiBotId], references: [id], onDelete: SetNull)
  defaultAiBotId String?

  // Auto-apply settings (which fields to automatically apply after AI analysis)
  autoApplyTitle         Boolean @default(false)
  autoApplyCorrespondent Boolean @default(false)
  autoApplyDocumentType  Boolean @default(false)
  autoApplyTags          Boolean @default(false)
  autoApplyDate          Boolean @default(false)

  // Owner
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Restrict)
  ownerId String

  // Shared access
  sharedWith UserPaperlessInstanceAccess[]

  // Related documents
  documents       PaperlessDocument[]
  processingQueue ProcessingQueue[]
  importHistory   ImportHistory[]

  @@index([ownerId])
  @@index([autoProcessEnabled, nextScanAt])
}

// =============================================================================
// AI Configuration
// =============================================================================

model AiAccount {
  id        String   @id @default(cuid())
  name      String
  provider  String // openai | anthropic | ollama | google | custom
  apiKey    String // Never expose in UI after saving
  baseUrl   String? // Optional for Custom/Ollama endpoints
  isActive  Boolean  @default(true) // Soft-delete for audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Owner
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Restrict)
  ownerId String

  // Shared access
  sharedWith UserAiAccountAccess[]

  // Related models
  models         AiModel[]
  aiUsageMetrics AiUsageMetric[]

  @@index([ownerId])
  @@index([isActive])
}

model AiModel {
  id               String   @id @default(cuid())
  name             String
  modelIdentifier  String // e.g. "gpt-4.1-mini", "claude-3-opus"
  inputTokenPrice  Float? // Price per 1M input tokens
  outputTokenPrice Float? // Price per 1M output tokens
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Owner
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Restrict)
  ownerId String

  // AI Account (parent)
  aiAccount   AiAccount @relation(fields: [aiAccountId], references: [id], onDelete: Restrict)
  aiAccountId String

  // Shared access
  sharedWith UserAiModelAccess[]

  // Related bots
  bots           AiBot[]
  aiUsageMetrics AiUsageMetric[]

  @@index([ownerId])
  @@index([aiAccountId])
  @@index([isActive])
}

model AiBot {
  id               String   @id @default(cuid())
  name             String
  systemPrompt     String
  responseLanguage String   @default("DOCUMENT")
  documentMode     String   @default("text") // 'text' | 'pdf'
  pdfMaxSizeMb     Int? // null = use global setting
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Owner
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Restrict)
  ownerId String

  // AI Model configuration
  aiModel   AiModel @relation(fields: [aiModelId], references: [id], onDelete: Restrict)
  aiModelId String

  // Shared access
  sharedWith UserAiBotAccess[]

  // Usage tracking
  aiUsageMetrics AiUsageMetric[]

  // Default bot for instances (reverse relation)
  defaultForInstances PaperlessInstance[] @relation("DefaultAiBotForInstance")

  // Processing queue items using this bot
  processingQueueItems ProcessingQueue[]

  @@index([ownerId])
  @@index([aiModelId])
}

// =============================================================================
// Paperless Documents
// =============================================================================

model PaperlessDocument {
  id                String    @id @default(cuid())
  paperlessId       Int
  title             String
  content           String    @db.Text
  correspondentId   Int?
  tagIds            Int[]
  documentDate      DateTime? // Date of the document from Paperless (created field)
  paperlessModified DateTime? // Last modified timestamp from Paperless (for sync detection)
  importedAt        DateTime  @default(now())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Link to Paperless instance
  paperlessInstance   PaperlessInstance @relation(fields: [paperlessInstanceId], references: [id], onDelete: Cascade)
  paperlessInstanceId String

  // AI processing results
  processingResults DocumentProcessingResult[]

  // Processing queue entries
  processingQueueItems ProcessingQueue[]

  @@unique([paperlessInstanceId, paperlessId])
  @@index([paperlessInstanceId])
  @@index([paperlessInstanceId, documentDate])
}

// =============================================================================
// Document Processing Results
// =============================================================================

model DocumentProcessingResult {
  id            String   @id @default(cuid())
  processedAt   DateTime @default(now())
  aiProvider    String
  inputTokens   Int      @default(0)
  outputTokens  Int      @default(0)
  estimatedCost Float?

  // Store what was changed (AI suggestions)
  changes Json?

  // Store tool calls made during analysis
  toolCalls Json?

  // Original values before processing
  originalTitle         String?
  originalCorrespondent String?
  originalDocumentType  String?
  originalTags          String[] @default([])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Link to PaperlessDocument
  document   PaperlessDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId String

  @@index([processedAt])
  @@index([documentId])
}

model ProcessingQueue {
  id                   String    @id @default(cuid())
  paperlessDocumentId  Int       // The document ID in Paperless-ngx
  status               String    @default("pending") // pending | processing | completed | failed
  priority     Int       @default(0)
  attempts     Int       @default(0)
  maxAttempts  Int       @default(3)
  lastError    String?   @db.Text
  scheduledFor DateTime  @default(now())
  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Link to Paperless instance
  paperlessInstance   PaperlessInstance @relation(fields: [paperlessInstanceId], references: [id], onDelete: Cascade)
  paperlessInstanceId String

  // Link to document (set after document is imported/found)
  document   PaperlessDocument? @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId String?

  // AI Bot to use for processing
  aiBot   AiBot?  @relation(fields: [aiBotId], references: [id], onDelete: SetNull)
  aiBotId String?

  @@unique([paperlessInstanceId, paperlessDocumentId])
  @@index([status, scheduledFor])
  @@index([paperlessDocumentId])
  @@index([paperlessInstanceId])
}

// =============================================================================
// Import History (for dashboard charts)
// =============================================================================

model ImportHistory {
  id                 String   @id @default(cuid())
  importedAt         DateTime @default(now())
  documentsImported  Int // New documents created
  documentsUpdated   Int // Existing documents updated
  documentsUnchanged Int // Documents that didn't need updating
  totalInPaperless   Int // Total document count in Paperless at import time

  // Link to Paperless instance
  paperlessInstance   PaperlessInstance @relation(fields: [paperlessInstanceId], references: [id], onDelete: Cascade)
  paperlessInstanceId String

  @@index([paperlessInstanceId, importedAt])
}

// =============================================================================
// Usage Tracking
// =============================================================================

model AiUsageMetric {
  id               String   @id @default(cuid())
  provider         String
  model            String
  promptTokens     Int
  completionTokens Int
  totalTokens      Int
  estimatedCost    Float?
  documentId       Int?
  createdAt        DateTime @default(now())

  // Who caused this usage
  user   User   @relation(fields: [userId], references: [id])
  userId String

  aiAccount   AiAccount @relation(fields: [aiAccountId], references: [id], onDelete: Restrict)
  aiAccountId String

  // Which model was used (optional, for tracking)
  aiModel   AiModel? @relation(fields: [aiModelId], references: [id], onDelete: SetNull)
  aiModelId String?

  // Which bot was used (optional, for tracking)
  aiBot   AiBot?  @relation(fields: [aiBotId], references: [id], onDelete: SetNull)
  aiBotId String?

  @@index([createdAt])
  @@index([provider])
  @@index([userId])
  @@index([aiModelId])
  @@index([aiBotId])
}

// =============================================================================
// WebAuthn (Passkey) Authentication
// =============================================================================

model WebAuthnCredential {
  id           String    @id @default(cuid())
  credentialId Bytes     @unique // Base64URL decoded credential ID
  publicKey    Bytes // COSE public key
  counter      BigInt    @default(0) // Signature counter for replay protection
  deviceType   String    @default("singleDevice") // "singleDevice" | "multiDevice"
  backedUp     Boolean   @default(false) // Whether credential is backed up (e.g., iCloud Keychain)
  transports   String[] // Array of transport hints: "usb", "ble", "nfc", "internal"
  name         String? // User-friendly name for the passkey (e.g., "MacBook Pro")
  createdAt    DateTime  @default(now())
  lastUsedAt   DateTime?

  // Link to User
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  @@index([userId])
}

model WebAuthnChallenge {
  id        String   @id @default(cuid())
  challenge String   @unique // The random challenge string
  type      String // "registration" | "authentication"
  userId    String? // For registration challenges, links to user
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([challenge])
  @@index([expiresAt])
}
